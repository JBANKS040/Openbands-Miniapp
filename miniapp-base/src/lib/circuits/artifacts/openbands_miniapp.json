{
    "noir_version": "1.0.0-beta.11+fd3925aaaeb76c76319f44590d135498ef41ea6c",
    "hash": "14907161465630189072",
    "abi": {
        "parameters": [
            {
                "name": "partial_data",
                "type": {
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec",
                    "fields": [
                        {
                            "name": "storage",
                            "type": {
                                "kind": "array",
                                "length": 640,
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 8
                                }
                            }
                        },
                        {
                            "name": "len",
                            "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        }
                    ]
                },
                "visibility": "private"
            },
            {
                "name": "partial_hash",
                "type": {
                    "kind": "array",
                    "length": 8,
                    "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                    }
                },
                "visibility": "private"
            },
            {
                "name": "full_data_length",
                "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                },
                "visibility": "private"
            },
            {
                "name": "base64_decode_offset",
                "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                },
                "visibility": "private"
            },
            {
                "name": "jwt_pubkey_modulus_limbs",
                "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 128
                    }
                },
                "visibility": "private"
            },
            {
                "name": "jwt_pubkey_redc_params_limbs",
                "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 128
                    }
                },
                "visibility": "private"
            },
            {
                "name": "jwt_signature_limbs",
                "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 128
                    }
                },
                "visibility": "private"
            },
            {
                "name": "domain",
                "type": {
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec",
                    "fields": [
                        {
                            "name": "storage",
                            "type": {
                                "kind": "array",
                                "length": 64,
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 8
                                }
                            }
                        },
                        {
                            "name": "len",
                            "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        }
                    ]
                },
                "visibility": "public"
            }
        ],
        "return_type": {
            "abi_type": {
                "kind": "field"
            },
            "visibility": "public"
        },
        "error_types": {
            "2920182694213909827": {
                "error_kind": "string",
                "string": "attempt to subtract with overflow"
            },
            "5019202896831570965": {
                "error_kind": "string",
                "string": "attempt to add with overflow"
            },
            "5675127253506927136": {
                "error_kind": "string",
                "string": "utils::search could not find needle in haystack"
            },
            "5727012404371710682": {
                "error_kind": "string",
                "string": "push out of bounds"
            },
            "5795655218219125583": {
                "error_kind": "string",
                "string": "Field failed to decompose into specified 8 limbs"
            },
            "6314603625877298116": {
                "error_kind": "string",
                "string": "haystack length of size 0 not supported"
            },
            "6485997221020871071": {
                "error_kind": "string",
                "string": "call to assert_max_bit_size"
            },
            "6543056410826478903": {
                "error_kind": "string",
                "string": "incorrect value for claim"
            },
            "6668324276689745315": {
                "error_kind": "string",
                "string": "Field failed to decompose into specified 4 limbs"
            },
            "7233212735005103307": {
                "error_kind": "string",
                "string": "attempt to multiply with overflow"
            },
            "7788270038095378938": {
                "error_kind": "string",
                "string": "substring not present in main text (match found if a padding text included. is main text correctly formatted?)"
            },
            "8403890105346170400": {
                "error_kind": "string",
                "string": "Field failed to decompose into specified 31 limbs"
            },
            "9281715815618326061": {
                "error_kind": "string",
                "string": "invalid domain"
            },
            "10713088778935619315": {
                "error_kind": "string",
                "string": "char before domain is not '@'"
            },
            "11393010598460336492": {
                "error_kind": "fmtstring",
                "length": 58,
                "item_types": [
                    {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                    },
                    {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                    }
                ]
            },
            "11856048133850814249": {
                "error_kind": "string",
                "string": "Field failed to decompose into specified 1 limbs"
            },
            "13815800804469369678": {
                "error_kind": "string",
                "string": "partial_data length is too long"
            },
            "14225679739041873922": {
                "error_kind": "string",
                "string": "Index out of bounds"
            },
            "14870952237766754546": {
                "error_kind": "string",
                "string": "Field failed to decompose into specified 30 limbs"
            },
            "15412340888643424233": {
                "error_kind": "string",
                "string": "needle length of size 0 not supported"
            },
            "17135372224865900210": {
                "error_kind": "string",
                "string": "Field failed to decompose into specified 15 limbs"
            },
            "17843811134343075018": {
                "error_kind": "string",
                "string": "Stack too deep"
            }
        }
    },
    "bytecode": "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",
    "debug_symbols": "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PGWdp1xXU66rKes8ZZ2nrPOUdZZ8Jf3ttvrb8/hD1jlknUPWOeS6knxVQ9aZ9Ssz1q/M2C9qJs+DJs+DxvqVGetXZpKvpL/djPUrM3keNNavzFi/MmP9ykzylbF+Zcb6lRnrV2asX5nJ86DJ86CxfmXG+pWZ5Cvpbzdj/cpMngeN9Ssz1q/MWL8yk3xlJutsss6sX5mxfmUmz4Mmz4Nmss4m6yz5SvrbzVi/MpPnQXNZZ5d1Zv3KTPKVuayzyzqzfmXmcl3J86DJ86A1Wecm6yz5SvrbzVi/MpPnQWuyzk3Wuct1JfnKuqxzl3Xucl11ua7kedDkedC6rHOXdZZ8Jf3tZqxfmcnzoA1Z5yHrPOS6knxlQ9Z5yDpPua6mXFfyPGjyPGhT1nnKOku+kv52syn+ledBC1nnkHUOua4kX1nIOoesc8h1FXJdyfOgyfOgS/3KpX7lkq+kv91c6lcuz4Mu9SuX+pVL/colX7nUr1zqVy71K5f6lcvzoMvzoEv9yqV+5ZKvpL/dXOpXLs+DLvUrl/qVS/3KJV+51K9c6lcu9SuX+pXL86DL86BL/cqlfuWSr6S/3VzqVy7Pgy71K5f6lUv9yiVfudSvXOpXLvUrl/qVy/Ogy/OgS/3KpX7lkq+kv91c6lcuz4Mu9SuX+pVL/colX7nUr1zqVy71K5f6lcvzoMvzoEv9yqV+5ZKvpL/dXOpXLs+DLvUrl/qVS/3KJV+51K9c6lcu9SuX+pXL86DL86BL/cqlfuWSr6S/3VzqVy7Pgy71K5f6lUv9yiVfudSvXOpXLvUrl/qVy/Ogy/OgS/3KpX7lkq+kv92a1K+aPA82qV81qV81qV81yVdN6ldN6ldN6ldN6lcyv91kfrvJ/HaT+e0m89tN+tutSf2qyfNgk/pVk/pVk/pVk3zVpH7VpH7VpH7VpH4l89tN5rebzG83md9uMr/dpL/dmtSvmjwPNqlfNalfNalfNclXTepXTepXTepXTepXMr/dZH67yfx2k/ntJvPbTfrbrUn9qsnzYJP6VZP6VZP6VZN81aR+1aR+1aR+1aR+JfPbTea3m8xvN5nfbjK//cVyvlK/avI82KR+1aR+1aR+1SRfyfx2k/ntJvPbrUn9Sua3m8xvN5nfbk3qV03yVZN81aR+JfPbTea3W5P6VZP6VZN8JfPbrUn9qkn9qkn9Sua3m8xvN5nfbk3qV03yVZN81aR+JfPbTea3W5P6VZf6VZd8JfPbrUv9qkv9qkv9Sua3m8xvN5nfbl3qV13yVZd81aV+JfPbTea3W5f6VZf6VZd8JfPbrUv9qkv9qkv9Sua3m8xvN5nfbl3qV13yVZd81aV+JfPbTea3W5f6VZf6VZd8JfPbrUv9qkv9qkv9Sua3m8xvN5nfbl3qV13yVZd81aV+JfPbTea3W5f6VZf6VZd8JfPbrUv9qkv9qkv9Sua3m8xvN5nfbl3qV13yVZd81aV+JfPbTea3W5f6VZf6VZd8JfPbrUv9qkv9qkv9Sua3m8xvN5nfbl3qV13yVZd81aV+JfPbTea3W5f6VZf6VZd8JfPbrUv9qkv9qkv9Sua3m8xvN5nfbl3qV13yVZd81aV+JfPbTea3W5f6VZf6VZd8JfPbrUv9akj9akj9Sua3m8xvN5nfbkPqV0Py1ZB8NaR+JfPbTea325D61ZD61ZB8JfPbbUj9akj9akj9Sua3m8xvN5nfbkPqV0Py1ZB8NaR+JfPbTea325D61ZD61ZB8JfPbbUj9akj9akj9Sua3m8xvN5nfbkPqV0Py1ZB8NaR+JfPbTea325D61ZD61ZB8JfPbbUj9akj9akj9Sua3m8xvN5nfbkPqV0Py1ZB8NaR+JfPbTea325D61ZD61ZB8JfPbbUj9akj9akj9Sua3m8xvN5nfbkPqV0Py1ZB8NaR+JfPbTea325D61ZD61ZB8JfPbbUj9akj9akj9Sua3m8xvN5nfbkPqV0Py1ZB8NaR+JfPbTea325D61ZD61ZB8JfPbbUj9akj9akj9Sua3m8xvN5nfblPqV1Py1ZR8NaV+JfPbTea325T61ZT61ZR8JfPbbUr9akr9akr9Sua3m8xvN5nfblPqV1Py1ZR8NaV+JfPbTea325T61ZT61ZR8JfPbbUr9akr9akr9SvrbTfrbTfrbTfrbTfrbTfrbbUr9Sua3m8xvtyn1qyn1qyn5Sua325T61ZT61ZT6lfS3m/S3m/S3m/S3m/S3m/S325T6lcxvN5nfblPqV1PqV1Pylcxvtyn1qyn1qyn1K+lvN+lvN+lvN+lvN+lvN+lvtyn1K5nfbjK/3abUr6bUr6bkqyn5akq+Wv3tLXkIT+Egn/nq4CKMfV42uX/QJvcP2uT+QZvcP2iT+wdtcv+gTe4ftMn9gza5f9BmiG6IbohuiG6IbohuiC73D1pw/6AF9w9acP+gBfcPWnD/oAX3D1pw/6AF9w9acP+gxSa6RXSL6BbRLaJbRLeIbhHdIrpFdIvoVtGtoltFt4puFd0qulV0q+hW0a2ia6Jromuia6Jromuia6Jromuia6Lrouui66Lrouui66Lrouui66LrottEt4luE90muk10m+g20W2i20S3iW4X3S66XXS76HbR7aLbRbeLbhfdLrpDdIfoDtEdojtEd4juEN0hukN0h+hO0Z2iK/kqJF+F5KuQfBWSr0LyVUi+CslXIfkqJF+F5KuQfBWSr0LyVUi+CslXIfkqmK98Y77yjfnKN+Yr35ivfGO+8o35yjfmK9+Yr3xjvvJtE90iukV0i+gW0S2iW0S3iG4R3SK6RXSr6FbRraJbRbeKbhXdKrpVdKvoVtE10TXRNdE10TXRNdE10TXRNdE10XXRddF10XXRddF10XXRddF10XXRbaLbRLeJbhPdJrpNdJvoNtE985UlB/nMVwcX4Spswi7chLvwEBZd7nf2jfudfeN+Z9+439k37nf2jfudfeN+Z9+439k37nf2jfudfRuiO0V3iu4U3Sm6U3Sn6E7RnaI7RXeKbohuiG6IbohuiG6IbohuiG6ILvc7e+F+5xcX4Spswi7chLvwEJ7ColtEt4huEd0iukV0i+gW0S2iW0S3iG4V3Sq6VXSr6FbRraJbRbeKbhXdKromuia6Jromuia65+/Rj+QuPISn8PG8sO3M+pUXzuvzwudBl/ntLvPbXea3u/S3u/S3u8xvd5nf7jK/3WV+u8v8di+sX3lh/coL61demug20W2i20S3i24X3S66XXS76HbR7aLbRbeLbhfdIbpDdIfoDtEdojtEd4juEN0hukN0p+hO0Z2iO0V3iu4U3Sm6U3Sn6E7RDdEN0Q3RDdEN0Q3RDdEN0Q3RZf3KZX67V9avvLJ+5ZX1K6+st3tlvd2lv92lv92lv92lv92lv92lv92lv90r61deWW/3ynq7V9bbvRbRLaJb6F+Z3+4yv90r+xlc5re7zG93md/u0t/u0t/uMr/dZX67y/x2l/ntLvPbXea3u8xvd5nf7jK/3WV+u8v8dpf57S7z213mt7vMb3fpb3eZ3+4yv91lfrvL/HaX+e0u89td5re7zG93md/uMr/dZX67y/x2l/ntLvPbXea3u/S3u8xvd5nf7jK/3WV+u8v8dpf57S7z213mt7vMb3eZ3+4yv91lfrvL/HaX+e0u89td+ttd5re7zG93md/uMr/dZX67y/x2l/ntLvPbXea3u8xvd5nf7jK/3WV+u8v8dpf57S797S7z213mt7vMb3eZ3+4yv91lfrvL/HaX+e0u89td5re7zG93md/uMr/dZX67y/x2l/52l/ntLvPbXea3u8xvd5nf7jK/3WV+u8v8dpf57S7z213mt7vMb3eZ3+4yv91lfrtLf7vL/HaX+e0u89td5re7zG93md/uMr/dZX67y/x2l/ntLvPbXea3u8xvd5nf7jK/3aW/3WV+u8v8dpf57S7z213mt7vMb3eZ3+4yv91lfrvL/HaX+e0u89td5re7zG93md/u0t/uMr/dZX67y/x2l/ntLvPbXea3u8xvd5nf7jK/3WV+u8v8dpf57S7z213mt7vMb3fpb3eZ3+4yv91lfrvL/HaX+e0u89td5re7zG93md/uMr/dZX67y/x2l/ntLvPbXea3u/S3u8xvd5nf7jK/3WV+u8v8dpf57S7z213mt7vMb3eZ3+4yv91lfrvL/HaX+e0u89td+ttd5re7zG93md/uMr/dZX67y/x2l/ntLvPbXea3u8xvd5nf7jK/3WV+u8v8dpf57S797S7z213mt7vMb3eZ3+4yv91lfrvL/HaX+e0u89td5re7zG93md/uMr/dZX67y/x2l/52l/ntLvPbXea3u8xvd5nf7jK/3WV+u8v8dpf57S7z213mt7vMb3eZ3+4yv91lfrtLf7vL/HaX+e0u89td5re7zG93md/uMr/dZX67y/x2l/ntLvPbXea3u8xvd5nf7jK/3aW/3WV+u8v8dpf57S7z213mt7vMb3eZ3+4yv91lfrvL/HaX+e0u89td5re7zG93md/u0t/uMr/dZX67y/x2l/ntLvPbXea3u8xvd5nf7jK/3WV+u8v8dpf57S7z213mt7vMb3fpb3eZ3+4yv91lfrvL/HaX+e0u89td5re7zG93md/uMr/dZX67y/x2l/ntLvPbXea3u/S3u8xvd5nf7jK/3WV+u8v8dpf57S7z213mt7vMb3eZ3+4yv91lfrvL/HaX+e0u89td+ttd5re7zG93md/uMr/dZX67y/x2l/ntLvPbXea3u8xvd5nf7jK/3WV+u8v8dpf57S79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uDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnHJh6beGzisYnXJl6beG3itYnXJl6beG3itYnXJl6beG3itYnXJl6beG3itYnXJl6beG3itYnXJl6beG3itYnXJl6beG3itYnXJl6beG3itYnXJl6beG3itYnXJl6beG3itYnXJl6beG3itYnXJl6beG3itYnXJl6beG3itYnXJl6beG3itYnXJl6beG3itYnXJl6beG3itYnXJl6beG3itYnXJl6beG3itYnXJl6beG3itYnXJl6beG3itYnXJl6beG3itYnXJl6beG3itYnXJl6beG3itYnXJl6beG3itYnXJl6beG2ijiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJ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jiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6lwibqWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKx/N+CCXQs/7dY/57jwglsoo6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6liqbqGMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQs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S+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6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2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk08NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTL028fzTx/tHE+0cT7x9NvH808f7RxPtHE+8fTbx/NPH+/TlBOEE4QThBOEE4QThBOEE4QThBOEE6QTpBOkE6QTpBOkE6QTpBOkE6QTlBOUE5QTlBOUE5QTlBOUE5QTlBO0E7QTtBO0E7QTtBO0E7QTtBO8E4wTjBOME4wTjBOME4wTjBOME4weMEjxM8TvA4weMEjxM8TvA4weMEjxOsE6wTrBOsE6wTrBOsE6wTrBOsExwnOE5wnOA4wXGC4wTHCY4THCc4TnCd4DrBdYLrBNcJrhNcJ7hOcJ3AJoZNDJsYNjFsYtjEsIlhE8Mmhk0Mmxg2MWxi2MSwiWETwyaGTQybGDYxbGLYxLCJYRPDJoZNDJsYNjFsYtjEsIlhE8Mmhk0Mmxg2MWxi2MSwiWETwyaGTQybGDYxbGLYxLCJYRPDJoZNDJsYNjFsYtjEsIlhE8Mmhk0Mmxg2MWxi2MSwiWETwyaGTQybGDYxbGLYxLCJYRPDJoZNDJsYNjFsYtjEsIlhE8Mmhk0Mmxg2MWxi2MSwiWETwyaGTQybGDYxbGLYxLCJYRPDJoZNDJsYNjFsYtrEtIlpE9Mmpk1Mm5g2MW1i2sS0iWkT0yamTUybmDYxbWLaxLSJaRPTJqZNTJuYNjFtYtrEtIlpE9Mmpk1Mm5g2MW1i2sS0iWkT0yamTUybmDYxbWLaxLSJaRPTJqZNTJuYNjFtYtrEtIlpE9Mmpk1Mm5g2MW1i2sS0iWkT0yamTUybmDYxbWLaxLSJaRPTJqZNTJuYNjFtYtrEtIlpE9Mmpk1Mm5g2MW1i2sS0iWkT0yamTUybmDYxbWLaxLSJaRPTJqZNTJuYNjFtYtrEtIlpE9Mmlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm1g2sWxi28S2iW0T2ya2TWyb2DaxbWLbxLaJbRPbJrZNbJvYNrFtYtvEtoltE9smtk1sm9g2sW1i28S2iW0T2ya2TWyb2DaxbWLbxLaJbRPbJrZNbJvYNrFtYtvEtoltE9smtk1sm9g2sW1i28S2iW0T2ya2TWyb2DaxbWLbxLaJbRPbJrZNbJvYNrFtYtvEtoltE9smtk1sm9g2sW1i28S2iW0T2ya2TWyb2DaxbWLbxLaJbRPbJrZNbJvYNrFtYtvEtoltE9smtk1sm9g2sW1i28S2iW0T2yaOTRybODZxbOLYxLGJYxPHJo5NHJs4NnFs4tjEsYljE8cmjk0cmzg2cWzi2MSxiWMTxyaOTRybODZxbOLYxLGJYxPHJo5NHJs4NnFs4tjEsYljE8cmjk0cmzg2cWzi2MSxiWMTxyaOTRybODZxbKKO5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epY7udY8v0rbxOr3sV/E9R9F/9N0H/vol2Mi/8m6O9Hrz/g+LHLx94mfh97m/h97G3i72Plx5zgbeLvY48fWz92/NjlY28Tv4+9Tfw+Nv47GP8dvE38fWz82OPH1o8dP3b52NvE72NvE7+PvU38faz8WPsxd+FxFx534XEXHndh3YV1F9ZdWHdh3YV1F9ZdWHdh3YV1F467cNyF4y4cd+G4C8ddOO7CcReOu3DchesuXHfhugvXXbjuwnUXrrtw3YXrLlx24XMs78c+x/J+7HMsv4+VH2s/Nn7s8WPrx44fYxc+x/J9LNiFz7H8PlZ+rP3Y+LHHj60fO36MXfgcy/exZBc+x/L7WPmx9mPjxx4/tn7s+DF3odyFchfK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",
    "file_map": {
        "5": {
            "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n}\n",
            "path": "std/cmp.nr"
        },
        "6": {
            "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n",
            "path": "std/collections/bounded_vec.nr"
        },
        "17": {
            "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
            "path": "std/field/bn254.nr"
        },
        "18": {
            "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
            "path": "std/field/mod.nr"
        },
        "22": {
            "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\n/// Asserts the validity of the provided proof and public inputs against the provided verification key and hash.\n///\n/// The ACVM cannot determine whether the provided proof is valid during execution as this requires knowledge of\n/// the backend against which the program is being proven. However if an invalid proof if submitted, the program may\n/// fail to prove or the backend may generate a proof which will subsequently fail to verify.\n///\n/// # Important Note\n///\n/// If you are not developing your own backend such as [Barretenberg](https://github.com/AztecProtocol/barretenberg)\n/// you probably shouldn't need to interact with this function directly. It's easier and safer to use a verification\n/// library which is published by the developers of the backend which will document or enforce any safety requirements.\n///\n/// If you use this directly, you're liable to introduce underconstrainedness bugs and *your circuit will be insecure*.\n///\n/// # Arguments\n/// - verification_key: The verification key of the circuit to be verified.\n/// - proof: The proof to be verified.\n/// - public_inputs: The public inputs associated with `proof`\n/// - key_hash: The hash of `verification_key` of the form expected by the backend.\n/// - proof_type: An identifier for the proving scheme used to generate the proof to be verified. This allows\n///               for a single backend to support verifying multiple proving schemes.\n///\n/// # Constraining `key_hash`\n///\n/// The Noir compiler does not by itself constrain that `key_hash` is a valid hash of `verification_key`.\n/// This is because different backends may differ in how they hash their verification keys.\n/// It is then the responsibility of either the noir developer (by explicitly hashing the verification key\n/// in the correct manner) or by the proving system itself internally asserting the correctness of `key_hash`.\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n",
            "path": "std/lib.nr"
        },
        "50": {
            "source": "mod zk_jwt;\nmod tests;\n\nuse zk_jwt::{\n    extra_zeros_removal::{remove_extra_zeros_from_partial_data},\n    utils::{decimal_string_to_field, get_domain_start_index_in_email},\n    nullifier_generator::{\n        generate_nullifier_with_poseidon2,\n        generate_nullifier_with_pedersen,\n    },\n};\n\nuse jwt::JWT;\n\nuse poseidon::poseidon2;                 // @dev - For v1.0.0-beta.11 of Noir/Nargo, we need to use this module for Poseidon hash\n//use std::hash::poseidon2::Poseidon2;   // @dev - For v1.0.0-beta.6 of Noir/Nargo, we are still able to use this module for Poseidon hash\n\nglobal MAX_PARTIAL_DATA_LENGTH: u32 = 640; // signed data length after partial SHA\nglobal MAX_DOMAIN_LENGTH: u32 = 64;\nglobal MAX_EMAIL_LENGTH: u32 = 128;\nglobal NONCE_LENGTH: u32 = 77;\n\n/**\n * @brief Verify JWT signature (RSA/SHA256 only) and validate hd and nonce fields\n *\n * @param partial_data: OIDC JWT (id_token) base64 data (`$header.$payload`) as byte array of ascii characters\n *                      We do partial SHA on the data up to hd field outside of the circuit, to reduce constraints\n *                      This field only contains the bytes after partial SHA; padded to MAX_PARTIAL_DATA_LENGTH\n * @param partial_hash: The 256-bit partial hash of the `data`\n * @param full_data_length: The full length of the `data` (before partial SHA)\n * @param b64_offset: Offset needed in `partial_data` to make the payloadB64 a multiple of 4\n *                    Signed data is $header.$payload. $payload might not be a multiple of 4 in `partial_data`, so we need to offset\n *                    Not attack-able by giving an incorrect offset, as string match of hd and nonce will fail\n * @param jwt_pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n * @param jwt_pubkey_redc_params_limbs: RSA reduction parameters limbs\n * @param jwt_signature_limbs: RSA signature limbs\n * @param domain: Domain name (`hd` key) as a byte array of ascii characters padded to MAX_DOMAIN_LENGTH\n * @param ephemeral_pubkey: Public key of the ephemeral keypair that is used to sign messages\n * @param ephemeral_pubkey_salt: Salt of the ephemeral keypair that is used to sign messages\n * @param ephemeral_pubkey_expiry: Expiry of the ephemeral keypair that is used to sign messages\n * @param nonce: JWT `nonce` as a byte array of ascii characters - 32 bytes\n **/\nfn main(\n    partial_data: BoundedVec<u8, MAX_PARTIAL_DATA_LENGTH>,\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    jwt_pubkey_modulus_limbs: [u128; 18],\n    jwt_pubkey_redc_params_limbs: [u128; 18],\n    jwt_signature_limbs: [u128; 18],\n    domain: pub BoundedVec<u8, MAX_DOMAIN_LENGTH>\n    //ephemeral_pubkey: pub Field,\n    //ephemeral_pubkey_salt: Field,\n    //ephemeral_pubkey_expiry: pub u32,\n) -> pub Field {\n    // @dev - Remove extra zeros, which are added to an original \"partial_data\" when it is inputted from the frontend, from an original \"partial_data\"\n    let _partial_data: BoundedVec<u8, MAX_PARTIAL_DATA_LENGTH> = unsafe { remove_extra_zeros_from_partial_data(partial_data) };\n    println(f\"_partial_data: {_partial_data}\\n\");\n\n    // Init JWT struct and verify signature\n    let jwt = JWT::init_with_partial_hash(\n        //partial_data,\n        _partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        jwt_pubkey_modulus_limbs,\n        jwt_pubkey_redc_params_limbs,\n        jwt_signature_limbs,\n    );\n    jwt.verify();\n\n    // // Get nonce claim\n    // let nonce: BoundedVec<u8, NONCE_LENGTH> = jwt.get_claim_string(\"nonce\".as_bytes());\n    // let nonce_field: Field = decimal_string_to_field(nonce.storage());\n\n    // // Verify nonce is the hash(ephemeral_pubkey, ephemeral_pubkey_salt, ephemeral_pubkey_expiry)\n    // let ephemeral_pubkey_hash = Poseidon2::hash(\n    //     [ephemeral_pubkey, ephemeral_pubkey_salt, ephemeral_pubkey_expiry as Field],\n    //     3,\n    // );\n\n    // assert(nonce_field == ephemeral_pubkey_hash, \"invalid nonce\");\n\n    // Assert email_verified claim\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n\n    // Get email claim\n    let email: BoundedVec<u8, MAX_EMAIL_LENGTH> = jwt.get_claim_string(\"email\".as_bytes());\n\n    // Get domain start_index from email claim - unconstrained, but we verify the domain bytes below\n    let domain_start_index = unsafe { get_domain_start_index_in_email(email) };\n\n    // Verify domain passed is present in the email claim after the @\n    assert(email.storage()[domain_start_index - 1] == 64, \"char before domain is not '@'\");\n    for i in 0..MAX_DOMAIN_LENGTH {\n        assert(email.storage()[domain_start_index + i] == domain.storage()[i], \"invalid domain\");\n    }\n\n    // @dev - Email\n    let email_bytes: [u8; MAX_EMAIL_LENGTH] = email.storage();\n    println(f\"email_bytes: {email_bytes}\\n\");\n    let email_field: Field = Field::from_be_bytes(email_bytes);\n    println(f\"email_field: {email_field}\\n\");\n\n    // @dev - Calculate a nullifier\n    let nullifier = generate_nullifier_with_poseidon2([email_field, full_data_length as Field, base64_decode_offset as Field]);\n    //let nullifier = generate_nullifier_with_poseidon2([full_data_length as Field, base64_decode_offset as Field]);\n    //let nullifier = generate_nullifier_with_pedersen([full_data_length as Field, base64_decode_offset as Field]);\n    //let nullifier = generate_nullifier([ephemeral_pubkey_hash, full_data_length as Field, base64_decode_offset as Field]);\n\n    // @dev - Return the nullifier\n    nullifier\n}\n",
            "path": "/Users/unomasanori/Projects/actual-projects/OpenBands/Openbands-Miniapp/Openbands-Miniapp_ZK-circuit_and_contracts/circuits/src/main.nr"
        },
        "55": {
            "source": "use crate::{ MAX_PARTIAL_DATA_LENGTH };\n\n/**\n * @dev - Remove extra zeros, which are added to an original \"partial_data\" when it is inputted from the frontend, from an original \"partial_data\"\n */\nunconstrained pub fn remove_extra_zeros_from_partial_data(partial_data: BoundedVec<u8, MAX_PARTIAL_DATA_LENGTH>) -> BoundedVec<u8, MAX_PARTIAL_DATA_LENGTH> {\n    let mut start_index = 0;\n    let mut zero_start_index = 0;\n    let len = partial_data.len();\n    for i in 0..len {\n        if partial_data.storage()[i] == 0 {\n            zero_start_index = i;\n            start_index = i + 1;\n            break;\n        }\n    }\n\n    let mut new_vector: BoundedVec<u8, MAX_PARTIAL_DATA_LENGTH> = BoundedVec::new();\n    for c in 0..len {\n        if partial_data.storage()[c] > 0 {\n            new_vector.push(partial_data.storage()[c]);\n        } else if partial_data.storage()[c] == 0 {\n            break;\n        }\n    }\n    println(f\"new_vector (which is a recreated partial_data from an original partial_data): {new_vector}\\n\");\n\n    new_vector\n}\n\n\n\n// pub fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\n// where\n//     T: Empty + Eq,\n// {\n//     let mut len = 0;\n//     for elem in array {\n//         if !is_empty(elem) {\n//             len += 1;\n//         }\n//     }\n//     BoundedVec::from_parts_unchecked(array, len)\n// }\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty + Eq,\n// {\n//     item.eq(T::empty())\n// }\n\n// trait Empty {\n//     fn empty() -> Self;\n// }\n\n// impl Empty for u8 {\n//     fn empty() -> Self {\n//         0\n//     }\n// }",
            "path": "/Users/unomasanori/Projects/actual-projects/OpenBands/Openbands-Miniapp/Openbands-Miniapp_ZK-circuit_and_contracts/circuits/src/zk_jwt/extra_zeros_removal.nr"
        },
        "57": {
            "source": "use poseidon::poseidon2;                 // @dev - For the Noir/Nargo v1.0.0-beta.11, we need to use this module for Poseidon hash\n//use std::hash::poseidon2::Poseidon2;   // @dev - For the Noir/Nargo v1.0.0-beta.6, we are still able to use this module for Poseidon hash\nuse std::hash::pedersen_hash;\n\n/** \n * @notice - Calculate a nullifier using Poseidon2 hash\n */\npub fn generate_nullifier_with_poseidon2(inputs: [Field; 3]) -> Field {   // @dev - For the Noir/Nargo v1.0.0-beta.11\n//pub fn generate_nullifier_with_poseidon2(inputs: [Field; _]) -> Field { // @dev - For the Noir/Nargo v1.0.0-beta.6\n    // @dev - For the Noir/Nargo v1.0.0-beta.11\n    let nullifier_hash = poseidon2::Poseidon2::hash(\n        inputs,\n        inputs.len() as u32\n    );\n\n    // @dev - For the Noir/Nargo v1.0.0-beta.6\n    // let nullifier_hash = Poseidon2::hash(\n    //     inputs,\n    //     inputs.len() as u32\n    // );\n\n    nullifier_hash\n}\n\n/** \n * @notice - Calculate a nullifier using Pedersen hash\n */\npub fn generate_nullifier_with_pedersen(inputs: [Field; 3]) -> Field {   // @dev - For the Noir/Nargo v1.0.0-beta.11\n//pub fn generate_nullifier_with_pedersen(inputs: [Field; _]) -> Field { // @dev - For the Noir/Nargo v1.0.0-beta.6\n    let nullifier_hash = pedersen_hash(\n        inputs\n    );\n    nullifier_hash\n}",
            "path": "/Users/unomasanori/Projects/actual-projects/OpenBands/Openbands-Miniapp/Openbands-Miniapp_ZK-circuit_and_contracts/circuits/src/zk_jwt/nullifier_generator.nr"
        },
        "58": {
            "source": "use crate::{MAX_EMAIL_LENGTH};\n\npub fn decimal_string_to_field<let LEN: u32>(decimal_bytes: [u8; LEN]) -> Field {\n    assert(LEN <= 77);\n\n    let mut field: Field = 0;\n    let mut multiplier: Field = 1;\n\n    for i in 0..LEN {\n        let ascii_char = decimal_bytes[LEN - i - 1];\n        if ascii_char >= 48 & ascii_char <= 57 {\n            let digit = ascii_char as Field - 48;\n            field += digit * multiplier;\n            multiplier *= 10;\n        }\n    }\n\n    field\n}\n\nunconstrained pub fn get_domain_start_index_in_email(email: BoundedVec<u8, MAX_EMAIL_LENGTH>) -> u32 {\n    let mut domain_start_index = 0;\n    for i in 0..MAX_EMAIL_LENGTH {\n        if email.storage()[i] == (\"@\".as_bytes())[0] {\n            domain_start_index = i + 1;\n            break;\n        }\n    }\n\n    domain_start_index\n}",
            "path": "/Users/unomasanori/Projects/actual-projects/OpenBands/Openbands-Miniapp/Openbands-Miniapp_ZK-circuit_and_contracts/circuits/src/zk_jwt/utils.nr"
        },
        "59": {
            "source": "mod partial_hash;\n\nuse base64::BASE64_URL_DECODER;\nuse bignum::{params::BigNumParams, RuntimeBigNum};\nuse nodash::str_to_u64;\nuse partial_hash::partial_sha256_var_end;\nuse rsa::rsa::verify_sha256_pkcs1v15;\nuse sha256::sha256_var;\nuse string_search::{StringBody, SubString};\n\n/**\n * @brief Struct representing a JWT. Use the init functions to create an instance\n *        Currently only supports RSA 2048/SHA256 signatures\n **/\npub struct JWT<let MAX_DATA_LENGTH: u32> {\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    pubkey_modulus_limbs: [u128; 18],\n    redc_params_limbs: [u128; 18],\n    signature_limbs: [u128; 18],\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    is_partial_hash: bool, // compile time variable used internally\n}\n\nimpl<let MAX_DATA_LENGTH: u32> JWT<MAX_DATA_LENGTH> {\n    /**\n    * @brief Initialize JWT struct\n    *\n    * @param data: Signed JWT data (base64 encoded `$header.$payload`) as byte array of ascii characters\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Any 4x multiple from the payload start index.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs (2048-bit split into 18 limbs)\n    * @param signature_limbs: RSA signature limbs (2048-bit split into 18 limbs)\n    **/\n    pub fn init(\n        data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(data.len() <= MAX_DATA_LENGTH, \"data length is too long\");\n\n        JWT {\n            data,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            // below fields are not relevant unless for partial hash\n            full_data_length: MAX_DATA_LENGTH,\n            partial_hash: [0; 8],\n            is_partial_hash: false,\n        }\n    }\n\n    /**\n    * @brief Initialize JWT with partial SHA256 hash'ed input\n    *        Since SHA hash is expensive to compute in circuit, we can optimize by pre-hashing up to a certain block outside the circuit,\n    *        and verify for correctness in the circuit. This is possible since SHA works in incremental blocks.\n    *        You can pre-hash up to the SHA-256 block from where you want to extract a claim.\n    *\n    * @param partial_data: Signed JWT data (base64 encoded `$header.$payload`) after partial hashed block\n    * @param partial_hash: The 256-bit partial hash of the `partial_data` up to a certain block\n    * @param full_data_length: The full length of the `data` (before partial SHA)\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Trimming `offset` nubmer of bytes from the data should it base64 decode-able.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs\n    * @param signature_limbs: RSA signature limbs\n    **/\n    pub fn init_with_partial_hash(\n        partial_data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        partial_hash: [u32; 8],\n        full_data_length: u32,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(partial_data.len() <= MAX_DATA_LENGTH, \"partial_data length is too long\");\n\n        JWT {\n            data: partial_data,\n            full_data_length,\n            partial_hash,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            is_partial_hash: true,\n        }\n    }\n\n    /**\n    * @brief Verify JWT signature with RSA 2048/SHA256\n    **/\n    pub fn verify(mut self) {\n        let mut data_hash: [u8; 32] = [0; 32];\n\n        if (!self.is_partial_hash) {\n            // this is a compile time conditional\n            // Hash the data using SHA256\n            data_hash = sha256_var(self.data.storage(), self.data.len() as u64);\n        } else {\n            // Compute the full SHA256 hash with the given partial hash\n            data_hash = partial_sha256_var_end(\n                self.partial_hash,\n                self.data.storage(),\n                self.data.len() as u64,\n                self.full_data_length as u64,\n            );\n        }\n\n        // Verify RSA signature\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(false, self.pubkey_modulus_limbs, self.redc_params_limbs);\n\n        let signature = RuntimeBigNum { params, limbs: self.signature_limbs };\n\n        assert(verify_sha256_pkcs1v15(data_hash, signature, 65537));\n    }\n\n    /**\n    * @brief Get a string claim from the JWT payload\n    *\n    * @param KEY_LENGTH: The length of the claim key\n    * @param MAX_VALUE_LENGTH: The maximum length of the claim value\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        self.get_claim::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key, true)\n    }\n\n    /**\n    * @brief Assert a string claim in the JWT payload.\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: BoundedVec<u8, MAX_VALUE_LENGTH>,\n    ) {\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> =\n            self.get_claim_string::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a number (u64) claim from the JWT payload\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_number<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> u64 {\n        let claim = self.get_claim::<KEY_LENGTH, 20>(claim_key, false);\n        str_to_u64(claim.storage())\n    }\n\n    /**\n    * @brief Assert a number (u64) claim in the JWT payload.\n    *        Refer to `get_claim_number` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_number<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: u64,\n    ) {\n        let value = self.get_claim_number::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a boolean claim from the JWT payload\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_bool<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> bool {\n        let value = self.get_claim::<KEY_LENGTH, 5>(claim_key, false);\n        let mut is_true = true;\n        for i in 0..4 {\n            is_true = is_true & (value.storage()[i] == \"true\".as_bytes()[i]);\n        }\n        let is_false = value.storage() == \"false\".as_bytes();\n\n        assert(is_true | is_false, \"incorrect value for claim\");\n        is_true\n    }\n\n    /**\n    * @brief Assert a boolean claim in the JWT payload.\n    *        Refer to `get_claim_bool` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_bool<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: bool,\n    ) {\n        let value = self.get_claim_bool::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Internal function to get claim bytes from the JWT payload\n    **/\n    fn get_claim<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        //Safety: extract the value in unconstrained mode, and verify later\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> = unsafe {\n            self.extract_claim_unconstrained::<KEY_LENGTH, MAX_VALUE_LENGTH>(\n                claim_key,\n                is_value_quoted,\n            )\n        };\n\n        // constrain the extracted value is present in the payload using string_search lib\n        // haystack is the base64 decoded payload;\n        let haystack = self.prepare_haystack();\n\n        // needle is the key with quotes around it - searching for just the key string might return false positives from elsewhere\n        // Note: key length is known at compile time as this lib doesn't support runtime keys\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = claim_key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle\n            : SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // assert value after quoted key is a colon\n        let colon_index = position + KEY_LENGTH + 2; // +2 for the quotes around the key\n        assert(haystack.body[colon_index] == 58); // :\n\n        // assert the value is correct - string have quotes around them, numbers and booleans don't\n        let mut value_start_index = colon_index + 1; // Value starts after the colon\n        let mut index_after_value = value_start_index + value.len(); // Index after the value, quoted or otherwise\n\n        if (is_value_quoted) {\n            // adjust start index for the quotes around the value\n            value_start_index = value_start_index + 1; // Adjust for the quote before the value\n            index_after_value = index_after_value + 2; // Adjust for the quotes around the value\n\n            // assert the char before and after the value is a quote\n            assert(haystack.body[value_start_index - 1] == 34); // \"\n            assert(haystack.body[index_after_value - 1] == 34); // \"\n        }\n\n        // assert the value is correct\n        for i in 0..MAX_VALUE_LENGTH {\n            if (i < value.len()) {\n                assert(haystack.body[value_start_index + i] == value.storage()[i]);\n            }\n        }\n\n        // assert the char after the value is a comma or a closing brace (last claim in the payload)\n        let char_after_value = haystack.body[index_after_value];\n        assert((char_after_value == 44) | (char_after_value == 125)); // , or }\n\n        value\n    }\n\n    /**\n    * @brief Internal function to prepare the haystack for string search (base64 decoded payload with offset applied)\n    **/\n    fn prepare_haystack(\n        self,\n    ) -> StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> {\n        // We need to decode the payload from the payload_b64_offset; i.e. data.slice(0, base64_decode_offset)\n        let mut data_to_b64_decode: [u8; MAX_DATA_LENGTH] = [0; MAX_DATA_LENGTH];\n\n        // Conditional inside the for loop blows up the constraint size\n        // So we fill the full MAX_DATA_LENGTH (rotate on overflow) and prepare a BoundedVec with the correct length later\n        for i in 0..MAX_DATA_LENGTH {\n            data_to_b64_decode[i] =\n                self.data.storage()[(i + self.base64_decode_offset) % self.data.len()];\n        }\n\n        let data_to_decode_bv: BoundedVec<u8, MAX_DATA_LENGTH> = BoundedVec::from_parts(\n            data_to_b64_decode,\n            self.data.len() - self.base64_decode_offset,\n        );\n\n        // Decode the payload\n        let payload: BoundedVec<u8, ((MAX_DATA_LENGTH / 4) * 3)> =\n            BASE64_URL_DECODER::decode_var(data_to_decode_bv); // b64 decoded length is ceil(MAX_DATA_LENGTH / 3) * 4\n\n        // Create the haystack\n        let haystack: StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> =\n            StringBody::new(payload.storage(), payload.len());\n\n        haystack\n    }\n\n    /**\n    * @brief Unconstrained function to extract claim bytes from the JWT payload\n    **/\n    pub unconstrained fn extract_claim_unconstrained<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        let haystack = self.prepare_haystack();\n\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle\n            : SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // Get the value after the key\n        let mut value_start_idx = position + key.len() + 3; // +3 for the quote around the key and the colon\n        if (is_value_quoted) {\n            value_start_idx += 1; // +1 for the quote before the value\n        }\n\n        let mut value: BoundedVec<u8, MAX_VALUE_LENGTH> = BoundedVec::new();\n\n        for i in 0..MAX_VALUE_LENGTH {\n            let val = haystack.body[value_start_idx + i];\n            if ((val == 34) | (val == 44) | (val == 125)) {\n                break;\n            }\n            value.push(haystack.body[value_start_idx + i]);\n        }\n\n        value\n    }\n}\n\n#[test]\nfn test_verify() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_verify_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_get_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_get_claim_string_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_assert_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let value: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    jwt.assert_claim_string(\"email\".as_bytes(), value);\n}\n\n#[test]\nfn test_get_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let iat: u64 = jwt.get_claim_number(\"iat\".as_bytes());\n    let expected_iat: u64 = 1737642217;\n    assert(iat == expected_iat);\n}\n\n#[test]\nfn test_assert_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let expected_iat: u64 = 1737642217;\n    jwt.assert_claim_number(\"iat\".as_bytes(), expected_iat);\n}\n\n#[test]\nfn test_get_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email_verified: bool = jwt.get_claim_bool(\"email_verified\".as_bytes());\n    assert(email_verified);\n}\n\n#[test]\nfn test_assert_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n}\n\n#[test]\nfn test_get_last_claim() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let exp: u64 = jwt.get_claim_number(\"exp\".as_bytes()); // exp is the last claim in the test payload\n    let expected_exp: u64 = 1799999999;\n    assert(exp == expected_exp);\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/zkemail/noir-jwt/saleel/deps-update-beta11/src/lib.nr"
        },
        "60": {
            "source": "// Copied form https://raw.githubusercontent.com/zkemail/zkemail.nr/refs/heads/main/lib/src/partial_hash.nr\n// Use dependency one zkemail.nr is updated to bignum 0.6.0\n\nuse std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L23\n// Convert 64-byte array to array of 16 u32s\npub fn msg_u8_to_u32(msg: [u8; BLOCK_SIZE]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4 * (i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L38\nunconstrained fn build_msg_block_iter<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> ([u8; BLOCK_SIZE], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L59\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32,\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE: u32 = 64;\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L86-L116\n/**\n * Partially computes a SHA256 hash of a message but does not finalize\n * @notice can be used for post-partial hashing where client proves part of hash and relies on server to finish\n * \n *\n * @param N: the length of the message to hash.\n *  --- WARNING: N must be divisible by BLOCK_SIZE such that N % BLOCK_SIZE == 0 \n *      otherwise the remaining bytes will not be inputted when computing the initial hash\n * @param msg: the preimage to begin hashing\n * @return the intermediate hash state\n */\npub fn partial_sha256_var_start<let N: u32>(msg: [u8; N]) -> [u32; 8] {\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block_iter(msg, N, msg_start) };\n        if msg_start < N {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, N, msg_block, msg_start);\n            if msg_start < N {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < N {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < N) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    h\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block_iter(msg, N, msg_start) };\n        if msg_start < N {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, N, msg_block, msg_start);\n            if msg_start < N {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < N {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < N) & (msg_byte_ptr == BLOCK_SIZE) & (msg_start < message_size) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    h\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L85\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the remaining preimage\n * @param real_message_size -= the total size of the preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u64,\n    real_message_size: u64,\n) -> [u8; 32] {\n    let message_size = message_size as u32; // noir stdlib uses u64\n    let real_message_size = real_message_size as u32; // noir stdlib uses u64\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block_iter(msg, message_size, msg_start) };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block_iter(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !is_unconstrained() {\n        for i in 0..64 {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..64 {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, real_message_size) };\n\n    if !is_unconstrained() {\n        for i in 0..56 {\n            if i < msg_byte_ptr {\n                assert_eq(msg_block[i], last_block[i]);\n            } else {\n                assert_eq(msg_block[i], zero);\n            }\n        }\n\n        let len = 8 * real_message_size;\n        let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n        for i in 56..64 {\n            assert_eq(msg_block[i], len_bytes[i - 56]);\n        }\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; BLOCK_SIZE],\n    mut msg_byte_ptr: u32,\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: [u8; BLOCK_SIZE],\n    mut msg_byte_ptr: u32,\n    message_size: u32,\n) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4 * j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/zkemail/noir-jwt/saleel/deps-update-beta11/src/partial_hash.nr"
        },
        "62": {
            "source": "unconstrained fn __boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let mut r: [Field; Range] = [0; Range];\n    for i in limit..Range {\n        r[i] = 1;\n    }\n    r\n}\n\n/**\n * @brief Return a size-Range array of values that describe whether an index `i` is in the range `0<=i<limit`\n * @details When evaluating variable-length loops of size `limit`, it is neccessary to iterate over a maximum bound defined at compile-time\n *          Any constraints or evaluations that occur where `i >= limit` must be discarded.\n *          This is most efficiently performed by using predicate `Field` values, where `predicate[i] = 0` if `i < limit`, otherwise `predicate[i] = 1`.\n *          This method efficiently generates such predicate values more efficiently than querying whether `i <= limit` at every iteration.\n *          Gate cost is 3 * Range\n **/\npub fn boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    // Safety: r contains claims about whether `r[i] >= limit`. the rest of this function checks this claim is correct\n    let r = unsafe { __boundary_check(limit) };\n\n    let mut transition_index = 0;\n    // **\n    // We have an array of Field elements `r` such that:\n    // if i < limit, `r = 0`\n    // if i >= limit, `r = 1`\n    // We validate the predicate list `r` is correct by checking:\n    // 1. every r[i] element is 0 or 1\n    // 2. if r[i] = 1, r[i+1] must also be 1\n    // 3. if r[i] = 0 and r[i+1] = 1, then i == limit\n    // we check point 3 by tracking a `transition_index` variable, where\n    // transition_index += (1 - r[i]) * (r[i+1]) * i\n    // i.e. if r[i] == 0 and r[i+1] == 1, transition_index += i\n    //      else transition_index += 0\n    // NOTE: total constraint cost is 3 gates per iteration\n    // **\n    if Range > 0 {\n        for i in 0..Range - 1 {\n            assert_eq(r[i] * r[i], r[i]);\n            assert_eq(r[i] * r[i + 1], r[i]);\n            let idx = (r[i + 1] * (1 - r[i])) * (i as Field + 1);\n            transition_index = transition_index + idx;\n            std::as_witness(transition_index);\n        }\n        assert_eq(r[Range - 1] * r[Range - 1], r[Range - 1]);\n        transition_index = transition_index + (1 - r[Range - 1]) * limit as Field;\n        assert(transition_index == limit as Field);\n        r\n    } else {\n        [0; Range]\n    }\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/noir_base64/v0.4.2/src/boundary_check.nr"
        },
        "63": {
            "source": "use super::defaults::{\n    BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK, INVALID_DECODE_VALUE,\n};\n\npub use crate::boundary_check::boundary_check;\nuse crate::tables::{\n    BASE64_DECODE_BE_TABLE, BASE64_DECODE_BE_URL_TABLE, BASE64_DECODE_BE_URL_VAR_TABLE,\n    BASE64_DECODE_BE_VAR_TABLE,\n};\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\npub mod Base64DecodeBE {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 0>(input)\n    }\n}\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4), but WITHOUT padding\npub mod Base64DecodeBENoPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 0>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5\npub mod Base64DecodeBEUrlSafe {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 1>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5, but WITH padding added\npub mod Base64DecodeBEUrlSafeWithPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 1>(input)\n    }\n}\n\n/**\n * @brief Return a human-readable error if the input is invalid Base64\n * @details We constrain the decoding to be correct by using a lookup table to decode Base64.\n *          Validation is performed by batch-checking that no lookups returned an error state.\n *          This produces unhelpful error messages so we put this sanitised check in an unconstrained fn\n **/\nunconstrained fn __validate_decoded(decoded: Field, input_byte: u8, offset: u32) {\n    assert(\n        decoded != INVALID_DECODE_VALUE,\n        f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n    );\n}\n\n/**\n * @brief Given a variable-sized number of Base64 encoded characters, return a *claim* about how many are padding chars\n * @note The returned value is only a claim and must be validated\n **/\nunconstrained fn __get_num_padding_chars_var<let InputElements: u32>(\n    input: BoundedVec<u8, InputElements>,\n) -> (bool, bool) {\n    let len = input.len();\n    let r1 = if len > 1 {\n        input.get(len - 2) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    let r2 = if len > 0 {\n        input.get(len - 1) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    (r1, r2)\n}\n\n/**\n * @brief Take an array of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\nfn decode<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; OutputBytes] {\n    let rem = OutputBytes % 3;\n    // Calculate the number of padding characters and the length of the input without padding\n    let num_padding_chars = if rem == 1 {\n        2\n    } else if rem == 2 {\n        1\n    } else {\n        0\n    };\n\n    // Assert that the output length & input length are correct\n    // Every 3 output chars will be encoded as 4 base64 input chars\n    let encoded_length = (OutputBytes + 2) / 3 * 4; // ceil(input * 4 / 3)\n    if Pad != 0 {\n        assert(\n            encoded_length == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {encoded_length} input elements, but got {InputElements}.\",\n        );\n        // enforce Base64 padding is valid\n        if num_padding_chars == 2 {\n            let offset = InputElements - 1;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n            let offset = InputElements - 2;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        } else if num_padding_chars == 1 {\n            let offset = InputElements - 1;\n            assert(\n                input[InputElements - 1] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        }\n    } else {\n        let expected = encoded_length - num_padding_chars;\n        assert(\n            encoded_length - num_padding_chars == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {expected} input elements, but got {InputElements}.\",\n        );\n    }\n\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n    let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    // validity_check = accumulator value that we add every output from BASE64_DECODE_BE_TABLE into.\n    // Invalid error states will return a lookup value of -2^32 , which will cause `validity_check` to fail a 32-bit range check.\n    // This batch-validation technique is more efficient than asserting every returned token is valid.\n    let mut validity_check: Field = 0;\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte: u8 = input[offset];\n                let index = input_byte as u32;\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_TABLE[index]\n                } else {\n                    BASE64_DECODE_BE_TABLE[index]\n                };\n                validity_check += decoded;\n                slice += decoded as Field;\n                // Safety: get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                unsafe {\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        // process the final chunk, which may contain padding\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_elements_in_final_chunk = if Pad != 0 {\n            InputElements - base64_offset - num_padding_chars\n        } else {\n            InputElements - base64_offset\n        };\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte: u8 = input[offset];\n            let index = input_byte as u32;\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_TABLE[index]\n            } else {\n                BASE64_DECODE_BE_TABLE[index]\n            };\n            validity_check += decoded;\n            slice += decoded as Field;\n            // Safety: get a sensible error message out if the decoding is invalid.\n            // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n            // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n            // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n            // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n            unsafe {\n                __validate_decoded(decoded, input_byte, offset);\n            }\n        }\n\n        // If any lookups returned an error state, this 32-bit range check will fail.\n        validity_check.assert_max_bit_size::<32>();\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Take a variable-length vector of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\npub fn decode_var<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: BoundedVec<u8, InputElements>,\n) -> BoundedVec<u8, OutputBytes> {\n    // We don't know how many padding bytes the input string contains - we use an unconstrained fn to return a *claim* that we will later validate\n    let (has_first_padding_byte_claim, has_second_padding_byte_claim) = if (Pad == 1) {\n        // Safety: get claims about whether the bytes input[input.len() - 2] and input[input.len() - 1] are padding chars\n        // we validate this later on by requiring these characters equal BASE64_PADDING_CHAR by looking up BASE64_DECODE_BE_VAR_TABLE\n        unsafe {\n            crate::decoder::__get_num_padding_chars_var::<InputElements>(input)\n        }\n    } else {\n        (false, false)\n    };\n\n    // num_padding_chars is a claim that depends on has_first_padding_byte_claim and has_second_padding_byte_claim being correct\n    let num_padding_chars: u32 = if Pad == 1 {\n        has_first_padding_byte_claim as u32 + has_second_padding_byte_claim as u32\n    } else {\n        0\n    };\n\n    let input_length = input.len();\n    let input = input.storage();\n\n    // boundary_flags = array of Field elements.\n    // if `i < input_length, boundary_flags[i] = 0`\n    // if `i >= input_length, boundary_flags[i+1] = 1`\n    // used as cheap(ish) predicates when iterating over bounded vector elements\n    let boundary_flags: [Field; InputElements] = boundary_check(input_length);\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n\n    let max_num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    let mut validity_check: Field = 0;\n    // if statement should be known at compile time\n    if max_num_chunks > 0 {\n        let final_chunk: u32 = max_num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n\n                let mut decode_index: Field = 0;\n                if Pad == 1 {\n                    let mut might_be_second_padding_char = 0;\n                    let mut might_be_first_padding_char = 0;\n                    // These if statements should not cost extra gates as the condition is known at compile time\n                    if (offset + 2 < InputElements) {\n                        might_be_first_padding_char = (1 - boundary_flags[offset])\n                            * (1 - boundary_flags[offset + 1])\n                            * boundary_flags[offset + 2];\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else if (offset + 1 < InputElements) {\n                        // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                        might_be_first_padding_char =\n                            (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else // last character\n                    {\n                        might_be_first_padding_char = 0;\n                        might_be_second_padding_char = (1 - boundary_flags[offset]);\n                    }\n\n                    // Cases where we need to require a padding character is present:\n                    // Case 1: we are at byte position `input.len() - 2` and `has_first_padding_byte_claim = true`\n                    // Case 2: we are at byte position `input.len() - 1` and `has_second_padding_byte_claim = true`\n                    let require_padding = might_be_first_padding_char\n                        * has_first_padding_byte_claim as Field\n                        + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n\n                    // The `decode_index` is used to map the input Base64 character into an output decoded character.\n                    // We know `input_byte` is in the range 0-255 , so we use a size 768 lookup to handle the following 3 cases:\n                    // Case 1 (index range 0-255): No special cases. We decode the Base64 ASCII char into an ASCII char\n                    // Case 2 (index range 256-511): We have exceeded the length of the input. The only valid input is 0, which decodes to 0 (all other byte values return an error state)\n                    // Case 3 (index range 512-767): A claim has been made that a padding byte is present, and we are at the appropriate byte location to check this.\n                    //                               The only valid input is BASE64_PADDING_CHAR, which decodes to 0. All other inputs return an error state\n                    decode_index =\n                        input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n                } else {\n                    decode_index = input_byte as Field + boundary_flags[offset] * 256;\n                }\n                decode_index.assert_max_bit_size::<32>();\n                let decode_index = decode_index as u32;\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n                } else {\n                    BASE64_DECODE_BE_VAR_TABLE[decode_index]\n                };\n\n                validity_check += decoded;\n                slice += decoded;\n                // Safety: get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                unsafe {\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            // convert the decoded slice into bytes and populate result array\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n        // process the final chunk\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        // might include padding characters\n        let base64_elements_in_final_chunk = InputElements - base64_offset;\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n\n            let mut decode_index: Field = 0;\n            if Pad == 1 {\n                let mut might_be_second_padding_char = 0;\n                let mut might_be_first_padding_char = 0;\n                // These if statements should not cost extra gates as the condition is known at compile time\n                if (offset + 2 < InputElements) {\n                    might_be_first_padding_char = (1 - boundary_flags[offset])\n                        * (1 - boundary_flags[offset + 1])\n                        * boundary_flags[offset + 2];\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else if (offset + 1 < InputElements) {\n                    // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                    might_be_first_padding_char =\n                        (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else // last character\n                {\n                    might_be_first_padding_char = 0;\n                    might_be_second_padding_char = (1 - boundary_flags[offset]);\n                }\n\n                let require_padding = might_be_first_padding_char\n                    * has_first_padding_byte_claim as Field\n                    + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n                decode_index =\n                    input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n            } else {\n                decode_index = input_byte as Field + boundary_flags[offset] * 256;\n            }\n            decode_index.assert_max_bit_size::<32>();\n            let decode_index = decode_index as u32;\n\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n            } else {\n                BASE64_DECODE_BE_VAR_TABLE[decode_index]\n            };\n            // Safety: get a sensible error message out if the decoding is invalid.\n            // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n            // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n            // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n            // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n            unsafe {\n                __validate_decoded(decoded, input_byte, offset);\n            }\n            validity_check += decoded;\n            slice += decoded as Field;\n        }\n\n        validity_check.assert_max_bit_size::<32>();\n\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    if Pad == 1 {\n        assert(input_length % 4 == 0, \"base64 encoded strings must be a multiple of 4 bytes\");\n    }\n\n    if has_first_padding_byte_claim {\n        assert(has_second_padding_byte_claim, \"if first byte contains padding so must the second\");\n    }\n    let output_length = ((input_length * 3) / 4) - num_padding_chars;\n    BoundedVec::from_parts_unchecked(result, output_length)\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = Base64DecodeBE::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard_no_pad() {\n    // f\n    let input: [u8; 2] = [90, 103];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 3] = [90, 109, 56];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [95, 119]; // \"_w\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 2] = [255, 255];\n    let _: [u8; 1] = Base64DecodeBENoPad::decode(input);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_standard_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 95, offset 0\")]\nfn test_decode_underscore_with_standard() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let _: [u8; 2] = Base64DecodeBE::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe_with_pad() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafeWithPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 47, offset 0\")]\nfn test_decode_slash_with_url_safe() {\n    // test decoding / and +\n    let input: [u8; 3] = [47, 43, 65];\n    let _: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe() {\n    // test decoding _ and -\n    let input: [u8; 3] = [95, 45, 65];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_url_safe_no_pad_fail_with_padding() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // all configurations should decode the same way\n    let result: [u8; 12] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n\n    // all configurations should decode the same way\n    let result: [u8; 27] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let input: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result: [u8; 44] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61,\n    ];\n\n    let result: [u8; 32] = Base64DecodeBE::decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_empty() {\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBE::decode_var(input);\n    println(f\"result {result}\");\n    println(f\"expected {expected}\");\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 8> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 6> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    // fo\n    println(f\"result {result}, expected {expected}\");\n\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n\n    assert(result == expected);\n\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 61, offset 3\")]\nfn test_decode_var_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([47, 43, 65, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([255, 224]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var() {\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let input: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let input_no_pad: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n    // \"Hello, World!\"\n    let expected: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n\n    // all configurations should decode the same way\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    println(f\"result {result}, expected {expected}\");\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_multi_chunks() {\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/noir_base64/v0.4.2/src/decoder.nr"
        },
        "102": {
            "source": "use crate::constants::TWO_POW_120;\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\nuse std::cmp::Ordering;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n * gt \n * check_gt_with_flags\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> Field {\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0] as Field\n    } else if N == 2 {\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n        (limbs[0] + limbs[1] * TWO_POW_120) as Field\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        (\n            limbs[0] as Field\n                + limbs[1] as Field * TWO_POW_120 as Field\n                + limbs[2] as Field * TWO_POW_120 as Field * TWO_POW_120 as Field\n        )\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    field: Field,\n) -> [u128; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result: [u128; N] = unsafe { __from_field::<N>(field) };\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n        let mut grumpkin_modulus = [0; N];\n        if N > 2 {\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n        }\n        if MOD_BITS > 253 {\n            // this means that the field modulus is larger than grumpkin modulus so we have to check if the element fields in the field size are less than the grumpkin modulus.\n            // also for correct params N is always larger than 3 here\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n        } else if MOD_BITS < 253 {\n            // this means that the field modulus is smaller than grumpkin modulus so we have to check if the element fields in the field size\n            validate_in_field(_params, result);\n        } else {\n            // this is the tricky part, when MOD_BITS = 253, so we have to compare the limbs of the modulus to the grumpkin modulus limbs\n            // any bignum with 253 bits will have 3 limbs\n\n            // if modulus is larger than grumpkin modulus, this will be true\n            let mut gt_grumpkin = false;\n            for i in 0..3 {\n                if !gt_grumpkin {\n                    if _params.modulus[2 - i] < grumpkin_modulus[2 - i] {\n                        gt_grumpkin = true;\n                    }\n                }\n            }\n            let result_2 = if gt_grumpkin {\n                _params.modulus\n            } else {\n                grumpkin_modulus\n            };\n            validate_gt::<N, MOD_BITS>(result_2, result);\n        }\n\n        // validate the limbs sum up to the field value\n        let TWO_POW_120_FIELD = TWO_POW_120 as Field;\n        let field_val = if N < 2 {\n            result[0] as Field\n        } else if N == 2 {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field + result[1] as Field * TWO_POW_120_FIELD\n        } else {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field\n                + result[1] as Field * TWO_POW_120_FIELD\n                + result[2] as Field * TWO_POW_120_FIELD * TWO_POW_120_FIELD\n        };\n        assert_eq(field_val, field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        poseidon::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[u128; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [u128; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        if num_bytes >= num_filled_bytes {\n            let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n            let mut num_remaining_limbs =\n                (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n            let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n            let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n                + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n            for j in 0..num_limbs_in_bigfield {\n                let mut limb: u128 = 0;\n                for _ in 0..15 {\n                    let need_more_bytes = (byte_ptr < num_bytes);\n                    let mut byte = hash_buffer[byte_ptr];\n                    limb *= (256 * need_more_bytes as u128 + (1 - need_more_bytes as u128));\n                    limb += byte as u128 * need_more_bytes as u128;\n                    byte_ptr += need_more_bytes as u32;\n                }\n                bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n            }\n            bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n        }\n    }\n\n    let mut bigfield_rhs_limbs: [u128; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, _, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [u128; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120 as Field;\n        r *= TWO_POW_120 as Field;\n        modulus_mod_n *= TWO_POW_120 as Field;\n        l += lhs[N - i - 1] as Field;\n        r += rhs[N - i - 1] as Field;\n        modulus_mod_n += params.modulus[N - i - 1] as Field;\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [u128; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [u128; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = (modulus[i] as Field - val[i] as Field);\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += (borrow_flags[0] as Field * TWO_POW_120 as Field);\n    for i in 1..N - 1 {\n        p_minus_self[i] +=\n            (borrow_flags[i] as Field * TWO_POW_120 as Field - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= (borrow_flags[N - 2] as Field);\n    validate_in_range::<_, _, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<T, let N: u32, let MOD_BITS: u32>(limbs: [T; N])\nwhere\n    T: Into<Field>,\n{\n    for i in 0..(N - 1) {\n        limbs[i].into().assert_max_bit_size::<120>();\n    }\n\n    limbs[N - 1].into().assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [u128; N]) {\n    for i in 0..(N) {\n        (limbs[i] as Field).assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    (limbs[N - 1] as Field).assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, _, MOD_BITS>(result);\n    assert(!underflow, \"BigNum::validate_gt check fails\");\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params.modulus, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params.modulus, val) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb = modulus[0] + (borrow_flags[0] as u128 * TWO_POW_120) - val[0] - result[0];\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] + (borrow_flags[i] as u128 * TWO_POW_120)\n                - val[i]\n                - result[i]\n                - borrow_flags[i - 1] as u128;\n            assert(result_limb == 0);\n        }\n        let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as u128;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            // __add_u128(params, lhs, rhs)\n            __add(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params.modulus, lhs, rhs) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [u128; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] as Field + rhs[0] as Field\n            - subtrahend[0] as Field\n            - result[0] as Field\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] as Field + rhs[i] as Field\n                - subtrahend[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120 as Field;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = lhs[N - 1] as Field + rhs[N - 1] as Field\n            - subtrahend[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params.modulus, lhs, rhs) };\n\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [u128; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n            + addend[0] as Field\n            + lhs[0] as Field\n            - rhs[0] as Field\n            - result[0] as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n                + addend[i] as Field\n                + lhs[i] as Field\n                - rhs[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = addend[N - 1] as Field + lhs[N - 1] as Field\n            - rhs[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n\n// a comparison function. returns true if lhs > rhs and false otherwise\npub(crate) fn cmp<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) -> Ordering {\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    // if underflow is true, swap lhs and rhs\n    let (lhs, rhs) = if underflow { (rhs, lhs) } else { (lhs, rhs) };\n\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n    if lhs == rhs {\n        Ordering::equal()\n    } else if underflow {\n        Ordering::less()\n    } else {\n        Ordering::greater()\n    }\n}\n\n// the constraining function for the results returned by __validate_gt_remainder. this is used in both comparisons and validate gt\npub(crate) fn check_gt_with_flags<let N: u32, let MOD_BITS: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    result: [u128; N],\n    borrow_flags: [bool; N],\n    carry_flags: [bool; N],\n) {\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] as Field - rhs[0] as Field + addend[0] - result[0] as Field\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120 as Field;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] as Field - rhs[i] as Field + addend[i] as Field\n            - result[i] as Field\n            - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] as Field - rhs[N - 1] as Field + addend[N - 1] as Field\n        - result[N - 1] as Field\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/constrained_ops.nr"
        },
        "103": {
            "source": "use crate::utils::split_bits;\n\nuse crate::constants::{TWO_POW_120, TWO_POW_126, TWO_POW_246};\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\n\nunconstrained fn compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N], [Field; 2 * N - 2]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n    assert(remainder == [0; N]);\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] as Field * params.modulus[j] as Field;\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N - 2] = [0; 2 * N - 2];\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{246 - 120} = 2^{126}\n    let downshift: Field = 1 / (TWO_POW_120 as Field);\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits =\n        (mulout_p[0] - mulout_n[0] + (borrow_flags[0] as Field * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n    flags: [bool; M],\n) -> ([u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [u128; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [u128; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + (modulus2[j] as Field - x[i][j] as Field) as u128;\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [u128; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] as Field * rhs[k][j] as Field);\n            }\n        }\n        mulout[i] += add[i] as Field;\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout: [Field; (N * 2)] = compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, k, params.modulus);\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([u128; N], [u128; N], [Field; 2 * N - 2]) = unsafe {\n        compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [u128; N] = params.double_modulus;\n\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i] as Field;\n                    t0[k][i] += double_modulus[i] as Field;\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i] as Field;\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i] as Field;\n                    t1[k][i] += double_modulus[i] as Field;\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i] as Field;\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i] as Field;\n                t4[i] += double_modulus[i] as Field;\n            } else {\n                t4[i] += linear_terms[j][i] as Field;\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term =\n                        t0[k][i] * t1[k][j] - quotient[i] as Field * params.modulus[j] as Field;\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j] as Field;\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] as Field * params.modulus[j] as Field;\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] as Field * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/expressions.nr"
        },
        "105": {
            "source": "use crate::utils::map::invert_array;\n/// conversions between big endian and little endian byte arrays and BigNum instances\n/// the byte serialization should have `(MOD_BITS + 7) / 8` bytes.\n/// each 120-bit limb is represented by 15 bytes, and there are fewer bytes for covering the most significant limb\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    let num_bits = (MOD_BITS + 7) / 8 * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result: [u128; N] = [0; N];\n\n    let excess_bytes = N * 15 - (MOD_BITS + 7) / 8;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    limb.assert_max_bit_size::<128>();\n    result[N - 1] = limb as u128;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        limb.assert_max_bit_size::<128>();\n        result[N - i - 1] = limb as u128;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - ((MOD_BITS + 7) / 8 * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_be_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let mut result: [u8; (MOD_BITS + 7) / 8] = [0; (MOD_BITS + 7) / 8];\n    // the last limb will not have all the 15 bytes so we deal with the full limbs first\n    for i in 0..N - 1 {\n        let index = N - i - 2;\n        let limb_bytes: [u8; 15] = (val[index] as Field).to_be_bytes();\n        for j in 0..15 {\n            // we leave the space for the first byte empty, which would take (MOD_BITS+7)/8 - MOD_BITS/8 bytes\n            result[i * 15 + j + (MOD_BITS + 7) / 8 - (N - 1) * 15] = limb_bytes[j];\n        }\n    }\n    // now we deal with the last limb\n    let last_limb_bytes: [u8; ((MOD_BITS + 7) / 8 - (N - 1) * 15)] =\n        (val[N - 1] as Field).to_be_bytes();\n\n    for i in 0..((MOD_BITS + 7) / 8 - (N - 1) * 15) {\n        result[i] = last_limb_bytes[i];\n    }\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let result_be: [u8; (MOD_BITS + 7) / 8] = to_be_bytes(val);\n    let result = invert_array(result_be);\n    result\n}\n\npub(crate) fn from_le_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    // make the bytes big endian\n    let be_x = invert_array(x);\n    from_be_bytes(be_x)\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/serialization.nr"
        },
        "106": {
            "source": "use crate::constants::{TWO_POW_119, TWO_POW_120};\nuse crate::fns::unconstrained_ops::{__add, __gte, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\nuse crate::utils::msb::get_msb;\nuse crate::utils::split_bits::__normalize_limbs;\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [u128; N] {\n    let mut x = field;\n    let x_first_u128 = (x as u128);\n    let first: u128 = x_first_u128 % TWO_POW_120;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_120 as Field);\n    let x_second_u128 = (x as u128);\n    let second = x_second_u128 % TWO_POW_120;\n    x = (x - (second as Field)) / (TWO_POW_120 as Field);\n    let x_third_u128 = (x as u128);\n    let third = x_third_u128 % TWO_POW_120;\n    let mut result: [u128; N] = [0; N];\n    if N > 2 {\n        result[0] = first;\n        result[1] = second;\n        result[2] = third;\n    }\n    if N == 2 {\n        result[0] = first;\n        result[1] = second;\n    }\n    if N == 1 {\n        result[0] = first;\n    }\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [u128; N] = params.modulus;\n    flags[0] = modulus[0] < val[0];\n    for i in 1..N - 1 {\n        flags[i] = modulus[i] < val[i] + flags[i - 1] as u128;\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> (bool, [u128; N], [bool; N], [bool; N]) {\n    let mut a = lhs;\n    let mut b = rhs;\n    let underflow = !__gte(lhs, rhs);\n\n    let mut result: [u128; N] = [0; N];\n    // swap a and b if there's an underflow\n    let (a, b) = if underflow { (b, a) } else { (a, b) };\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = a[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = b[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = (borrow * TWO_POW_120 + add_term - sub_term);\n\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (underflow, result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32>(\n    modulus: [u128; N],\n    val: [u128; N],\n) -> ([u128; N], [bool; N - 1]) {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow_in: u128 = 0;\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    for i in 0..N {\n        let sub_term = val[i] + borrow_in;\n        let borrow = (sub_term > modulus[i]) as u128;\n        result[i] = borrow * TWO_POW_120 + modulus[i] - sub_term;\n\n        borrow_in = borrow;\n        if (i < N - 1) {\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let add_res = __helper_add(lhs, rhs);\n    let overflow = __gte(add_res, modulus);\n\n    let mut subtrahend: [u128; N] = [0; N];\n    let mut result: [u128; N] = [0; N];\n\n    if overflow {\n        subtrahend = modulus;\n    }\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term = lhs[i] + rhs[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry as u128;\n\n        let sub_term = subtrahend[i] + borrow_in;\n\n        let mut borrow: u128 = (sub_term > add_term) as u128;\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow as u128;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let underflow = !__gte(lhs, rhs);\n    let addend: [u128; N] = if underflow { modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + addend[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = rhs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = borrow as u128 * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [u128; 2 * N],\n    redc_param: [u128; N],\n    k: u32,\n    modulus: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mulout_field: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout_field[i + j] += x[i] as Field * redc_param[j] as Field;\n        }\n    }\n\n    let mulout: [u128; 3 * N] = __normalize_limbs(mulout_field, 3 * N);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient = __shr(mulout, (k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n    // the quotient has bunch of zero limbs now, so we can just take the first N limbs as a result\n    let mut smaller_quotient = [0; N];\n    for i in 0..N {\n        smaller_quotient[i] = quotient[i] as u128;\n    }\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = __into_field_array(quotient);\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] +=\n                partial_quotient_full[i] * modulus[j] as Field;\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    let long_quotient_mul_modulus_normalized: [u128; 2 * N] =\n        __normalize_limbs(quotient_mul_modulus_normalized, 2 * N);\n    let mut quotient_mul_modulus_normalized: [u128; N] = [0; N];\n    for i in 0..N {\n        quotient_mul_modulus_normalized[i] = long_quotient_mul_modulus_normalized[i];\n    }\n\n    let mut long_remainder = __helper_sub(x, long_quotient_mul_modulus_normalized);\n    // ugly but have to remove a bunch of zeros from this\n    let mut remainder = [0; N];\n    for i in 0..N {\n        remainder[i] = long_remainder[i];\n    }\n    // barrett reduction is quirky so might need to remove a few modulus from the remainder\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n\n    (smaller_quotient, remainder)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let mut target = __helper_sub(params.modulus, one);\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target = __shr1(target);\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [u128; N],\n    p_minus_one_over_two: [u128; N],\n) -> (bool, [u128; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [u128; N] = __one();\n    let neg_one = __neg(params.modulus, one);\n    let found = exped == neg_one;\n    let mut result: (bool, [u128; N]) = (found, target);\n    if (!found) {\n        let _target: [u128; N] = __add(params.modulus, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [u128; N] {\n    let mut target: [u128; N] = __one();\n    let p_minus_one_over_two = __shr1(__helper_sub(params.modulus, __one()));\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [u128; N],\n    i: u32,\n) -> u32 {\n    let one: [u128; N] = __one();\n    let is_one = t2m == one;\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n\npub(crate) unconstrained fn __increment<let N: u32>(val: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 1;\n    for i in 0..N {\n        let mut add_term = (val[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u128;\n    let remainder_shift = (120 - limb_shift);\n    let mask: u128 = (((1 as u128) << limb_shift) - 1) << remainder_shift;\n    result[0] = (input[0 + num_shifted_limbs] >> (limb_shift));\n    for i in 1..(N - num_shifted_limbs) {\n        let value = input[i + num_shifted_limbs];\n        result[i] = value >> limb_shift;\n        let remainder: u128 = (value << remainder_shift) & mask;\n        result[i - 1] = result[i - 1] + remainder;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shl<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u128;\n    let remainder_shift = 120 - limb_shift;\n\n    // 83\n    // limb shift = 1\n    // inside shift = 19 bits to the left\n    // meaning we have 19 carry bits and 41 remainder bits\n    let mask: u128 = (1 as u128 << 120) - 1;\n    //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n    let value = input[0];\n\n    let mut remainder = (value >> remainder_shift);\n    result[num_shifted_limbs] = (value << limb_shift) & mask;\n\n    // shift 84. num shifted = 1\n    for i in 1..((N) - num_shifted_limbs) {\n        let value = input[i];\n        let upshift = ((value << limb_shift) + remainder) & mask;\n        result[i + num_shifted_limbs] = upshift;\n        remainder = (value >> remainder_shift);\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_sub<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    for i in 0..N {\n        borrow = ((rhs[i] + borrow_in) > lhs[i]) as u128;\n        let sub = (borrow << 120) + lhs[i] as u128 - rhs[i] as u128 - borrow_in;\n        result[i] = sub;\n        borrow_in = borrow;\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_add<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr1<let N: u32>(mut input: [u128; N]) -> [u128; N] {\n    let value = input[N - 1];\n    input[N - 1] = value >> 1;\n\n    let mut remainder = (value & 1) << 119;\n\n    for i in 1..N {\n        let value = input[N - 1 - i];\n        input[N - 1 - i] = (value >> 1) + remainder;\n        remainder = (value << 119) & TWO_POW_119;\n    }\n    input\n}\n\npub(crate) unconstrained fn __get_msb<let N: u32>(val: [u128; N]) -> u32 {\n    let mut count = 0;\n    for i in 0..N {\n        let v = val[(N - 1 - i)];\n        if (v > 0) {\n            count = 120 * (N - 1 - i) + get_msb(v);\n            break;\n        }\n    }\n    count\n}\n\npub(crate) fn __get_bit<let N: u32>(input: [u128; N], bit: u32) -> bool {\n    let segment_index: u32 = bit / 120;\n    let uint_index = (bit % 120) as u128;\n    let limb: u128 = input[segment_index];\n    let value = (limb >> uint_index) & 1;\n    value == 1\n}\n\npub(crate) fn __into_field_array<let N: u32>(input: [u128; N]) -> [Field; N] {\n    let mut result: [Field; N] = [0; N];\n    for i in 0..N {\n        result[i] = input[i] as Field;\n    }\n    result\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/unconstrained_helpers.nr"
        },
        "107": {
            "source": "use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __get_bit, __get_msb, __helper_add, __helper_sub, __increment,\n    __multiplicative_generator, __primitive_root_log_size, __shl, __shr,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse super::unconstrained_helpers::__shr1;\n\npub(crate) unconstrained fn __one<let N: u32>() -> [u128; N] {\n    let mut limbs: [u128; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [u128; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32>(modulus: [u128; N], limbs: [u128; N]) -> [u128; N] {\n    __helper_sub(modulus, limbs)\n}\n\npub(crate) unconstrained fn __add<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    // check if the result is greater than the modulus\n    if __gte(result, modulus) {\n        __helper_sub(result, modulus)\n    } else {\n        result\n    }\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __add(modulus, lhs, __neg(modulus, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += (lhs[i] as Field * rhs[j] as Field);\n        }\n    }\n    let to_reduce: [u128; (N * 2)] = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(to_reduce, params.redc_param, MOD_BITS, params.modulus);\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    let inv_divisor: [u128; N] = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut quotient: [u128; N] = [0; N];\n    let mut remainder: [u128; N] = numerator;\n\n    let b = divisor;\n    let numerator_msb = __get_msb(numerator);\n    let divisor_msb = __get_msb(divisor);\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = __get_msb(remainder) - __get_msb(divisor);\n        let mut accumulator: [u128; N] = __one();\n        let mut divisor = __shl(divisor, bit_difference);\n        accumulator = __shl(accumulator, bit_difference);\n\n        if (__gte(divisor, __increment(remainder))) {\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        for _ in 0..(N * 120) {\n            if (__gte(remainder, b) == false) {\n                break;\n            }\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (__gte(remainder, divisor)) {\n                remainder = __helper_sub(remainder, divisor);\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient = __helper_add(quotient, accumulator);\n            }\n            divisor = __shr1(divisor); // >>= 1;\n            accumulator = __shr1(accumulator); //  >>= 1;\n        }\n\n        (quotient, remainder)\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    let one = __one();\n    let exp = __helper_sub(params.modulus, __helper_add(one, one));\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n    exponent: [u128; N],\n) -> [u128; N] {\n    let x = exponent;\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [u128; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if __get_bit(x, num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n) -> [[u128; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]; M] = std::mem::zeroed();\n\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]],\n) -> [[u128; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one = __one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let Q = __shr(\n        __helper_sub(params.modulus, one),\n        primitive_root_log_size - 1,\n    );\n    let two = __helper_add(one, one);\n    let Q_minus_one_over_two = __shr(__helper_sub(Q, two), 2);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [u128; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __gte<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    let mut result = false;\n    let mut early_exit = false;\n    for i in 0..(N) {\n        let idx = (N) - 1 - i;\n        if (rhs[idx] == lhs[idx]) {\n            continue;\n        }\n\n        result = rhs[idx] < lhs[idx];\n        early_exit = true;\n        break;\n    }\n    if early_exit {\n        result\n    } else {\n        lhs[0] == rhs[0]\n    }\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/unconstrained_ops.nr"
        },
        "109": {
            "source": "pub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [u128; N],\n\n    // @brief double_modulus: used when performing negations and subtractions\n    // @note we borrow 1 from the last limb. This is for easing up the operations that might underflow\n    pub double_modulus: [u128; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [u128; N],\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [u128; N],\n        redc_param: [u128; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [u128; N]) -> [u128; N] {\n    let TWO_POW_120: u128 = 0x1000000000000000000000000000000;\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (modulus[i] + modulus[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/params.nr"
        },
        "110": {
            "source": "use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, cmp, derive_from_seed, div, eq, is_zero, mul, neg, sub, udiv,\n        udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    serialization::{from_be_bytes, from_le_bytes, to_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __derive_from_seed, __div, __eq, __invmod, __is_zero, __mul, __neg, __pow, __sub,\n        __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::{cmp::Ordering, ops::Neg};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [u128; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {\n\n    pub fn zero(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [u128; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    pub fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::zero(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    pub fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [u128]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    pub fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [u128; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    pub fn from_be_bytes(params: BigNumParams<N, MOD_BITS>, x: [u8; (MOD_BITS + 7) / 8]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS>(x), params }\n    }\n\n    pub fn from_le_bytes(params: BigNumParams<N, MOD_BITS>, x: [u8; (MOD_BITS + 7) / 8]) -> Self {\n        Self { limbs: from_le_bytes::<_, MOD_BITS>(x), params }\n    }\n\n    pub fn to_be_bytes(self) -> [u8; (MOD_BITS + 7) / 8] {\n        to_be_bytes::<_, MOD_BITS>(self.limbs)\n    }\n\n    pub fn to_le_bytes(self) -> [u8; (MOD_BITS + 7) / 8] {\n        to_le_bytes::<_, MOD_BITS>(self.limbs)\n    }\n\n    pub fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    pub fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    pub fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    pub fn get_limbs(self) -> [u128; N] {\n        self.limbs\n    }\n\n    pub fn get_limb(self, idx: u32) -> u128 {\n        self.limbs[idx]\n    }\n\n    pub fn set_limb(&mut self, idx: u32, value: u128) {\n        self.limbs[idx] = value;\n    }\n\n    pub unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    pub unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params.modulus, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params.modulus, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params.modulus, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    pub fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    pub fn validate_in_range(self) {\n        validate_in_range::<_, _, MOD_BITS>(self.limbs);\n    }\n\n    pub fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    pub fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    pub fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Ord for RuntimeBigNum<N, MOD_BITS> {\n    fn cmp(self, other: Self) -> Ordering {\n        assert(self.params == other.params);\n        cmp::<_, MOD_BITS>(self.limbs, other.limbs)\n    }\n}\n\n// UNCONSTRAINED! (Hence `__` prefix).\npub fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[RuntimeBigNum<N, MOD_BITS>; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[RuntimeBigNum<N, MOD_BITS>; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [RuntimeBigNum<N, MOD_BITS>; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> (RuntimeBigNum<N, MOD_BITS>, RuntimeBigNum<N, MOD_BITS>) {\n    let (q_limbs, r_limbs) = unsafe {\n        crate::fns::expressions::compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| RuntimeBigNum::get_limbs(bn)),\n            linear_flags,\n        )\n    };\n    (RuntimeBigNum { limbs: q_limbs, params }, RuntimeBigNum { limbs: r_limbs, params })\n}\n\npub fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[RuntimeBigNum<N, MOD_BITS>; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[RuntimeBigNum<N, MOD_BITS>; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [RuntimeBigNum<N, MOD_BITS>; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    crate::fns::expressions::evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n        params,\n        map(lhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n        lhs_flags,\n        map(rhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n        rhs_flags,\n        map(linear_terms, |bn| RuntimeBigNum::get_limbs(bn)),\n        linear_flags,\n    )\n}\n\n// UNCONSTRAINED! (Hence `__` prefix).\npub fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    x: [RuntimeBigNum<N, MOD_BITS>; M],\n) -> [RuntimeBigNum<N, MOD_BITS>; M] {\n    let params = x[0].params;\n    assert(params.has_multiplicative_inverse);\n    let all_limbs = unsafe {\n        crate::fns::unconstrained_ops::batch_invert::<_, MOD_BITS, _>(\n            params,\n            x.map(|bn| RuntimeBigNum::get_limbs(bn)),\n        )\n    };\n    all_limbs.map(|limbs| RuntimeBigNum { limbs, params })\n}\n\npub unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32, let M: u32>(\n    x: [RuntimeBigNum<N, MOD_BITS>],\n) -> [RuntimeBigNum<N, MOD_BITS>] {\n    let params = x[0].params;\n    assert(params.has_multiplicative_inverse);\n    let all_limbs = crate::fns::unconstrained_ops::batch_invert_slice::<_, MOD_BITS>(\n        params,\n        x.map(|bn| RuntimeBigNum::get_limbs(bn)),\n    );\n\n    all_limbs.map(|limbs| RuntimeBigNum { limbs, params })\n}\n\npub fn conditional_select<let N: u32, let MOD_BITS: u32>(\n    lhs: RuntimeBigNum<N, MOD_BITS>,\n    rhs: RuntimeBigNum<N, MOD_BITS>,\n    predicate: bool,\n) -> RuntimeBigNum<N, MOD_BITS> {\n    let params = lhs.params;\n    assert(params == rhs.params);\n    let limbs = if predicate { lhs.limbs } else { rhs.limbs };\n    RuntimeBigNum { limbs: limbs, params }\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/runtime_bignum.nr"
        },
        "117": {
            "source": "use crate::constants::TWO_POW_120;\n\nunconstrained fn split_120_bits(mut x: Field) -> (u128, u128) {\n    // Here we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low = (x as u128) % TWO_POW_120;\n    let high = ((x - low as Field) / TWO_POW_120 as Field) as u128;\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [u128; N] {\n    let mut normalized: [u128; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n        normalized[i] = lo as u128;\n        next = input[i + 1] + hi as Field;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[range - 1] = lo as u128;\n        assert(hi == 0);\n    }\n    normalized\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/utils/split_bits.nr"
        },
        "124": {
            "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"
        },
        "149": {
            "source": "use dep::bignum::RuntimeBigNum;\nuse sha1::sha1;\nuse sha256;\nuse sha512::{sha384, sha512};\n\nglobal SHA1_HASH_LEN: u32 = 20;\nglobal SHA256_HASH_LEN: u32 = 32;\nglobal SHA384_HASH_LEN: u32 = 48;\nglobal SHA512_HASH_LEN: u32 = 64;\n\nfn reverse_array<let N: u32>(array: [u8; N]) -> [u8; N] {\n    let mut reversed = [0 as u8; N];\n    for i in 0..N {\n        reversed[i] = array[N - i - 1];\n    }\n    reversed\n}\n\nfn get_array_slice<let N: u32, let M: u32>(array: [u8; N], start: u32, end: u32) -> [u8; M] {\n    assert(end - start <= M);\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        if i < end - start {\n            slice[i] = array[start + i];\n        }\n    }\n    slice\n}\n\nfn pow(base: u32, exp: u32) -> u32 {\n    let mut result = 1;\n    for _ in 0..exp {\n        result *= base;\n    }\n    result\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA1 as the hash function\n **/\nfn mgf1_sha1<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA1_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA1_HASH_LEN as Field + 1);\n\n    // SHA1_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA1_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA1_HASH_LEN] = [0; SHA1_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block using SHA-1\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha1::sha1_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA1_HASH_LEN {\n            if i * SHA1_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA1_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA256 as the hash function\n **/\nfn mgf1_sha256<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA256_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA256_HASH_LEN as Field + 1);\n\n    // SHA256_HASH_LEN bytes are added at each iteration and there is at least 1 iteration\n    // so if SHA256_HASH_LEN is not enough to fill MASK_LEN bytes in one iteration,\n    // another one is required and so on.\n    let iterations = (MASK_LEN / SHA256_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA256_HASH_LEN] = [0; SHA256_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block\n        // First SEED_LEN bytes are the seed, next 4 bytes are the counter\n        hashed = sha256::sha256_var(block, SEED_LEN as u64 + 4);\n\n        // Copy hashed output to mask\n        for j in 0..SHA256_HASH_LEN {\n            if i * SHA256_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA256_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA384 as the hash function\n **/\nfn mgf1_sha384<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA384_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA384_HASH_LEN as Field + 1);\n\n    // SHA384_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA384_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA384_HASH_LEN] = [0; SHA384_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha384::sha384_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA384_HASH_LEN {\n            if i * SHA384_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA384_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA512 as the hash function\n **/\nfn mgf1_sha512<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA512_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA512_HASH_LEN as Field + 1);\n\n    // SHA512_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA512_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA512_HASH_LEN] = [0; SHA512_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha512::sha512_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA512_HASH_LEN {\n            if i * SHA512_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA512_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-1 to the original message hash\n **/\nfn compare_signature_sha1<let N: u32>(padded_sha1_hash: [u8; N], msg_hash: [u8; 20]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..20 {\n        // Padded hash is reversed\n        assert(padded_sha1_hash[19 - i] == msg_hash[i]);\n    }\n\n    // SHA-1 ASN.1 DER identifier\n    let hash_prefix: [u8; 15] = [20, 4, 0, 5, 26, 2, 3, 14, 43, 5, 6, 9, 48, 33, 48];\n\n    for i in 20..35 {\n        assert(hash_prefix[i - 20] == padded_sha1_hash[i]);\n    }\n\n    assert(padded_sha1_hash[35] == 0);\n\n    // Sub 20 bytes for hash, 15 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 38;\n    for i in 36..N {\n        if i < 36 + ps_len {\n            // PS padding\n            assert(padded_sha1_hash[i] == 255);\n        } else if i == 36 + ps_len {\n            // Pad 0x01\n            assert(padded_sha1_hash[i] == 1);\n        } else if i == 37 + ps_len {\n            // 0x00\n            assert(padded_sha1_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha1_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-384 to the original message hash\n **/\nfn compare_signature_sha384<let N: u32>(padded_sha384_hash: [u8; N], msg_hash: [u8; 48]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..48 {\n        // Padded hash is reversed\n        assert(padded_sha384_hash[47 - i] == msg_hash[i]);\n    }\n\n    // SHA-384 ASN.1 DER identifier\n    let hash_prefix: [u8; 19] =\n        [48, 4, 0, 5, 2, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 65, 48];\n\n    for i in 48..67 {\n        assert(hash_prefix[i - 48] == padded_sha384_hash[i]);\n    }\n\n    assert(padded_sha384_hash[67] == 0);\n\n    // Sub 48 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 70;\n    for i in 68..N {\n        if i as u32 < 68 + ps_len as u32 {\n            // PS padding\n            assert(padded_sha384_hash[i] == 255);\n        } else if i as u32 == 68 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha384_hash[i] == 1);\n        } else if i as u32 == 69 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha384_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha384_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-512 to the original message hash\n **/\nfn compare_signature_sha512<let N: u32>(padded_sha512_hash: [u8; N], msg_hash: [u8; 64]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..64 {\n        // Padded hash is reversed\n        assert(padded_sha512_hash[63 - i] == msg_hash[i]);\n    }\n\n    // SHA-512 ASN.1 DER identifier\n    let hash_prefix: [u8; 19] =\n        [64, 4, 0, 5, 3, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 81, 48];\n\n    for i in 64..83 {\n        assert(hash_prefix[i - 64] == padded_sha512_hash[i]);\n    }\n\n    assert(padded_sha512_hash[83] == 0);\n\n    // Sub 64 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 86;\n    for i in 84..N {\n        if i as u32 < 84 + ps_len as u32 {\n            // PS padding\n            assert(padded_sha512_hash[i] == 255);\n        } else if i as u32 == 84 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha512_hash[i] == 1);\n        } else if i as u32 == 85 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha512_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha512_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Exponentiate a signature by a given exponent using binary exponentiation\n * @details This function handles the exponentiation of a signature by any given exponent.\n * Uses the square-and-multiply algorithm for efficient modular exponentiation.\n * @param sig The signature to exponentiate\n * @param exponent The exponent to use (any positive integer)\n * @return The exponentiated signature\n */\nfn exponentiate_signature<let NumLimbs: u32, let ModBits: u32>(\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> RuntimeBigNum<NumLimbs, ModBits> {\n    assert((exponent > 0) & (exponent < 131072), \"Exponent must be positive and less than 2^17\");\n\n    // Binary exponentiation (square-and-multiply algorithm)\n    let mut result = RuntimeBigNum::one(sig.params);\n    let mut base = sig;\n    let mut exp = exponent;\n\n    // We assume the exponent won't be more than to 2^17 so we can\n    // have less iterations\n    for _ in 0..17 {\n        if exp > 0 {\n            // If the exponent is odd, multiply result by current base\n            if exp % 2 == 1 {\n                result = result * base;\n            }\n\n            // Square the base for the next bit\n            base = base * base;\n\n            // Divide exponent by 2 (move to the next bit)\n            exp = exp / 2;\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-1\n *\n * @param msg_hash The SHA-1 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha1_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 20],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha1_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha1(padded_sha1_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme with SHA-256\n * @note The `exponent` can be any positive integer (commonly 3 or 65537 are used for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-384\n *\n * @param msg_hash The SHA-384 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha384_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 48],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha384_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha384(padded_sha384_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-512\n *\n * @param msg_hash The SHA-512 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha512_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 64],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha512_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha512(padded_sha512_hash_bytes, msg_hash)\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-1.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha1_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 20],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 20; // SHA-1 produces 20-byte hashes\n    let s_len = 20; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 20 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 21 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 21 = 235 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 21 = 107 bytes left for DB\n    let masked_db: [u8; (ModBits + 7) / 8 - 21] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-1\n    let db_mask: [u8; (ModBits + 7) / 8 - 21] = mgf1_sha1(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 21];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 20] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 48]; // 8 + h_len + s_len = 8 + 20 + 20 = 48\n    for i in 8..28 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 28..48 {\n        m_prime[i] = salt[i - 28];\n    }\n\n    // Compute H' using SHA-1\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 48);\n    let h_prime = sha1::sha1_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha256_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 32;\n    let s_len = 32;\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 32 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 33 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 33 = 223 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 33 = 95 bytes left for DB\n    let masked_db: [u8; (ModBits + 7) / 8 - 33] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1\n    let db_mask: [u8; (ModBits + 7) / 8 - 33] = mgf1_sha256(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 33];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 32] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 72]; // 8 + h_len + s_len\n    for i in 8..40 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 40..72 {\n        m_prime[i] = salt[i - 40];\n    }\n\n    // Compute H'\n    let h_prime = sha256::sha256_var(m_prime, 72);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-384.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha384_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 48],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 48; // SHA-384 produces 48-byte hashes\n    let s_len = 48; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    let offset = key_len - em_len;\n\n    // The array slice sizes will be different for SHA-384 compared to SHA-256\n    let masked_db: [u8; (ModBits + 7) / 8 - 49] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-384\n    let db_mask: [u8; (ModBits + 7) / 8 - 49] = mgf1_sha384(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 49];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 48] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 104]; // 8 + h_len + s_len = 8 + 48 + 48 = 104\n    for i in 8..56 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 56..104 {\n        m_prime[i] = salt[i - 56];\n    }\n\n    // Compute H' using SHA-384\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 104);\n    let h_prime = sha384::sha384_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-512.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha512_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 64],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 64; // SHA-512 produces 64-byte hashes\n    let s_len = 64; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    let offset = key_len - em_len;\n\n    // The array slice sizes will be different for SHA-512 compared to SHA-256\n    let masked_db: [u8; (ModBits + 7) / 8 - 65] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-512\n    let db_mask: [u8; (ModBits + 7) / 8 - 65] = mgf1_sha512(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 65];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 64] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 136]; // 8 + h_len + s_len = 8 + 64 + 64 = 136\n    for i in 8..72 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 72..136 {\n        m_prime[i] = salt[i - 72];\n    }\n\n    // Compute H' using SHA-512\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 136);\n    let h_prime = sha512::sha512_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\nmod tests {\n\n    use crate::types::{\n        Params1024, Params1025, Params2048, Params4096, RBN1024, RBN1025, RBN2048, RBN4096,\n    };\n    use super::{\n        mgf1_sha1, mgf1_sha256, mgf1_sha384, mgf1_sha512, verify_sha1_pkcs1v15, verify_sha1_pss,\n        verify_sha256_pkcs1v15, verify_sha256_pss, verify_sha384_pkcs1v15, verify_sha384_pss,\n        verify_sha512_pkcs1v15, verify_sha512_pss,\n    };\n    use bignum::params::BigNumParams;\n    use bignum::RuntimeBigNum;\n    use sha1::sha1;\n    use sha512::{sha384, sha512};\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_1024() {\n        // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170, 193,\n            96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n        ];\n\n        let params: BigNumParams<9, 1024> = BigNumParams::new(\n            false,\n            [\n                0xab238ad9cb37979a43aefbf10be8fb,\n                0x31347febe45fe8c2dac1dd30900704,\n                0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n                0x5eac6390f7873fe97ff9bb14a173ea,\n                0xbc41f700c91fd733a2c63177bbdbd4,\n                0x41442bd58769a3595b659a2ec9c6be,\n                0x4ddc91395f330382aa2e2d3fbe147,\n                0x3d008ff255a0bc71c7887f5728ba1,\n                0xb640c3a8f511c64e,\n            ],\n            [\n                0x5d53d2634c6a0918266043968ce263,\n                0x5dd4be3dce0323a492ee9340aec4db,\n                0xf82d0e2e5c8319f01a460c72c01854,\n                0x236e6fc6e62e8a1d522acda5fb3892,\n                0xdaf755619d66e580901aa224d03174,\n                0x8366291616480e7e1f202dbcedda87,\n                0x40ba1202537d1e94561ccc05265586,\n                0x69b993d857ba89ea5de9822aeb4b93,\n                0x167968c0000761a273,\n            ],\n        );\n\n        let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xc3850e84ea02da3f028ff422f4d6a9,\n                0x9761f0bd9021f76d45c60df0670a19,\n                0xc1ede421a43607ab623ed4d5a17fc8,\n                0x86197b4315206f4d53200b42555831,\n                0xe95783b69db28c26a83706f39d04cd,\n                0x18b178dc1a9ec76fb22b57e4dfa703,\n                0xdd0e19cd5a09ab48e7af4d0e3470e3,\n                0x10004dfab1cf91304e80e6baa4dfc7,\n                0x241c3fd77b90adef,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048() {\n        // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131, 166,\n            79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n                0xbfb937fc4d3cf02cc0af780f3cab44,\n                0xd20637ef7adcf5d238ee87bccc9bca,\n                0xb9db4f2663108e2f8b673f7612ae8b,\n                0x85f894ef669b36bfd3d86b0a28873,\n                0xdcc70e1884e38b8229cce3b884121d,\n                0x35488d1138e0b03e1676f7f5d8a5b3,\n                0xe1a97820e7dcbb4eab35c9b71bb273,\n                0x97d19eb3c63249ddbfcff915863f54,\n                0x3a78c7af6da0f6af0d67b1ca4b6065,\n                0xd7a3c433c020f624821e5e678c7d69,\n                0x52d5b53240feae82ffea3d2a3d9b09,\n                0xb8aad5e19e2163f68997c6fdd71906,\n                0x5db432d06e8b0bf59511100c7894e2,\n                0xadc0bbc4c54da10d1cc88438ea3127,\n                0xece1cf6a1501109cd2734d5893c8d9,\n                0x7196b90acdf06c31b1288064fd0c27,\n                0xc8,\n            ],\n            [\n                0x1b1deccf4dbde852c34a5d6908a0f,\n                0xbc9e5bdab22f023fbcca58692bccf5,\n                0x1f65439685623e45396ff55751c3bf,\n                0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n                0x5ca2e8e3048243c16c708a8030ab0d,\n                0x30079bfeb1fa51e5501581173ca19c,\n                0xff8d5f6bea485fdcc2716327f69ab4,\n                0x36b599d81589416b5b5f037986b999,\n                0x75612e34a4ff29f0a19a7823512f58,\n                0x288b6897929b54c3b26a5faa07c00f,\n                0x4b5675fa13ab7444f1f047d3eb1bbe,\n                0x6ba0ac610ef9f267ab30fe25bb1c84,\n                0xa386b48ee03168d5cea3ecb9dc901f,\n                0xacf1a01f7dba44e050c976142fb1f6,\n                0x97a63b5cb7efc60d3502946aec63cf,\n                0x12cc1d5cab10a1e9e2398d29b9e3ef,\n                0x4635cf25c66e76bba8034df46204fb,\n                0x146f,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xad29e07d16a278de49a371b9760a27,\n                0x86311920cc0e17a3c20cdff4c56dbb,\n                0x863556c6c5247dd83668dd825716ae,\n                0xc247c960945f4485b46c33b87425ca,\n                0x7326463c5c4cd5b08e21b938d9ed9a,\n                0x4f89fe0c82da08a0259eddb34d0da1,\n                0x43a74e76d4e1bd2666f1591889af0d,\n                0x240f7b80f0ff29f4253ee3019f832d,\n                0xc6edd131fbaaf725fd423dac52b362,\n                0x85f9732679242163e8afff44f6104d,\n                0xd3c3bbcb1757013fd6fb80f31dd9a6,\n                0x9008633f15df440e6df6d21ee585a2,\n                0x324df3425ed256e283be5b6b761741,\n                0xc60c1302929bd0e07caa4aeff4e8fd,\n                0x600d804ff13ba8d0e1bc9508714212,\n                0x50f7e75e5751d7edd61167027926be,\n                0x0db41d39442023e1420a8a84fe81d9,\n                0xab,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n        // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132, 239,\n            227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0xe40ee47801326543c8e84b85d567c1,\n                0x5b54ea87f0ce29de1995697b0696fd,\n                0x457078f8fdce68b437cac0970b2452,\n                0x473ec776fee3731b6ab06e35875ddc,\n                0x62dedd594e5f12c80c3ccb5791a6cd,\n                0xecb934b9d8272c5e3a418145345499,\n                0xd1af643b3d785470ed0c6cd633f706,\n                0xb58a57b9e96eccbdfc7c17f0333d4,\n                0x2ebd34b5039fc596504927c282c60d,\n                0x3a44928a74f25fc1043bb37ce4dfa8,\n                0x91448459f9617fac33a2816162ac9e,\n                0x70cb910d9f3e1a78864640ec6c8240,\n                0x9aed33f6b31f1c9de67248a98c180,\n                0x7f1416e032c79488c94b311e87bd9c,\n                0x7191b4ebb1b3fffa949fa48ed01e5,\n                0x350a75cbaeca6bfdd71ca83cdbcae9,\n                0xfb1d274fa207457c6814d42c09f9cf,\n                0xd4,\n            ],\n            [\n                0x803bf4d38110a7d37fdd05f590dee9,\n                0xa68d317c933f37cab5ab4e7c00a3b9,\n                0x476a05a536bf5f2aa1b8850146cba7,\n                0xca297ea8b5528d91d4836ff27c30ab,\n                0x75cf2eaab76eefa12bbd570f1aea9f,\n                0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n                0xd497db1f6ebe83decacaa647fabea6,\n                0x686b27ca330e25e7a7cf197f6433ef,\n                0xfde04d2225c8308b07580af0058a0f,\n                0xa29fb69777c0e916976243b2b09855,\n                0xf983592285852e7e1c2cb3ae968323,\n                0x673608017f9f5acf67a01b73728d70,\n                0xeeff82521c0bc432a05f4b7444fac0,\n                0x85a89c4d229f60aaa3aa7ac7dac1e2,\n                0xcfecff93bc9fbfe0d6dff6091f2db8,\n                0xf20f047dcb224b4447bd098c07f8c2,\n                0x554bb53cadeb3eaab911a189f90227,\n                0x133b,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa250eff812c63eaaeaa3f04641c05f,\n                0xecc09613cb8b289c1f37c8f92e6a05,\n                0x2c0a0510058360c07af65d46f594fd,\n                0x943d67513363d3de430c94a1dafe7c,\n                0x511ec8e9b10bc6c6ff0d6c232ccf92,\n                0x50ffd07b3c093b3f5fc027de847731,\n                0xc268e1489449943fdafdf89ff168c3,\n                0x0b8b7f9f49b492f78fda58d252f23a,\n                0x491c6c4ef836a6a8730b7bf81e865e,\n                0x8746c75fb079d014e419543f56d7f0,\n                0x65804c417d6168a8bc0025d255cebf,\n                0xf695e91b77890b8e3fd775fa56e627,\n                0x5e90001c0218550f4083ae28025a2f,\n                0x526bd4eff34f25f62a698f0470e0a6,\n                0x7f224306a7d9daf536b1559434c6c6,\n                0x88809f16fe1fcea3c87511d9319735,\n                0x7694685fee0bfab4a9196b92ec6f2e,\n                0xa7,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_38129() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x4f79aee9e865ee89b9695c2ac44903,\n                0xe33ac311e740f4dfc39492d38186d4,\n                0xf513677b71c4cdf88b9011d109402d,\n                0x940eba50ebc0a50b539268b2c9edee,\n                0x6d7b7dc633b0ba7deb34669da59af9,\n                0x69f0b92bd973d83643b54c86302bc8,\n                0xbee39cd038bb54491cab410bc1382d,\n                0xe59688c01aa8491c6522aa467fbdba,\n                0x8731b6ff98f9e1f792d4a4dff8c81d,\n                0x9d1773f064f1ce81301053e3abcc43,\n                0xe80e6137f3ccf06ca669e0d0f14c30,\n                0xefbf9d55ae96471f9fef8d5ac29c46,\n                0x284807c893f7e7af1a39d9c599ba76,\n                0x17491bdeafd3a2c796dd50f2444997,\n                0x21742c4e2dc66d064e36abb50f9c67,\n                0x58f1503ad765979883692dcff55252,\n                0xf613ad8641b9195cb742ac5d3ff778,\n                0xad,\n            ],\n            [\n                0xbd864af583a9911c93c5b92ab68568,\n                0x10d63ed8c0c83e91e945683061045b,\n                0xf38982278a43cfae6438348ae94c9b,\n                0x75133ea58bac5abff54a6e7a165283,\n                0xd3449474e97738f4c6a2d843722783,\n                0x9e3b3c08f360d9f967416af9becf84,\n                0xcd40081688aedd976009f34a964356,\n                0xa27adea282e0227e69ff47203440cb,\n                0x99f812956fd9377b0bed8deb543ede,\n                0x5f655415ed123df19398d5d479401d,\n                0x587d5cae3d0a5b34e3f8b2ca43ade1,\n                0xa4fde6c7f37ea8267d2183519ceb1,\n                0x1ba5bec0bb36c67251aa7678f7c169,\n                0x2e1ddae393d6a4f1a320b15b23b974,\n                0xfc61518efd066b5912b60cfd1d7474,\n                0xf854c457bf3908af1e4934d7c72d1f,\n                0xa44257cffc0c579bf0addd3c75d4df,\n                0x178b,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x98156ae7cbad0e0fbaa9b254c445cf,\n                0x6f3ea82d1faf48ecb60f3f7481f020,\n                0xea0f2df747bbe8a8629c9dc6246da7,\n                0xb635b9de66aa7e600e924c0932b43b,\n                0xa010df8938db4c035c8473f0fd167d,\n                0xe37d1709aae17c76199c99efa5e5a7,\n                0xf8336b32c807dfb62d149fb8353f4e,\n                0xf852a4cc6a84981cd8a0d9eef5510f,\n                0x10c5cae74e75c83e3835906e5eea2a,\n                0xd83e21dc7e49277c86d81144837750,\n                0x72e367e8e2db3320145626438e6e93,\n                0x2129c9c0c2ce89e77661a15c8c7647,\n                0xe9c0b584a2ed003dbe4cadd2cfd87f,\n                0x6e5bd7521c235ab9e18356d089863a,\n                0x28e861ed03b6acc39fa7af5c068fa7,\n                0x4d1a681de2ce54f0d19eb736723af8,\n                0x2042cf79eb42702aab8526c68a64fd,\n                0x90,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 38129));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_107903() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xf2bc2f4fd3637bb9ccc7e163324dbf,\n                0x88ac5e7a9abee89a393533168e8743,\n                0xa9d1ef7f5677329e23336052001928,\n                0x2fa85860b512fed4ecc0c94388e4dc,\n                0x61b27bbdb48fd8dcf155a1d3242029,\n                0x8119d20bb357bee95c9e6038448ea2,\n                0x4e8759208ccbfc555d32e3fa487af4,\n                0x7608d025ac5a266c1e795b7dc0840b,\n                0xd9df24711a6d2fed0d9248057cf278,\n                0xfbcd7907dc0dacc66a855324c5ae85,\n                0xcf3eca7c8405dfaf7ce39c1b1e526d,\n                0xf2c0a24eb8fd5b2b49eb261b01e5cb,\n                0xb7be784d951012ec79c8df7bb35e10,\n                0x2f7a97fe187189f04fead5f1b00850,\n                0x8246d382cd0821b066e801665eb949,\n                0xbca14eae9a7d4b426639eb99d15c3e,\n                0xfd0f6549b224f1be363e496501a0d8,\n                0xd0,\n            ],\n            [\n                0x66eb2aa6aa1141cacc9004c4aaafcb,\n                0x3983dda53fcc7548cac5070988d128,\n                0xa94b8ccd7bc37c9c6c074ec9dc418e,\n                0x57d6ec9504d4f025839a764cc80cd6,\n                0x5a99da586dd573c790ad0b0cf4048f,\n                0x4c7432020677232539d08b80c4d3,\n                0x338f75091af189cb1d224bd37c6249,\n                0xee6a89be24e36b5f7f1e7c38fae7ba,\n                0x1464843dcb6adf79a5775db61a461c,\n                0x6040e8536fcfa579e6058fe8fe2faf,\n                0x493b2bb04dd77744a5adc46d90652c,\n                0xef49699688680f2bed603abb89bf31,\n                0x5d86fdb1035de7023db8815fea79ef,\n                0x36e4b0aca5531d5c0da94709ba17a4,\n                0xa4327a03320a6982a60603abc981cb,\n                0x5d54032f69977241b356abc4590887,\n                0x62bf97079a59e9ce6320da47988e99,\n                0x1399,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x4b2f40b350af5cf9b4cd5e4a48484b,\n                0x2d45da942f02e9c1ca4d0b5c8891eb,\n                0x95e181ee7a25546bb5f06881ed06ab,\n                0x96daf6f89a37583781ac3cadc3b474,\n                0xca3d251f57ab831e38da4a72febd6b,\n                0xd331a8762354c7a21a205bd00a56e4,\n                0x30e1612ca0c22b20df7e3b13ce20ab,\n                0x0e44e8752d7f365a5be65666a695c7,\n                0x2f9371a16fac95bdbe2bdd29fe3660,\n                0xb5aa14bd29c9cead7fe248cc8d8fef,\n                0x5152b5458eac4871b2dad8ae6f82a9,\n                0xb440d47429dfc47c83afa416a4f6e2,\n                0x6c71eb1897abe36235364ea0257868,\n                0xd2d51b57e037b494d663d8238f7ee5,\n                0xcc7fdf728797297df1292e63fd6e3c,\n                0x4eaf8992cf23b65390e2dfa7b012d7,\n                0xe84bdde98147a17f3a9297786a9b84,\n                0xaa,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 107903));\n    }\n\n    #[test]\n    fn smoke_test() {\n        // Output of `cargo run -- --msg \"hello world\"` in the `signature_gen` directory\n        // Create runtime params:\n        let modulus_limbs = [\n            0x65af46d235241cf0e8fbe8cff4abb7,\n            0xeead39ba3f377ddd5ccb2ef2085190,\n            0xe483f94c0a98e8b618d92fb926f596,\n            0x1fa8c1b2c62cca6db090cd74a29db2,\n            0xc38e22042fcb74585a7e535301f50f,\n            0xcbc4378e5212752743ae78a75a44a9,\n            0xf5acc41788d9a346a0f75630a8b2b6,\n            0xf7a741bb3ecf1aadd5a327f362abd8,\n            0x4d5f24e815db43a1b2cc2ba40f8715,\n            0xe501f1a01305cb198475a4bff0da2e,\n            0xd541b78cfbc2b314083c340840c82c,\n            0xa0ab069c26b2a0458f4c642bf72526,\n            0x2ccb676d8f22517116fee0d2340533,\n            0x7cf2a7cf772025c0a83747bbc18228,\n            0xf9475f17988a56f17b3bdf88dc72dc,\n            0x4ff228bee24415fae7a7c05771e830,\n            0x55acd96b485515c38906106cf0d189,\n            0xb9,\n        ];\n        let redc_limbs = [\n            0x172c8f156f020ad88d30fa3ba47f03,\n            0x1740a43a67cb9a7be1ac1422d77246,\n            0x2d967be1edf369834317e04856e591,\n            0x65d9fa0de5fdab598c04d9a515156a,\n            0xc6791a661ea7621db7e6c4ec48f466,\n            0xa4a1a7c06d3e8a0bcbc540c6af6788,\n            0xdcaffeb149f5bf646caa00d7355715,\n            0xb75471630a9d0fefb5cb61e66991a1,\n            0x97c041a0fc30fdff3d5ed16997da02,\n            0xbfbe7d217694b269e1ed37819c2f17,\n            0x1b44ffc3180531e2ab8bdf7848a3a9,\n            0x9f004af11132cb68bb55998ed7616a,\n            0x1b15dbbb96ce80f479724bbd768a0c,\n            0x59ba1419093ae6ed2592ffb3065867,\n            0xa35b69affa3bb3f4713f315e50b584,\n            0xa873210f83a6de0d8cbb816af3e37,\n            0xbe4fe7cf98da87ec87638030797e92,\n            0x1619,\n        ];\n\n        let signature_limbs = [\n            0x2f397c4611d4a4271453e1e50e1578,\n            0xe506a7f47c721a4943783e8ad459e6,\n            0x6cc4ae1d91cb381cba9673470999fb,\n            0x1e127364d07f94e58227f50fbf5687,\n            0xf64a2579c7189f882d68832d16faa4,\n            0x3b014b74c6c6f76f2f8af170fa0fe4,\n            0x7df41e68c86815a6fdc33968c66b67,\n            0x6a57ac06282527242fddb6ed08dbdc,\n            0xac40d37b819c4b6193f90a634e4fc7,\n            0x96606ed166a7f032d858cd40ac73a5,\n            0x8eb7d4351159a46733f92610d5c597,\n            0xc8e8e9faa9738e82dbe774a3f5cf07,\n            0x89ca84fd54ee3d5cca87c9f178375e,\n            0xdb7a1465fc76507ea498a351af70dd,\n            0x6ac6fe14f51c711f983125c776f712,\n            0x3254c17fef51bf4194a8a1674634e3,\n            0xee38c83c77c6e1ff7b70a5d9d1dd0f,\n            0x26,\n        ];\n\n        let hash: [u8; 32] = [\n            0xb9, 0x4d, 0x27, 0xb9, 0x93, 0x4d, 0x3e, 0x08, 0xa5, 0x2e, 0x52, 0xd7, 0xda, 0x7d,\n            0xab, 0xfa, 0xc4, 0x84, 0xef, 0xe3, 0x7a, 0x53, 0x80, 0xee, 0x90, 0x88, 0xf7, 0xac,\n            0xe2, 0xef, 0xcd, 0xe9,\n        ];\n\n        let has_multiplicative_inverse = false;\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(has_multiplicative_inverse, modulus_limbs, redc_limbs);\n\n        let signature: RBN2048 = RBN2048::from_array(params, signature_limbs);\n\n        assert(verify_sha256_pkcs1v15(hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha384_pkcs1v15_2048() {\n        let sha384_hash: [u8; 48] = sha384::sha384_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x1dccbc1b553aef560cd665aa2ca411,\n                0xdf1b70d8f0ff39013065a5a886490f,\n                0xc3952220c2f6ba45b86fd1842f6db5,\n                0x13403323f2e86127e7d30ca5c3741f,\n                0xdd9593e1b80868ee660cff6aed224d,\n                0xa768ff67951f621cf220c3f11fb7d0,\n                0x827a30c8fc6da6d9e0002ccbab7354,\n                0xd4f4b3326c1822490ba84bf7d8f2ff,\n                0xbc1aed9983525cf9795c5ee886efbe,\n                0x95eca388e0ef68d9e1b51bfdb3f38b,\n                0x5f250161202b7d91724180734cd057,\n                0x5f6a6e4b2adf9db128af321e90bc61,\n                0x2b395ebbeaaf0c6c40a8e7ab2f041b,\n                0x8fea1754c39077bbc232d8380c4eac,\n                0xa113212c3d6ba516cdf08b1c0c0cae,\n                0x9ba6c1d51332cd846f88cfe28dabb,\n                0x57a8d8bfcb8839f3ef85c7ee2dc2e0,\n                0xb4,\n            ],\n            [\n                0xeb993de4326322c7d2e7979b705653,\n                0x1d611f18aa83085ef385333ec454c3,\n                0xb7a3bee73153dae2577781e9a435b0,\n                0xee599bc9d964a749c73673b0559c2c,\n                0x35c1adbbcbfe860f721aa7a0fc3f13,\n                0xa8c28cff73d6ab769ff07f77246062,\n                0xa6263efec60ed7d395f486a0a96b2d,\n                0xa6da86e3c3abd7bec42b6fab8927bf,\n                0xc5a27d894e67e310bc4490762e53dd,\n                0xea29c3c6430885ae7b68d1399dd42e,\n                0xb5a82288241107dcc02e4d04cc0fd,\n                0xf9dbe42935c2111913f05933346bb8,\n                0xc82f5eca04e0b6ab27cdbc55ed1cf6,\n                0xbc6d3e01593e9d1c9399245a306ccd,\n                0xf5da9e23e54b7ace54fc14e9b8fe89,\n                0xc087aabdf746e1a12a8792cf7ac5d1,\n                0x5c825b2c8353558dd371d57b1d31af,\n                0x16b6,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x0d643395f61610f78e0965ff28b34a,\n                0x991a18b16cd776f8ba0dc7d3a2c0ac,\n                0x59ad92fdc6573338573a5ec3a8ac1f,\n                0x39fa3c545c220904560f89449e0cb6,\n                0x77c0492bb5f8faeab6484258164fef,\n                0x32f66a824fc81c4bc3a10228c9d875,\n                0xaf5a933d03c5c769af3e1c43112418,\n                0xe4b3c71e29d230dbcd784dfd344cc6,\n                0x08f5fd6f3b0782eaae154fe56fbe0f,\n                0x9b785970ee35b2cd656cd9f098565c,\n                0xc6c649021334fff3d4ba072255eb0e,\n                0x1fb7d5c84e2fc4e975ea5793a92fc9,\n                0xcbb718f2f6c780b4f6e3a17575b89f,\n                0x04f7eb7174814ff492727916397bb8,\n                0x77790f451d53ce4d4229791f142d38,\n                0xd9ab6403501d48c29b3abbad760d43,\n                0x20d90ee7975dcbd1761fa7f6487391,\n                0x17,\n            ],\n        };\n        assert(verify_sha384_pkcs1v15(sha384_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha512_pkcs1v15_2048() {\n        let sha512_hash: [u8; 64] = sha512::sha512_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x56acc9475dd0568166f6d519d2b123,\n                0x4388e4291f2a16d58441e4c966d869,\n                0x3b6cbbf6524f2e12e274d96a598cf3,\n                0xcb7b28845e13e53fc8827fadcbf5c2,\n                0xc2f20ecad4360634ca81a3f2700df9,\n                0x71b5ed85f3cc58e9820fa9cdabf2b4,\n                0x8e15d0237c7dbee5369ccbf8f6e25e,\n                0x280d4771bcddaebaa691b4870d4a92,\n                0x3f8ab4c278a35f45149814c95c1c6a,\n                0x4b88bb3a4f16adaa8a9ffa781086ad,\n                0xb4e8dad6bc3fd7d666683e872832e1,\n                0x3135b2958becadcb9e25ec25e55b23,\n                0x405ef523d210399f9def6302a36221,\n                0xb9aaf3a3c5b2e3f4f86393bde7b852,\n                0x5f66a3d278b5759b92269481eb94ca,\n                0xb0ae491acfb3d0a8a46a92b7adffb7,\n                0xa61f0e1720a3cc4594121de7aedf34,\n                0xc0,\n            ],\n            [\n                0xa1818833c46a2c4799148d9f1264d9,\n                0x91008bc32d17f31c4f28b53cf3b9a,\n                0xbf512971ab01254af711f37837279b,\n                0x4f98e0725dbc7d52fba2f5d5482d5,\n                0xc06343b59716c402d33ae0d15ce9b,\n                0x96e236079ec038a21029aba4ff7ffb,\n                0x76e91c4ee8870b1d1c06b73a00f0f9,\n                0xc5018d4394283930ab64cc401b3809,\n                0xc8b4f3f863b01b0fe223822f163552,\n                0x6a94ec6a63708552ac0ab6a824f380,\n                0xc3cf47d1d72b08284f9c04e265a5bc,\n                0xa9d863c6820f2ec1cd35de9327b153,\n                0x85983ec02cffd866801e790bbfa7d2,\n                0x5ee89f7c98ece0aaf4150b6c5b6abe,\n                0x7255ef31994f3cb4b731d0bbf76c57,\n                0x3aba2e537e9003f447c62153c3dcd7,\n                0xf005726db837e60cff0feaac8d326d,\n                0x1542,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x8c1ac22b4f25479bd4d63adc5647a5,\n                0xc226d235d17e3ce2d6303804edd317,\n                0x75992147cd0883367aac32c28927e2,\n                0x7f131d0a5dc76ac9a3982bc3430a66,\n                0x1e5c5471a794bede59e42c5125df77,\n                0x7d4d8bffa69b08eb5a9338c96eb042,\n                0x44bc5745bdb2ed1944e61939c9b325,\n                0xa9c536593f93201b1493257bfceedb,\n                0x9f00b9f27e424f9724c1486fb54314,\n                0xeae7e1250521e254ee2d31f94002f9,\n                0x9ee4db7dbe46139670393a1250fa79,\n                0x014039fcd5bcfa3db273bf7188b3ce,\n                0x4967a88c2ddaf359c3c813cfa3ccc6,\n                0x9c3f74383a8c3326b47401d5815c45,\n                0x2f666d5fbe8464dcfaf569bffa0248,\n                0xfeccacb7e9e0e44320651e58344e8e,\n                0x8942c708df7e40a175d44fee7cf5ec,\n                0x4c,\n            ],\n        };\n        assert(verify_sha512_pkcs1v15(sha512_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_mgf1_sha256() {\n        let seed: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let expected_mask: [u8; 32] = [\n            106, 93, 232, 46, 236, 203, 51, 228, 103, 104, 145, 29, 197, 74, 26, 194, 135, 200, 40,\n            232, 179, 172, 220, 135, 51, 185, 209, 35, 194, 131, 176, 190,\n        ];\n        let mask: [u8; 32] = mgf1_sha256(seed);\n        assert(mask == expected_mask);\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_2048() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xb2cae9b4d726643aef459696fb80d7,\n                0x46585d789783e6f0ea6a4a17001b8e,\n                0xfdf7476659c117564ca991f3d635f4,\n                0x9bb5835a63f78d2ff06927d5f5a64d,\n                0x18ce92c21c9a7dad5ed41c66790811,\n                0x38003b2699273864cc87b363714855,\n                0x7c19d41f8dbe41e03505fe1e061a5a,\n                0xd63a7a6d91625495e46db9161b0d7c,\n                0x3dffb1f7121946f6e04dc642a85da9,\n                0x389eabe29dbf38c1be95c9b9c0c029,\n                0x77a14dc6452603a154cc463e4c2a3a,\n                0x68eaeef1963fa3866c934d1225ac67,\n                0x3a66b9b64048ed95cec6bbe4235189,\n                0x113fd1c23822a8dd63e7d97b034eeb,\n                0x28b7376afc6109602ed94eb40284f6,\n                0x4d331f4da82c798979e7d9d2c5f7bf,\n                0x716d8b401bea115cf1265f976aaccf,\n                0xaf,\n            ],\n            [\n                0x399ea4dac74d4757a7a2956b5b0493,\n                0x954c409a53ce8d70f35be10b94d284,\n                0xee4d330032d52a65e66f54f9e091f4,\n                0x7522b6ca940bfc5133b8fd77ca4bc8,\n                0x43485c2c6ac94d8041c5a056da794b,\n                0xa464924f3a28ab23c5ffa0493dddee,\n                0x8fe3f1bc6a09e1103acbb53acbf6f1,\n                0x5e47597909e86c168b5748cc089ce1,\n                0xc86b6b4de2aa786e144d0ef5556c30,\n                0xf45a9d9d93fbe0cd5f2ddca2316648,\n                0x5edab2328b0b639407f9c773a06c5c,\n                0xb61d4e287c0c6a969f5decfd036ea5,\n                0xd47864f47e49cd0e0ec34f120ba0a4,\n                0x3eaa94f799b276ef6a790eb61722d4,\n                0x5c18da1341811cee5de6f76ed1a186,\n                0x5ef0641da7cac0c45ba74d4355befa,\n                0xbb04586630e92ea5ece8e5db45caea,\n                0x1758,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x6d3125fde00a57fb5971460c38a826,\n                0xba2092dd58c4de8ffff2bf13f5ef57,\n                0xf0ad4ed46727881e7e7f6a103d7713,\n                0x7e8b2203a7a6e3a3a30219d6edf8a2,\n                0x9b0b861dd1cb2751f30d54d07ad167,\n                0x4373e863b15edba97439182a6a9043,\n                0x61621211db5f34a0786d5ef38cd90c,\n                0x63001609f7dffdc70761c67617b580,\n                0x8b2b817a0508e4be6f2c50df23962d,\n                0x6d6f9396978782a90fe06ca78c4f88,\n                0xc567a9fe5f7175225384d7c1e4c991,\n                0x38926dfee8636b9e36728c1cf51198,\n                0x0eb84e90f89a0bd21536a537618b92,\n                0x23dbdcda1fee2b57c8dc2e605777b7,\n                0x6acac69b2fc1c12c204e790034a01e,\n                0xee44b77264385863ccef2e133241cd,\n                0xe9c67049c219997cc8c43b0b1f420b,\n                0x78,\n            ],\n        };\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha384_pss_2048() {\n        let sha384_hash: [u8; 48] = sha384::sha384_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xc3034c17b5578d9c029b22158a8e45,\n                0xa84c80b43a68c9eb7cde67f1f60e07,\n                0xa8d82a4aef2cd733a9fdf43439ffbb,\n                0xa1b9aae31832c2815b81f0db70962e,\n                0xcfcbc51338d691443e702bd18354a7,\n                0xaa2c5f465a247efc9d97fb052579b8,\n                0x571f3c233fa322a933a4cfc0c4b213,\n                0x3280f1f7238a3416c5e1140077537a,\n                0x8685f03e3076c1bb62550cb363ae08,\n                0x55ebdcb84073ad2dfd3553c5e2d21a,\n                0x1e5a0a662b44f5250377abcd1069e6,\n                0x178357493184215e38603004f6c9f3,\n                0x75cb8889b33c6b78bab0a378453376,\n                0x4f5f7baa56492d5ac52c1bf7b998b,\n                0x16cf48a7c416bbf67657a263376e22,\n                0x1d8ab41c7021ebcb15da705dab5343,\n                0xc5e43d48377059df0aa5d7e5441586,\n                0xc7,\n            ],\n            [\n                0x721a52a87ca82263e96fd6d2bf3417,\n                0x74bfd742af70020df01f6cae960793,\n                0x1091edcad411cdbfc254bbb2ab2906,\n                0x9d1a2951a8e50de9c90b803c3d4931,\n                0x506ad1760d06b52708ccc0ed9fe629,\n                0x11b96266505a62523f9cfa1101a9c8,\n                0xbe5243b0f30ee090c4181e19f45f1a,\n                0xa2a56edaec8f9fe12d4d07d725931e,\n                0x50723b780f7ef18393031ced4f1489,\n                0x1ef7d8dc5b567db0b1a65b745625f2,\n                0xf9f37b5efea9a93029d7d5dda26bc2,\n                0x759247cff5570cb9075ae0e8b5cfee,\n                0xfb2e6c00b4ce0feedc40f3633d354e,\n                0xc9051ad4f912e7a5753e614d892320,\n                0x3cf78d852f5f76bc267b0ebcf13c39,\n                0x7b3cb2df2619a3020f2080dd555657,\n                0xd649e6032585f42250ac6c95111c09,\n                0x1480,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x06d24f9dbd859780c7684e7733ebb1,\n                0x3acb7e4bd7c9f42a5f9649e1fef5c4,\n                0x67878f2493de5cb48ae107df08dbf1,\n                0xf268bc940d64e42b8719216fef188e,\n                0x2c4701120db41532e6d195ba1f8faa,\n                0x03d3b537eefd6f0c99fbb7c1f359d9,\n                0x35b732ca45b03bb17b1f3564f18464,\n                0x468584d7dac0a4ba51032e2a5f95e2,\n                0xe10042eb30d1662517aed3b89e1154,\n                0x0e5743acb366c6251627e64f751256,\n                0xb06e6af3e06ed5c656e66aa0295f63,\n                0x67378aabfe17e33e305825eb4f6c5a,\n                0x8cd4c7aa81b660325dba4b0d899a9c,\n                0x40c83a9c74f99c026aa845fa222b69,\n                0xd52f8e19032a33a1d9a01063fff8f9,\n                0x7dc36972054edf46bbfe918711e693,\n                0xb035fca3baf4329ff5d588baf7b034,\n                0x1c,\n            ],\n        };\n\n        assert(verify_sha384_pss(sha384_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha512_pss_2048() {\n        let sha512_hash: [u8; 64] = sha512::sha512_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x928a173c3947c058b084e258b8a4c1,\n                0x5f1179c22cfacb440464695cfa393e,\n                0xc409e532b3077ce4d90e66e913f125,\n                0x29e8696374f86380ff45d0f29a98d5,\n                0xf931d155d89d3753ee931433a8e2fd,\n                0xfc3d1c2a999f0112f5c5416c2e0428,\n                0x4d21692b210bec2ab8e1b52fe78e66,\n                0x9df364fad350d314b146e84f114203,\n                0x8511a74031596831dda8ac9d18dcf7,\n                0xab5f9ad71b33284aae738988284229,\n                0x3332aa31681f69a5f470caadad7469,\n                0xf1fcad281e0fea144e1f4208d38e38,\n                0xe83d3b0afb20bc39814ea22df000ef,\n                0x3d9244664808f54fc4f0702adc9399,\n                0xc087b5dc693953e6371b9c7c175a21,\n                0xd5910d0d4232e8f92148482a72baec,\n                0x44e57b58ec4e75250116ce2f1abf3b,\n                0xd2,\n            ],\n            [\n                0x74b3f4c907125a6150549b8b5a387e,\n                0x9c2ecc9981d5fc27f5a6a7b4f23756,\n                0x57ee194ec44b4a44df198809f8d673,\n                0x7ffa9a1ec7d9a9b915e1abc75c493f,\n                0xde339596c27c993135a7ee132cf774,\n                0xfdb788951d3777aeea6afee171b569,\n                0x8dda93126970270ed42ae605e9824f,\n                0x3fa6e07b4429f0ee8370c988553ee3,\n                0x26d95e43ed1e1960a316eebf6b3b0b,\n                0xfd155b9025d16ecdbdac73725d9a89,\n                0x2f5a47107ec03b05f5a10fba4fa1df,\n                0x61a45285c5dc3355741713d6d71a24,\n                0x8644f1f46cecd803e531110da3bd5f,\n                0xaf989d56c5412bee6598af25829723,\n                0x52f7827f7aee453f9c3eb9753fbe4b,\n                0x9f38d6f5f1a3ff0d40c601d799dbb0,\n                0xd401bd1620fdd206413a8977de6375,\n                0x137a,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x2058f7115f339e55a93f8dcefe81b9,\n                0x38a20cdbfc439a1fea423c119f2879,\n                0x7ac4e03a5fa662754e6e21a78984d4,\n                0x69d714829d29b235d588476152b5af,\n                0xce3db2102990c27bb66bc32da8dec4,\n                0xb4914f6f0e73718b5f1e422fac6ddf,\n                0x7d812b554c81ccb7932d1e78c6e002,\n                0x438fe60d9e0912328374513ab91b69,\n                0x56abaf2b8d9a6dcb9201586d2f0d0a,\n                0x4151c524481066bd81b4cd17829481,\n                0x7c63b445e245d09ca91057032ad22b,\n                0x9f242d5a655035a028a68d337ae40d,\n                0xb5f91b99b495862044bc7122913806,\n                0xc123aa56dff5b23d7d8ad097748efb,\n                0x6892e3a32a7b6963d97b3bdd81b91d,\n                0xcd7aa9e3e77f68f0ed195bff92a162,\n                0x583a32fd5a399f3acd867dd7d6a1b6,\n                0x7f,\n            ],\n        };\n\n        assert(verify_sha512_pss(sha512_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_4096() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params4096 = BigNumParams::new(\n            false,\n            [\n                0xd78653b3d43a72784415fc0537129b,\n                0xc725d4fb19419a03b58e0fb5ea4ad2,\n                0x1d866cfc050224a0eb317e835ee283,\n                0xd298018e86d3225a264a449c63d69d,\n                0x824db5365a077bf704acd2446baa7f,\n                0x5c419e562b5b5ccb0dcb151a3f48c9,\n                0x198a6627edcbc2afce1893217c2e25,\n                0x29a693a0bb3f6f02d80e660f681d6d,\n                0x5656562a9622f87bfb969db2542f63,\n                0xb9408b08a3ee3b25b6dc6ae12899ef,\n                0x4ce9b767219e1e0593782ce46a041f,\n                0xc5a4f318b34ff79121677f283ceea1,\n                0xbd5e62c599453a94e0bf5f48c6b58a,\n                0x6ce23c4978ae07af4c46ea9b9964ad,\n                0x68d4db6209ac89538e6d986cb77459,\n                0xf2ada72cff01696e2efdf123ab60f3,\n                0xf951c3c1965c355f460fa815587ed2,\n                0x6063ac0275e6592b878d5a66e68501,\n                0x594eb3db288ad091bc1db2b2a90101,\n                0xb72899c91edcdf890053f87d5b1dab,\n                0xdfd45eab0c435e275202bff1e22f5d,\n                0x3da05e1d0d3cd0012e6c40e1878ab7,\n                0x4fe053feaf486a27dd119cbee9ce1e,\n                0xa3781b036bd3a3411c2af8377ad0d9,\n                0xdf4410ba8397cbe580fc5eca7d230d,\n                0xdc34151036d459fc3c21d8ba0702fc,\n                0x4ea71eb1b0b1a2f36741b61e8765d8,\n                0x22cb66b4eb0b34b34320402ef652dd,\n                0xd19167b88620fc6b60709fd39cd48b,\n                0x524e4fbe4d75e4817de075ac70c72f,\n                0xd0de26679602cd331c3e5534ce668a,\n                0xf5aa120ff51d4bd3d57c1d68359f95,\n                0xaa06f0791b623cddd53d787035bd66,\n                0x122e014d565fa26417a5ed0f786fbb,\n                0xb95e,\n            ],\n            [\n                0xc4c3bf6cc9335c4bb7199f9eb47a5d,\n                0x7bcbe7b5b3cfb697c6b77fe1aa066f,\n                0x3e936bb516c60dec6e7bde90a54056,\n                0x78a92edbea967a370dc928b2f4cb53,\n                0x99df0977952d4278e6b4c792b31c39,\n                0x7d894ebed8702b158c7a51dff502b8,\n                0x6da93f37eabadd8e55d4f450bf48a6,\n                0xfb59acbad033856be388bf59b73c4a,\n                0x8644dd32dc773e5e12e03380dbff01,\n                0xdff59e8aefb7acc81bde30f7b22890,\n                0xa646c3f6a98819547eae677e99679,\n                0xc777d7da058b7a0d88b7ec84400a6,\n                0xc6ba50b7cc4d0aebf8a25d1eaca0ec,\n                0x6f2cc8babdde75a318872b952885fa,\n                0x6fc91aadc8ce227e9039c8f3148d9c,\n                0x67773f804221d4f58ca3bd11952bc7,\n                0xcf5a20affc5a099ad25abb5b9cc622,\n                0xf60a9108eb36c8068e93e524c23512,\n                0x8b67af87617dcd94e38a62a7297673,\n                0x656343f8e1802e8c043b2621f5b08d,\n                0xd82c8e1a8d3e458e7979a77cd76424,\n                0xd2bf783c787be340bd66fb8a07d1d7,\n                0xc94d16e2ea48369f57abca5909b81c,\n                0x2ff442542b4e904ad3ca20d06ee11f,\n                0xa1fa20565627dd7eb96b4027b6714f,\n                0xd3a82d484df4983db5fadd7b93048a,\n                0x5f4e993b09d0ab81b8312bc09f069,\n                0xcd135a6daa623b906fb62c6e28e9e1,\n                0x1a5abe5655f62a0a0d0d9479ae7675,\n                0xcfa89adba08b924725c940a56ad9e,\n                0x6023b1d30936eb9ee54bf789026e22,\n                0x9e91f11aa269f381122653c704cd5,\n                0x2116e976d592737e0c57dc12269efc,\n                0xe88a3202a09bdeaa3db69af98a651,\n                0x1618be,\n            ],\n        );\n        let signature: RBN4096 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x5d9212d0c25acc14b61c6ce61a844e,\n                0x9d369ae765eb0545f83f552b8d7bb6,\n                0x5f0f5d383bd70d7726a851c422fe29,\n                0xcff5886575636efcde5d9843e59a10,\n                0x5820fa1e3158154641adb2c28a8954,\n                0x03ce0301512be13c0317fb679e6348,\n                0x13ec0af966303ca69b6f7fece6c2f4,\n                0x58dcc592b80e4756a8d01224e6174f,\n                0x73610ba199750de1e35cd658cbae92,\n                0xeb1d49f1ecc3bf332b4048d978a46a,\n                0x8c9ad13691accdce88ce1e6fda0bf5,\n                0x425e80441351444e751cd86b97b464,\n                0xd25a9581921c44fba102ed92a75658,\n                0x698c73a7fc85fee22b1c7f04fb4600,\n                0x70267fc50db236dfcf1e9405e25856,\n                0x1a35b94cf56f801be96defed712afe,\n                0xa3ecae6965b3bdee416f8d506f64fd,\n                0xc875faf0fb4e4fa47ff65aba633529,\n                0x3ca01bcaf3c4a5eee7fa8fdf0e98,\n                0xa666b5d8c9f3217c412610ae91c862,\n                0x517ccc77102fa7799e521ef0e6d4e7,\n                0x7a50f7e553db75f0e0bd18d43bd622,\n                0x98e8da14444b6cf3d2b91d84da3506,\n                0xd1f5e4f7a725babc988cc7822c3d0a,\n                0x09ee2caa2e6f8b02db37ebe2352624,\n                0xd500b790312328a681b89b5de51b4f,\n                0x5ce0ebb445d4c82c3ecf21134c00bf,\n                0x83b6fafae79bc59f07e9b6802ef018,\n                0x8efd78556c637f8af6299ace0cd790,\n                0x5e99cf54d0f7e491cd72bcf20701fe,\n                0x19f15da137fe1bbe44c5531300829a,\n                0x0aae159f54317b49ec6b083292f57e,\n                0x37c2bba2237a59a35556f2d351c728,\n                0x7ec51821f03bde0c862e19e6ebe62c,\n                0x2081,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_2048_exponent_3() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x1c961b234309c24fdab3f3e8a09da1,\n                0xf4aa851a30a198c359f3779b6bf4e0,\n                0x844034a1488c79edf31b1711a5e547,\n                0xc83ad2f9b30cfcb6d5f7c152a78e62,\n                0x16e97e0f8d8bad08da76d859c575c6,\n                0x6a85158069b211820a596359d0dc47,\n                0x1b834ed69818f1aa7d9944dee07b20,\n                0x4d7148da361f1881cd4fd396ef46d2,\n                0xc4cf36bbfa2781703699abf19a1e6d,\n                0xca4bd632c8eb2c8051915c3530aef9,\n                0x9cbfd5681aa95ade8eb256925d60ea,\n                0x3b8153585ff5f1d7b1ed37ac709dc6,\n                0x7d741c118fd653af3c21848f789ed8,\n                0x7aefa65093c124e46405849ca82ad1,\n                0xf9dbb9414e8eb849e2532d3f55d0b9,\n                0x35aeee862ac76c20be58527220f6a,\n                0xa3b6f81f07963c34ff0168634f8a99,\n                0xc4,\n            ],\n            [\n                0xaf8e2d749a5966b98ffa10ea071d41,\n                0x83704b0ef8ae71e3f1a7d24d871556,\n                0x82903be42859c5bd5cbb935d1097fb,\n                0x5bdc4e1e26670ed73580e2c8c144c1,\n                0xce5178ff7019c4a6c0a2743ab2fae1,\n                0xfd9ba73654ecf2020bdfa6ed9dc777,\n                0x9ba95e3e7551ee261a4f10eca35f05,\n                0x9e09b71274e5df10e06a6ce6319c3f,\n                0xb14781efad91be0888f5150771eea5,\n                0x15d2f490d6ba3cf25ad91e5e2539b0,\n                0x7887aca3df2194cdbed904e6d42977,\n                0xb797f21802a052c11e5c205bcb7d21,\n                0x94d15b35eaf46e2fe69f2b60c02922,\n                0x73814f1d160107a3ff1081b0cd1fea,\n                0xaa4c31b61839c41980a8bb9c922a0c,\n                0x123cc9f0ad08747529171a2e286eb6,\n                0x7a8b658fe4e9b448debf21d8ea0cc0,\n                0x14d4,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x091a8c417287e046ec96c62b5ac66f,\n                0xbe71db0fe3122ea5624e8e7a0a72dc,\n                0xf35e5f3537c0ad0e938fdedd454de9,\n                0xd53c652cc3aac5d11fe6f5bc7ec536,\n                0x5d6869f0dd8b00697743f956b9b112,\n                0x5d46286274a1128a8fe0d96e859837,\n                0x951ee9dcb59dacebba972e9b9d7cfd,\n                0xd22245a462bff840a882f6869689a5,\n                0xcf7605b64a20dc2c3e6d5ceb88a03a,\n                0x7831aa25052c11411c3e5bdbe7dc10,\n                0x8e3bce799814987c984a2cc0e5d283,\n                0x7fdb0ce6e413e0f32742f4652f14a2,\n                0xa896a360bd70243209390e00761c57,\n                0x0d326051ac677371678f92bd182f13,\n                0xfcc593faaa9f45448ab756d70def,\n                0x2fd6d46ec8d25a6648dadf8246daf0,\n                0xe4aea2700222e610c1d94d82dd0f52,\n                0x9b,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 3));\n    }\n\n    // Test an unusual key length that is not a multiple of 8\n    /*#[test]\nfn test_verify_sha256_pss_1964() {\n    let sha256_hash: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n    let params: Params1964 = BigNumParams::new(\n        false,\n        [\n            0x75ac0d9987aebebd25983ab5a48fdf,\n            0xae0a5ffc69f51e789ea8f90a72745b,\n            0x9b8c92fb6ea3ca021a894ae52025f1,\n            0x50de84cce0d856376083aa1785fd38,\n            0xa912e3aabd4191e143128ce89e2086,\n            0xcf361d0e7f4fb458b950ca7f58414e,\n            0xe27bbefff3820e512b05a07d2d7e1c,\n            0x7a2fd42d837098a67f056f1b15ed33,\n            0x4ebeddd5d6fde42dc68ba5bb2a3732,\n            0x2d1cbcf87c37b430c33b04aa35ce2b,\n            0x9e9cd702ef1e7191c78e712ac6e151,\n            0x9aef318e4318c313c0cf0c71ba378b,\n            0xc1cd2e631f327acf58dca9f4e63bfd,\n            0xc828e43ce8acda48fa1fff12de4df4,\n            0x2d91364c2a898031a0ea615c82fe50,\n            0x3fed935e1e73af131b48aafef030d7,\n            0xc278be706ab,\n        ],\n        [\n            0xd4343ba7542877db4a663c12d159c,\n            0xb7f3ebb5e9a7e46abb5fa5ebebf068,\n            0x6f2ab6c72bbdcd87bf3cd5343f7059,\n            0xa437eae960f2ac5714f7a35b803598,\n            0xae01beec10904488485933615d62b6,\n            0xf9509a6004d765dfa27536888f2757,\n            0x57dbdd558fa8831a632849dbaecdfa,\n            0xe7c4027a23af2ef309461db1f95629,\n            0x388a2b780c78da825692f1cec5055e,\n            0xd064ac53ec3c505b8e8e25b9350ce7,\n            0x529b1374876a3bbf8e83e5d239cd69,\n            0x7206c8bf4a0d11655219207de991b4,\n            0x5fe1135077b5b760d31bdbfcb4f698,\n            0xdb00d1d10cdb6c91c0f93f4b1a18c8,\n            0x8329224ca1e3c5ef415cb1629f82d8,\n            0xecca0fb0c3e52adfd165bbf85b34eb,\n            0x150fec084e187,\n        ],\n    );\n    let signature: RBN1964 = RuntimeBigNum {\n        params,\n        limbs: [\n            0xbd4bab3d5a9af46cac40fc2f6c9547,\n            0xd3e04f0b8e833f1e80a4022684694f,\n            0xbb4267e4fc29ec83dc8398dc547fca,\n            0xba625b4fdf379883f6ccabede3574a,\n            0xc9736193ab3cc0d1ef8ea63fdba46f,\n            0x72dc058e8abcbe15ed09e97c1bb58a,\n            0x98d8c915cb9447bcce3bbfc0f92032,\n            0x9a0778461e9dec09e41c0ea354a41f,\n            0xe4a6b80a5f62abf93268cde64b5e9c,\n            0xd36dc0ccfdc6d9d8e8a939a3e762d0,\n            0x1b2593bff17ff433ee20f1a60c6861,\n            0x78115ebfd2484df0b59abfa3222e79,\n            0x7693ac9aa8acfb4b5379c0adbcb7d1,\n            0xd76979aa97b41f1f58c65ad896f1cf,\n            0xe1f7c4fa2dc6cbe0162be9adb01c14,\n            0x5f5a8f5b9ca6fe12c4fe3c00795f10,\n            0x8b4a98cedd,\n        ],\n    };\n\n    assert(verify_sha256_pss(sha256_hash, signature, 65537));\n}*/\n\n    // Test an edge case where the key length in bytes is greater than the encoded message length\n    #[test]\n    fn test_verify_sha256_pss_1025() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params1025 = BigNumParams::new(\n            false,\n            [\n                0xf278b138628000b2652c779e852235,\n                0x6d0676977e76ef0429002673ce9be2,\n                0x6cfc0db4d97f20ad2a1ad48cd899a0,\n                0x64024c19a1b1540e23ba4531e677f2,\n                0x3696125dd256ffed9567fccff06be6,\n                0x2dc09476b0c7629eed3c7c2cb591e3,\n                0x2e007f2f978504c5cfea0ec51ba0e9,\n                0x84ec9458cc6d0e95e06a7f404f26b4,\n                0x174fd186dca48668a,\n            ],\n            [\n                0x7ab08c63fb6eeee6204bd814d3134a,\n                0x20d51c551c06e8ae471cc43e84d131,\n                0x5eac3eae8238c6c2c37c1ce5bec407,\n                0xcff61632bd2ea6bc1dc8da002aa0c5,\n                0x801c1e85137856c4a6dc8c25078a59,\n                0x5ce8ee248cac12cbc3faa426acd58b,\n                0xe72384bb8302bbb78a3766fc61c5f0,\n                0x6ea716c0a657933b91b2d488b29cec,\n                0x2bed1ff958b58c194c,\n            ],\n        );\n\n        let signature: RBN1025 = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa90e06eff7cbd20dd9c1241fe89290,\n                0x9ff719ce8f34229cd248e1f0ef4246,\n                0xd1d032dbf236cd711aa4fb49f0c71f,\n                0x454abf136ae14c7617df3b4d505e08,\n                0x45f30ac2c023205d35803f114f8ee3,\n                0xc8b1265c786d6da808ab31d35795a1,\n                0x1f75005a85f3636b099c58edd9fb8e,\n                0xac251bf9bb342b551c0f5c80449a3f,\n                0x03e2bc114292962b,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha1_pkcs1v15_2048() {\n        let sha1_hash: [u8; 20] = sha1::sha1_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x156ceaf444d8819f2aedf0ba175481,\n                0xd3bf95380882ed1e760191e383dc84,\n                0x8585e65def5c89b3b3aeab9ceb6c80,\n                0xf215a93f61d5165db91d88a871368c,\n                0x5274e088a95fb4053f26fcc5619e6d,\n                0xf4494a491b66f30025ee633bed7a72,\n                0x801bdf85598a082dbac2b26a4fbff9,\n                0x9cd2905057dcca8c319d294785aa89,\n                0xb155d5581ec0bfd4096e6878b3bc25,\n                0xa0cfdf3decd16f8dde113e85a38c7b,\n                0x9452a725f9f2f3e82ebef589345c23,\n                0x1984df6bd68eaf0cc88b42b166ab6c,\n                0xff925851486b26af0a896eae9c7fe9,\n                0xe6fd92b72a2381389820a8ab283ff3,\n                0xbd5a35556d716ba8685d106a944555,\n                0xd9102f1ca16442372df5234fc4c23,\n                0xae1aa56a4a4e1b155af1ac4fbef88a,\n                0xdc,\n            ],\n            [\n                0x8ad3c9e65e7035db6d57a4182a4fb2,\n                0x9df5db4eabb63cb8306ba17ab7d99,\n                0x4177c0f5014aa2717306987d9ff827,\n                0xb35faed8cc169c33eecfac2341d47d,\n                0xff5faf8dbca65f1431a5d94d3a6d60,\n                0xbd49ab8984a0739a666a81bcf41f4,\n                0xb97ef986aa48a3f9c5160b1a9165c5,\n                0x3b34d06a7867dc8c0e9411bb389f30,\n                0x66ccff351294c073811e0e018e0917,\n                0x4bb0ee68c1f5ddebb71a9dd3a6df38,\n                0x29d2d550ec2d549320fec501d71108,\n                0x6609e5236bb550a30e29378259ed01,\n                0x4c33e3f52407cc796ba41acfaa3007,\n                0x6e6ec514bb4f26c0ac197aa2f995f2,\n                0x47967368b344f7c4fe0e84bdddc040,\n                0x1dc9219753dbeb4aa003c81b210e0e,\n                0x90dbe39955df1d4aa7c6efce2a8b3d,\n                0x128f,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x1999f7717a7fd287d0b3e2d66a3437,\n                0xc8fb6805554123679c362e6f002aae,\n                0x3facdc5f1def4f49606b908e2a2538,\n                0xc05aa4965a11190493a6f4e7fd5984,\n                0x1672f3416fb95821efcb5375f1779e,\n                0x2f81eb13f1894268f4acb1b0ae7513,\n                0x15d997bac63df6624c2603e93cb0fa,\n                0x536c959eea6cb9fc3980b86d9877b7,\n                0x4296d1c42936c208b6ae13cd06d60b,\n                0x39144ec79fc42ccc160b14c8b793e4,\n                0xc40a783835d9df4c5f69ba68faaa,\n                0xde2af88216d83b8136f094d8945b95,\n                0x4ecac07a39171bd9a01383a4919924,\n                0x737d8ffc839f4a503c431c507ba5f3,\n                0x844f4957cf4b01c277f67a7591b7f5,\n                0x0291a8afc7cda7e4c6e73e011c181f,\n                0x7afcd49577ffbc75fbe9a2e2959b82,\n                0x83,\n            ],\n        };\n\n        assert(verify_sha1_pkcs1v15(sha1_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha1_pss_2048() {\n        let sha1_hash: [u8; 20] = sha1::sha1_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x8076ee27cf6ed266e737de20b03e47,\n                0xbd07415cda0752a917b4f40d19c992,\n                0xd473ccfa4dc8a5690c17eceab674d4,\n                0xdf2645d4e31531b5e68d7b30152182,\n                0xe4e6d87d9b3222f56ddc48b46dc544,\n                0x587c5d66e6970f42fe18afa99b5e5b,\n                0x30261d8162c75fe7ba96ab0c2a6dd3,\n                0xdc69073390846c7fb3c98c9c316d60,\n                0x4b6a2bc2c1e5131129539c38b0ac3b,\n                0xf05187e8d7cf34d2c1685409173080,\n                0x2d26be5b0d792a3d92b7d4062b3d44,\n                0x4eb7f21f6c4e3df8d2829f6b3e6eaa,\n                0x9f1cd4d18bd53d4bbcf804651435f3,\n                0x3d266b2f1223e08dd2159d58cb48d4,\n                0x873625d48c8244c51924bfdee0c6ac,\n                0xfcbf5c61a9d3cf2d0e13686af8d0de,\n                0xb4345e8b5be7510698390901722861,\n                0xba,\n            ],\n            [\n                0x51b40d9d6a288a5396a16f9fc85f2a,\n                0xbc36a9bf43ffceed626f118da3b290,\n                0xdcff05073f93178b589ab93edcfa9d,\n                0x42fe8b2c11fb9eb89432cd017ecae3,\n                0x7c74c2b03dc0a6ef97319821e6adaa,\n                0xf35c6951909aa944366d8e5f8f435f,\n                0x211b51cea0e9e9db01a1803ff9d995,\n                0xe9632ae2bbff5ecfb13344716976aa,\n                0x5ac98d1f7f9796c5f4360a6c53c0ac,\n                0x21cad5d27ccd949ab83384e613df0f,\n                0x7305d4a53c3121804a7e563663ac19,\n                0x42f7f8514dc823f5cec8029950f51d,\n                0x88af0d59283ad9e8ceadd7275f9665,\n                0xe377f531eb845e3ae55cb1f4f00845,\n                0x863da2aa3bd54edc8b6da777626340,\n                0xe92dc9d46715752498a8eda776a039,\n                0x401e4c6793f0bc7f5da805da5cd5bb,\n                0x15f0,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x835c0b9302499888acedea4013ec92,\n                0xe1f4b56b2ca0ad8c1ee3b8a9a85d93,\n                0x5d4fecc54034eb1091ca9fc28e3ff1,\n                0xab316868780469b1621c789b8d8b75,\n                0x13205cae60d93b387ef282c901bb,\n                0x776e846d321b59b584c6de6ae6da18,\n                0x6170c33330baeaee6a3de84e32f031,\n                0x3862d9f28a50c32f0f09a6e5e60560,\n                0x83e54c8d5a9522e5addc4cb35078b1,\n                0xf4cd91425b0b042fb1cbb81d0ce6d6,\n                0x33c49780bb4c00637bfd9f5de1d1cc,\n                0xcbd14e26c78a769ff0e47854ff9d72,\n                0x459db8d780c5287c894d8d419ec583,\n                0x19909716db20e09223fbc169d58ed4,\n                0x62efd0331023145d761b8568fc93c9,\n                0xcac052c722d08645d4ad31464f665a,\n                0x33c6a0e25cd27dbfd1d15fc2197aa5,\n                0x89,\n            ],\n        };\n\n        assert(verify_sha1_pss(sha1_hash, signature, 65537));\n    }\n\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/zkpassport/noir_rsa/saleel/sha-version/src/rsa.nr"
        },
        "165": {
            "source": "mod utils;\n\npub use utils::{conditional_select, DebugRandomEngine};\nuse std::collections::bounded_vec::BoundedVec;\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"haystack\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @details the \"body\" parameter contains some input bytes, zero-padded to the nearest multiple of 31\n *          We pack \"bytes\" into 31-byte \"chunks\", as this is the maximum number of bytes we can fit\n *          into a field element without overflowing.\n *          TODO: once we can derive generics via arithmetic on other generics, we want this \"31\" parameter\n *          to be defined by the backend being used instead of being hardcoded to 31\n *\n * @note We perform this 31-byte packing because it dramatically reduces the number of constraints required for substring matching. See (chicken)\n *\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunks: the number of 31-byte chunks needed to represent MaxPaddedBytes\n **/\npub struct StringBody<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    chunks: [Field; PaddedChunks],\n    pub byte_length: u32,\n}\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"needle\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunksMinusOne: the number of 31-byte chunks needed to represent MaxPaddedBytes minus one!\n *\n * @note PaddedChunksMinusOne is because we are going to do the following:\n *                            1. align the SubString bytes according to the StringBody bytes being matched against\n *                            2. split the aligned bytes into 31-byte chunks. The 1st and last chunks might contain\n *                               fewer than 31 bytes due to the above alignment\n *                            3. validate the aligned-byte-chunks match the StringBody byte chunks\n *       To account for the fact that the 1st and last chunks might have fewer bytes we treat those separately\n *       The param PaddedChunksMinusOne is the number of 31-byte chunks required to represent SubString *EXCLUDING* the initial and final chunks\n */\npub struct SubString<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    pub byte_length: u32,\n}\n\npub type StringBody32 = StringBody<62, 2, 32>;\npub type StringBody64 = StringBody<93, 3, 64>;\npub type StringBody128 = StringBody<155, 5, 128>;\npub type StringBody256 = StringBody<279, 9, 256>;\npub type StringBody512 = StringBody<527, 17, 512>;\npub type StringBody1024 = StringBody<1054, 34, 1024>;\npub type StringBody2048 = StringBody<2077, 67, 2048>;\npub type StringBody4096 = StringBody<4123, 133, 4096>;\npub type StringBody8192 = StringBody<8215, 265, 8192>;\npub type StringBody16384 = StringBody<16399, 529, 16384>;\n\npub type SubString32 = SubString<62, 1, 32>;\npub type SubString64 = SubString<93, 2, 64>;\npub type SubString128 = SubString<155, 4, 128>;\npub type SubString256 = SubString<279, 8, 256>;\npub type SubString512 = SubString<527, 16, 512>;\npub type SubString1024 = SubString<1054, 33, 1024>;\n\npub trait SubStringTrait {\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        num_bytes_in_first_chunk: u32,\n        body_chunk_offset: u32,\n        num_full_chunks: u32,\n    );\n\n    fn len(self) -> u32;\n    fn get(self, idx: u32) -> u8;\n    fn get_body(self) -> [u8];\n}\n\n// ######################################################\n// S U B S T R I N G\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    /**\n     * @brief construct a SubString object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(input: [u8; InputBytes], input_length: u32) -> Self {\n        assert(MaxBytes <= MaxPaddedBytes);\n        assert(input_length <= MaxBytes);\n        assert(InputBytes <= MaxBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together\n     * @details each SubString can have different MaxBytes sizes, however we need OtherBytes <= MaxBytes\n     *          (use concat_into for cases where this is not the case)\n     **/\n    pub fn concat<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> Self {\n        assert(\n            OtherPaddedBytes <= MaxPaddedBytes,\n            \"SubString::concat. SubString being concatted has larger max length. Try calling concat_into\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxPaddedBytes,\n            \"SubString::concat, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body = self.body;\n        let offset: u32 = self.byte_length;\n        for i in 0..MaxPaddedBytes {\n            if (i + offset < MaxPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together. Return type has OtherPaddedBytes max bytes\n     * @details each SubString can have different MaxBytes sizes, however we need MaxBytes <= OtherBytes\n     *          (use concat for cases where this is not the case)\n     **/\n    pub fn concat_into<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes> {\n        assert(\n            MaxPaddedBytes <= OtherPaddedBytes,\n            \"SubString::concat_into. SubString being concat has larger max length. Try calling concat\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= OtherPaddedBytes,\n            \"SubString::concat_into, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body: [u8; OtherPaddedBytes] = [0; OtherPaddedBytes];\n        for i in 0..MaxBytes {\n            body[i] = self.body[i];\n        }\n\n        let offset: u32 = self.byte_length;\n        for i in 0..OtherPaddedBytes {\n            if (i + offset < OtherPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubStringTrait for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    fn len(self) -> u32 {\n        self.byte_length\n    }\n    fn get(self, idx: u32) -> u8 {\n        self.body[idx]\n    }\n    fn get_body(self) -> [u8] {\n        let x = self.body.as_slice();\n        x\n    }\n\n    /**\n     * @brief given some `haystack` 31-byte chunks, validate that there exist `num_full_chunks`\n     *        in the SubString, starting at byte position `starting_needle_byte`.\n     *        The selected chunks must be equal to the haystack chunks starting at `starting_haystack_chunk`\n     **/\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        starting_needle_byte: u32,\n        starting_haystack_chunk: u32,\n        num_full_chunks: u32,\n    ) {\n        let mut substring_chunks: [Field; PaddedChunksMinusOne] = [0; PaddedChunksMinusOne];\n        // pack the substring into 31 byte chunks.\n        // This is fairly expensive as we need a ROM table to access the SubString.body\n        // which is 2 gates per byte\n        for i in 0..PaddedChunksMinusOne {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let substring_idx = starting_needle_byte + (i * 31) + j;\n                let mut byte = self.body[substring_idx];\n                slice += byte as Field;\n            }\n            std::as_witness(slice);\n            substring_chunks[i] = slice;\n        }\n        // iterate over the needle chunks and validate they match the haystack chunks\n        for i in 0..PaddedChunksMinusOne {\n            let predicate = i < num_full_chunks;\n            let lhs = substring_chunks[i];\n            let rhs = haystack[predicate as u32 * (i + starting_haystack_chunk)];\n            assert(predicate as Field * (lhs - rhs) == 0);\n        }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n// ######################################################\n// S T R I N G   B O D Y\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> StringBody<MaxPaddedBytes, PaddedChunks, MaxBytes> {\n\n    /**\n     * @brief construct a StringBody object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(data: [u8; InputBytes], length: u32) -> Self {\n        assert(length <= MaxBytes);\n        assert(length <= InputBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = data[i];\n        }\n        StringBody { body, chunks: compute_chunks(body), byte_length: length }\n    }\n\n    /**\n     * @brief Validate a substring exists in the StringBody. Returns a success flag and the position within the StringBody that the match was found\n     **/\n    pub fn substring_match<NeedleSubString>(self, substring: NeedleSubString) -> (bool, u32)\n    where\n        NeedleSubString: SubStringTrait,\n    {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text\n        let position: u32 = unsafe {\n            // Safety: The rest of this function checks this.\n            utils::search(\n                self.body,\n                substring.get_body(),\n                self.byte_length,\n                substring.len(),\n            )\n        };\n\n        assert(\n            position + substring.len() <= self.byte_length,\n            \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\",\n        );\n        let substring_length = substring.len();\n\n        // chunk_index = which 31-byte haystack chunk does the needle begin in?\n        let chunk_index: u32 = position / 31;\n        // chunk_offset = how many haystack bytes are present in the 1st haystack chunk?\n        let chunk_offset: u32 = position % 31;\n        // how many needle bytes are in 1st haystack chunk?\n        let num_bytes_in_first_chunk: u32 = 31 - chunk_offset;\n        let mut starting_needle_byte_index_of_final_chunk: u32 = 0;\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes: u32 = 0;\n        let mut num_full_chunks = 0;\n\n        // is there only one haystack chunk that contains needle bytes?\n        let merge_initial_final_needle_chunks = substring_length < num_bytes_in_first_chunk;\n\n        // if the above is false...\n        if (!merge_initial_final_needle_chunks) {\n            // compute how many full 31-byte haystack chunks contain 31 needle bytes\n            num_full_chunks = (substring_length - num_bytes_in_first_chunk) / 31;\n            // for the final haystack chunk that contains needle bytes, where in the needle does this chunk begin?\n            starting_needle_byte_index_of_final_chunk =\n                num_full_chunks * 31 + num_bytes_in_first_chunk;\n\n            // what is the index of the final haystack chunk that contains needle bytes?\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes =\n                num_full_chunks + chunk_index + 1;\n        } else {\n            starting_needle_byte_index_of_final_chunk = 0;\n            // if the needle bytes does NOT span more than 1 haystack chunk,\n            // the final haystack index will be the same as the initial haystack index\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index;\n        }\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n        when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n        a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n        Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n        The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n        If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let offset_to_first_needle_byte_in_chunk: u32 = chunk_offset;\n        let initial_haystack_chunk = self.chunks[chunk_index];\n        let final_haystack_chunk =\n            self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n\n        let initial_body_bytes: [u8; 31] = initial_haystack_chunk.to_be_bytes();\n        let final_body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes();\n\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: u32 = i;\n            let predicate = i < offset_to_first_needle_byte_in_chunk;\n            let lhs: Field = initial_body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = if predicate {\n                0\n            } else {\n                idx - offset_to_first_needle_byte_in_chunk\n            };\n            let rhs: Field = substring.get(substring_idx) as Field;\n            let byte: Field = predicate as Field * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // If `merge_initial_final_needle_chunks = true`, `final_chunk` will contain the full needle data,\n        // this requires some complex logic to determine where we are sourcing the needle bytes from.\n        // Either they come from the `initial_chunk`, the haystack bytes or the substring bytes.\n        for i in 0..31 {\n            let mut lhs_index = starting_needle_byte_index_of_final_chunk + i;\n            let predicate = lhs_index < substring_length;\n            /*\n                | merge_initial_final_needle_chunks | predicate | byte_source              |\n                | false                             | false     | body_bytes[i]            |\n                | false                             | true      | substring[lhs_idx]       |\n                | true                              | false     | body_bytes[i]            |\n                | true                              | true      | initial_chunk[lhs_index] |\n            NOTE: if `merge = true` and `predicate = true`, we read from `initial_chunk` to short-circuit some extra logic.\n                      if `initial_chunk` did not exist, then we would need to validate whether `i < offset_to_first_needle_byte_in_chunk`.\n                      if true, the byte source would be body_bytes, otherwise the source would be substring bytes\n            */\n            let substring_idx = (predicate as u32) * lhs_index;\n            let byte_from_substring = substring.get(substring_idx) as Field;\n            let byte_from_initial_chunk = initial_chunk[i] as Field;\n            let byte_from_haystack = final_body_bytes[i] as Field;\n\n            // TODO: find out why this cuts 1 gate per iteration\n            std::as_witness(byte_from_initial_chunk);\n\n            let p = predicate as Field;\n            let m = merge_initial_final_needle_chunks as Field;\n            // p * (m * (a - b) + (b - c)) + c\n            let ab = byte_from_initial_chunk - byte_from_substring;\n            std::as_witness(ab);\n            let bc = byte_from_substring - byte_from_haystack;\n            let t0 = m * ab + bc;\n            let destination_byte = p * t0 + byte_from_haystack;\n\n            final_chunk[i] = destination_byte;\n        }\n\n        // TODO: moving this above the previous code block adds 31 gates. find out why? :/\n        let mut initial_needle_chunk: Field = 0;\n        let mut final_needle_chunk: Field = 0;\n\n        // Construct the initial and final needle chunks from the byte arrays we previously built.\n        // Validate they match the initial and final haystack chunks\n        for i in 0..31 {\n            initial_needle_chunk *= 256;\n            initial_needle_chunk += initial_chunk[i];\n            final_needle_chunk *= 256;\n            final_needle_chunk += final_chunk[i];\n        }\n\n        std::as_witness(initial_needle_chunk);\n        std::as_witness(final_needle_chunk);\n\n        initial_needle_chunk = merge_initial_final_needle_chunks as Field\n            * (final_needle_chunk - initial_needle_chunk)\n            + initial_needle_chunk;\n        assert(initial_needle_chunk == initial_haystack_chunk);\n        assert(final_needle_chunk == final_haystack_chunk);\n\n        // Step 3: Construct needle chunks (for all but the 1st and last chunks) and validate they match the haystack chunks.\n        //         This part is much simpler as we know that all bytes in the chunk are sourced from the needle chunk.\n        // NOTE:   If we chose to not pack bytes into 31-byte chunks, the string matching algorithm would be simpler but more expensive.\n        //         Instead of matching chunks with each other, we would match individual byte values.\n        //         i.e. the number of iterations in this loop would be 31x greater\n        //         each loop iteration would also require a predicate, to check whether the byte index was within the needle range or not\n        //         Combined these two operations would add about 10 gates per loop iteration,\n        //         combined with a 31x iteration length would make this algorithm much more costly than the chunked variant\n        let body_chunk_offset = chunk_index + 1;\n        substring.match_chunks(\n            self.chunks,\n            num_bytes_in_first_chunk,\n            body_chunk_offset,\n            num_full_chunks,\n        );\n        (true, position)\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for StringBody<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n/// Given an input byte array, convert into 31-byte chunks\n///\n/// Cost: ~0.5 gates per byte\nfn compute_chunks<let MaxPaddedBytes: u32, let PaddedChunks: u32>(\n    body: [u8; MaxPaddedBytes],\n) -> [Field; PaddedChunks] {\n    let mut chunks: [Field; PaddedChunks] = [0; PaddedChunks];\n    for i in 0..PaddedChunks {\n        let mut limb: Field = 0;\n        for j in 0..31 {\n            limb *= 256;\n            limb += body[i * 31 + j] as Field;\n        }\n        chunks[i] = limb;\n        std::as_witness(chunks[i]);\n    }\n    chunks\n}\n\n#[test]\nfn test() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \"olor\".as_bytes();\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString32 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog\".as_bytes();\n    let needle_text = \" the lazy dog\".as_bytes();\n\n    let mut haystack: StringBody256 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString256 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_haystack_equal_size() {\n    let haystack_text =\n        \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n    let needle_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n\n    let mut haystack: StringBody64 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_concat() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString128 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nfn test_concat_into() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat_into(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nunconstrained fn test_partial_match() {\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 1024] = Engine.get_random_bytes();\n    let mut bar: [u8; 128] = [0; 128];\n    for i in 0..128 {\n        bar[i] = foo[i + 123];\n    }\n    let position = utils::search(foo, bar.as_slice(), 1024, 128);\n\n    assert(position == 123);\n}\n\n#[test]\nfn test_substring_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_string_body_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn regression_20() {\n    let haystack: [u8; 128] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x92, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x6e, 0x00, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    let needle: [u8; 32] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    let needle_len: u32 = 0x20;\n    let id_haystack: StringBody128 = StringBody::new(haystack, 128);\n    let pk_needle: SubString32 = SubString::new(needle, needle_len);\n    let (result, _): (bool, u32) = id_haystack.substring_match(pk_needle);\n    assert(result);\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/lib.nr"
        },
        "166": {
            "source": "pub unconstrained fn search<let N: u32>(\n    haystack: [u8; N],\n    needle: [u8],\n    haystack_length: u32,\n    needle_length: u32,\n) -> u32 {\n    assert(needle_length > 0, \"needle length of size 0 not supported\");\n    assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n    let mut found = false;\n    let mut found_index: u32 = 0;\n    for i in 0..haystack_length - needle_length + 1 {\n        if (found == true) {\n            break;\n        }\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    assert(found == true, \"utils::search could not find needle in haystack\");\n    found_index\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    if (predicate) {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    // Safety: This is all just a very verbose `if (predicate) { lhs } else { rhs }`\n    // formulated as `rhs + (lhs - rhs) * predicate`\n    unsafe {\n        let result = __conditional_select(lhs, rhs, predicate);\n        let result_f = result as Field;\n        let lhs_f = lhs as Field;\n        let rhs_f = rhs as Field;\n\n        let diff = lhs_f - rhs_f;\n        std::as_witness(diff);\n        assert_eq((predicate as Field) * diff + rhs_f, result_f);\n        result\n    }\n}\n\npub struct DebugRandomEngine {\n    pub seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes();\n        let hash: [u8; 32] = std::hash::blake3(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    pub unconstrained fn get_random_bytes<let NBytes: u32>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u32;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/utils.nr"
        }
    },
    "names": [
        "main"
    ],
    "brillig_names": [
        "remove_extra_zeros_from_partial_data",
        "print_unconstrained",
        "build_msg_block_iter",
        "pad_msg_block",
        "attach_len_to_msg_block",
        "__mul",
        "compute_quadratic_expression_with_borrow_flags",
        "extract_claim_unconstrained",
        "__boundary_check",
        "__validate_decoded",
        "search",
        "extract_claim_unconstrained",
        "get_domain_start_index_in_email",
        "print_unconstrained",
        "print_unconstrained",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
    ]
}