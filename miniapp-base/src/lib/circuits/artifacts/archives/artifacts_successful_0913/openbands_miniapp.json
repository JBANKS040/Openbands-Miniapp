{
    "noir_version": "1.0.0-beta.11+fd3925aaaeb76c76319f44590d135498ef41ea6c",
    "hash": "10991023315433717763",
    "abi": {
        "parameters": [
            {
                "name": "partial_data",
                "type": {
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec",
                    "fields": [
                        {
                            "name": "storage",
                            "type": {
                                "kind": "array",
                                "length": 640,
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 8
                                }
                            }
                        },
                        {
                            "name": "len",
                            "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        }
                    ]
                },
                "visibility": "private"
            },
            {
                "name": "partial_hash",
                "type": {
                    "kind": "array",
                    "length": 8,
                    "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                    }
                },
                "visibility": "private"
            },
            {
                "name": "full_data_length",
                "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                },
                "visibility": "private"
            },
            {
                "name": "base64_decode_offset",
                "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                },
                "visibility": "private"
            },
            {
                "name": "jwt_pubkey_modulus_limbs",
                "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 128
                    }
                },
                "visibility": "private"
            },
            {
                "name": "jwt_pubkey_redc_params_limbs",
                "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 128
                    }
                },
                "visibility": "private"
            },
            {
                "name": "jwt_signature_limbs",
                "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 128
                    }
                },
                "visibility": "private"
            },
            {
                "name": "domain",
                "type": {
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec",
                    "fields": [
                        {
                            "name": "storage",
                            "type": {
                                "kind": "array",
                                "length": 64,
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 8
                                }
                            }
                        },
                        {
                            "name": "len",
                            "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                            }
                        }
                    ]
                },
                "visibility": "public"
            }
        ],
        "return_type": {
            "abi_type": {
                "kind": "field"
            },
            "visibility": "public"
        },
        "error_types": {
            "2920182694213909827": {
                "error_kind": "string",
                "string": "attempt to subtract with overflow"
            },
            "5019202896831570965": {
                "error_kind": "string",
                "string": "attempt to add with overflow"
            },
            "5675127253506927136": {
                "error_kind": "string",
                "string": "utils::search could not find needle in haystack"
            },
            "5727012404371710682": {
                "error_kind": "string",
                "string": "push out of bounds"
            },
            "5795655218219125583": {
                "error_kind": "string",
                "string": "Field failed to decompose into specified 8 limbs"
            },
            "6314603625877298116": {
                "error_kind": "string",
                "string": "haystack length of size 0 not supported"
            },
            "6485997221020871071": {
                "error_kind": "string",
                "string": "call to assert_max_bit_size"
            },
            "6543056410826478903": {
                "error_kind": "string",
                "string": "incorrect value for claim"
            },
            "6668324276689745315": {
                "error_kind": "string",
                "string": "Field failed to decompose into specified 4 limbs"
            },
            "7233212735005103307": {
                "error_kind": "string",
                "string": "attempt to multiply with overflow"
            },
            "7788270038095378938": {
                "error_kind": "string",
                "string": "substring not present in main text (match found if a padding text included. is main text correctly formatted?)"
            },
            "8403890105346170400": {
                "error_kind": "string",
                "string": "Field failed to decompose into specified 31 limbs"
            },
            "9281715815618326061": {
                "error_kind": "string",
                "string": "invalid domain"
            },
            "10713088778935619315": {
                "error_kind": "string",
                "string": "char before domain is not '@'"
            },
            "11393010598460336492": {
                "error_kind": "fmtstring",
                "length": 58,
                "item_types": [
                    {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                    },
                    {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                    }
                ]
            },
            "11856048133850814249": {
                "error_kind": "string",
                "string": "Field failed to decompose into specified 1 limbs"
            },
            "13815800804469369678": {
                "error_kind": "string",
                "string": "partial_data length is too long"
            },
            "14225679739041873922": {
                "error_kind": "string",
                "string": "Index out of bounds"
            },
            "14870952237766754546": {
                "error_kind": "string",
                "string": "Field failed to decompose into specified 30 limbs"
            },
            "15412340888643424233": {
                "error_kind": "string",
                "string": "needle length of size 0 not supported"
            },
            "17135372224865900210": {
                "error_kind": "string",
                "string": "Field failed to decompose into specified 15 limbs"
            },
            "17843811134343075018": {
                "error_kind": "string",
                "string": "Stack too deep"
            }
        }
    },
    "bytecode": "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",
    "debug_symbols": "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JuvBJvWrJvWrJvWrJvmqSf2qSf2qSf2qSf1K5rebzG83md9uMr/dZH67SX+7NalfNVkPNqlfNalfNalfNclXTepXTepXTepXTepXMr/dZH67yfx2k/ntJvPbTfrbrUn9qsl6sEn9qkn9qkn9qkm+alK/alK/alK/alK/kvntJvPbTea3m8xvN5nfbjK/3ZrUr5qsB5vUr5rUr5rUr5rkK5nfbjK/3WR+uzWpX8n8dpP57Sbz261J/apJvmqSr5rUr2R+u8n8dmtSv2pSv2qSr2R+uzWpXzWpXzWpX8n8dpP57Sbz261J/apJvmqSr5rUr2R+u8n8dmtSv+pSv+qSr2R+u3WpX3WpX3WpX8n8dpP57Sbz261L/apLvuqSr7rUr2R+u8n8dutSv+pSv+qSr2R+u3WpX3WpX3WpX8n8dpP57Sbz261L/apLvuqSr7rUr2R+u8n8dutSv+pSv+qSr2R+u3WpX3WpX3WpX8n8dpP57Sbz261L/apLvuqSr7rUr2R+u8n8dutSv+pSv+qSr2R+u3WpX3WpX3WpX8n8dpP57Sbz261L/apLvuqSr7rUr2R+u8n8dutSv+pSv+qSr2R+u3WpX3WpX3WpX8n8dpP57Sbz261L/apLvuqSr7rUr2R+u8n8dutSv+pSv+qSr2R+u3WpX3WpX3WpX8n8dpP57Sbz261L/apLvuqSr7rUr2R+u8n8dutSv+pSv+qSr2R+u3WpXw2pXw2pX8n8dpP57Sbz221I/WpIvhqSr4bUr2R+u8n8dhtSvxpSvxqSr2R+uw2pXw2pXw2pX8n8dpP57Sbz221I/WpIvhqSr4bUr2R+u8n8dhtSvxpSvxqSr2R+uw2pXw2pXw2pX8n8dpP57Sbz221I/WpIvhqSr4bUr2R+u8n8dhtSvxpSvxqSr2R+uw2pXw2pXw2pX8n8dpP57Sbz221I/WpIvhqSr4bUr2R+u8n8dhtSvxpSvxqSr2R+uw2pXw2pXw2pX8n8dpP57Sbz221I/WpIvhqSr4bUr2R+u8n8dhtSvxpSvxqSr2R+uw2pXw2pXw2pX8n8dpP57Sbz221I/WpIvhqSr4bUr2R+u8n8dhtSvxpSvxqSr2R+uw2pXw2pXw2pX8n8dpP57Sbz221K/WpKvpqSr6bUr2R+u8n8dptSv5pSv5qSr2R+u02pX02pX02pX8n8dpP57Sbz221K/WpKvpqSr6bUr2R+u8n8dptSv5pSv5qSr2R+u02pX02pX02pX0l/u0l/u0l/u0l/u0l/u0l/u02pX8n8dpP57TalfjWlfjUlX8n8dptSv5pSv5pSv5L+dpP+dpP+dpP+dpP+dpP+dptSv5L57Sbz221K/WpK/WpKvpL57TalfjWlfjWlfiX97Sb97Sb97Sb97Sb97Sb97TalfiXz203mt9uU+tWU+tWUfDUlX03JV6u/vSUP4Skc5DNfHVyEsc/LJvcP2uT+QZvcP2iT+wdtcv+gTe4ftMn9gza5f9Am9w/aDNEN0Q3RDdEN0Q3RDdHl/kEL7h+04P5BC+4ftOD+QQvuH7Tg/kEL7h+04P5BC+4ftNhEt4huEd0iukV0i+gW0S2iW0S3iG4R3Sq6VXSr6FbRraJbRbeKbhXdKrpVdE10TXRNdE10TXRNdE10TXRNdE10XXRddF10XXRddF10XXRddF10XXSb6DbRbaLbRLeJbhPdJrpNdJvoNtHtottFt4tuF90uul10u+h20e2i20V3iO4Q3SG6Q3SH6A7RHaI7RHeI7hDdKbpTdCVfheSrkHwVkq9C8lVIvgrJVyH5KiRfheSrkHwVkq9C8lVIvgrJVyH5KiRfBfOVb8xXvjFf+cZ85RvzlW/MV74xX/nGfOUb85VvzFe+baJbRLeIbhHdIrpFdIvoFtEtoltEt4huFd0qulV0q+hW0a2iW0W3im4V3Sq6Jromuia6Jromuia6Jromuia6Jrouui66Lrouui66Lrouui66Lrouuk10m+g20W2i20S3iW4T3Sa6Z76y5CCf+ergIlyFTdiFm3AXHsKiy/3OvnG/s2/c7+wb9zv7xv3OvnG/s2/c7+wb9zv7xv3OvnG/s29DdKfoTtGdojtFd4ruFN0pulN0p+hO0Q3RDdEN0Q3RDdEN0Q3RDdEN0eV+Zy/c7/ziIlyFTdiFm3AXHsJTWHSL6BbRLaJbRLeIbhHdIrpFdIvoFtGtoltFt4puFd0qulV0q+hW0a2iW0XXRNdE10TXRNdE9/we/UjuwkN4Ch/rhW1n1q+8cF6fF64HXea3u8xvd5nf7tLf7tLf7jK/3WV+u8v8dpf57S7z272wfuWF9SsvrF95aaLbRLeJbhPdLrpddLvodtHtottFt4tuF90uul10h+gO0R2iO0R3iO4Q3SG6Q3SH6A7RnaI7RXeK7hTdKbpTdKfoTtGdojtFN0Q3RDdEN0Q3RDdEN0Q3RDdEl/Url/ntXlm/8sr6lVfWr7yy3u6V9XaX/naX/naX/naX/naX/naX/naX/navrF95Zb3dK+vtXllv91pEt4huYfzK/HaX+e1e2c/gMr/dZX67y/x2l/52l/52l/ntLvPbXea3u8xvd5nf7jK/3WV+u8v8dpf57S7z213mt7vMb3eZ3+4yv91lfrtLf7vL/HaX+e0u89td5re7zG93md/uMr/dZX67y/x2l/ntLvPbXea3u8xvd5nf7jK/3aW/3WV+u8v8dpf57S7z213mt7vMb3eZ3+4yv91lfrvL/HaX+e0u89td5re7zG93md/u0t/uMr/dZX67y/x2l/ntLvPbXea3u8xvd5nf7jK/3WV+u8v8dpf57S7z213mt7vMb3fpb3eZ3+4yv91lfrvL/HaX+e0u89td5re7zG93md/uMr/dZX67y/x2l/ntLvPbXea3u/S3u8xvd5nf7jK/3WV+u8v8dpf57S7z213mt7vMb3eZ3+4yv91lfrvL/HaX+e0u89td+ttd5re7zG93md/uMr/dZX67y/x2l/ntLvPbXea3u8xvd5nf7jK/3WV+u8v8dpf57S797S7z213mt7vMb3eZ3+4yv91lfrvL/HaX+e0u89td5re7zG93md/uMr/dZX67y/x2l/52l/ntLvPbXea3u8xvd5nf7jK/3WV+u8v8dpf57S7z213mt7vMb3eZ3+4yv91lfrtLf7vL/HaX+e0u89td5re7zG93md/uMr/dZX67y/x2l/ntLvPbXea3u8xvd5nf7jK/3aW/3WV+u8v8dpf57S7z213mt7vMb3eZ3+4yv91lfrvL/HaX+e0u89td5re7zG93md/u0t/uMr/dZX67y/x2l/ntLvPbXea3u8xvd5nf7jK/3WV+u8v8dpf57S7z213mt7vMb3fpb3eZ3+4yv91lfrvL/HaX+e0u89td5re7zG93md/uMr/dZX67y/x2l/ntLvPbXea3u/S3u8xvd5nf7jK/3WV+u8v8dpf57S7z213mt7vMb3eZ3+4yv91lfrvL/HaX+e0u89td+ttd5re7zG93md/uMr/dZX67y/x2l/ntLvPbXea3u8xvd5nf7jK/3WV+u8v8dpf57S797S7z213mt7vMb3eZ3+4yv91lfrvL/HaX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8a8u/hXnt+dFD1704MW/4vz25Pz25Pz2vPhXFz148a8u/hXntyfnt+fFv7r4Vxf/ivPb86IHL3rw4l9xfntyfntyfnte/KuLHrz4Vxf/ivPbk/Pb8+JfXfyri3/F+e150YMXPXjxrzi/PTm/PTm/PS/+1UUPXvyri3/F+e3J+e158a8u/tXFv+L89rzowYsevPhXnN+enN+enN+eF//qogcv/tXFv+L89uT89rz4Vxf/6uJfcX570t+e9Lcn/e1Jf3vS3570t+fFv7rowYt/dfGvOL89Ob89L/7Vxb+6+Fec3570tyf97Ul/e9LfnvS3J/3tGfhXgR4M/KvAv+L89uT89gz8q8C/Cvwrzm9P+tuT/vakvz3pb0/625P+9gz8q0APBv5V4F9xfntyfntyfntyfnv++tvj73Pxufk87+cvXz2fF5//zXllvPODGe/8YMY7P5jxzg9mvPODGe/8YMY7P5jxzg9mvPODGZd1L+te1r2se1n3su5l3cu6wbrBusG6wbrBusG6wbrBusG6wbrJusm6ybrJusm6ybrJusm6ybrJusW6xbrFusW6xbrFusW6xbrFusW6zbrNus26zbrNus26zbrNus26zbrDusO6w7rDusO6w7rDusO6w7rvvHPmO++c+c47Z77zzpnvvHPmO++c+c47Z77zzpnvvHPmO++c+WHdxbqLdRfrLtZdrLtYd7HuYt3Fuot1N+tu1t2su1l3s+5m3c26m3U3627WPax7WBe+Svgq4auErxK+Svgq4auErxK+Svgq4auErxK+Svgq4auErxK+Svgq4auErxK+Svgq4auErxK+Svgq4auErxK+Svgq4auErxK+Svgq4auErxK+Svgq4auErxK+Svgq4auErxK+Svgq4auErxK+Svgq4auErxK+Svgq4auErxK+Svgq4auErxK+Svgq4auErxK+Svgq4auErwq+Kviq4KuCrwq+Kviq4KuCr7797f/NaOe3v/35/OWr5/Pi8+bz4fPlc/A5+Vx8Zt133jnrnXfOeueds95556x33jnrnXfOeueds95556x33jnrnXfO2qx7WPew7mHdw7qHdQ/rHtY9rHtY97DuZd3Lupd1L+te1r2se1n3su5l3cu6wbrBusG6wbrBusG6wbrBusG6wbrJusm6ybrJusm6ybrJusm6ybrJusW6xbrFusW6xbrF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PjbxsYmPTXxs4mMTH5v42MTHJj428bGJj018bOJjEx+b+NjExyY+NvGxiY9NfGziYxMfm/jYxMcmPjbxsYmPTXxs4mMTH5v42MTHJj428bGJj018bOJjEx+b+NjExyY+NvGxiY9NfGziYxMfm/jYxMcmPjbxsYmPTXxs4mMTH5v42MTHJj428bGJj018bOJjEx+b+NjExyY+NvGxiY9NfGziYxMfm/jYxMcmPjbxsYmPTXxs4mMTH5v42MTHJj428bGJj018bOJjEx+b+NjEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk08NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTr028NvHaxGsTdSyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW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ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LBU2UcdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjuV/CybQsfxvsf5njgsnsIk6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGU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rWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tY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TVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEYxOPTTw28djEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw2Ucfy6FgeHcujY3l0LI+O5dGxPDqWR8eyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpb/LZzAJupYVseyOpbVsayOZXUsq2NZHcvqWFbHsjqW1bGsjmV1LKtjWR3L6lhWx7I6ltWxrI5ldSyrY1kdy+pYVseyOpbVsayOZXUsq2NZHcvq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HB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcv5cyzzLt4Jzrv4b4L8Ptb+k/GfPP6T9Z8c/8nln3xNfP/J28S/f+IEjxM8TvA4weMEjxM8TvA4wTrBOsE6wTrBOsE6wTrBOsE6wTrBcYLjBMcJjhMcJzhOcJzgOMFxguME1wmuE1wnuE5wneA6wXWC6wTXCS4T/DmW8y7Cf5L+k/KftP9k/CeP/2T9J8d/4gThBOEE4QThBOEE4QThBOEE4QThBOkE6QTpBOkE6QTpBOkE6QTpBOkE5QTlBOUE5QTlBOUE5QTlBOUE5QTtBO0E7QTtBO0E7QTt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2ya2TWyb2DaxbWLbxLaJbRPbJrZNbJvYNrFtYtvEtoltE9smtk1sm9g2sW1i28S2iW0T2yaOTRybODZxbOLYxLGJYxPHJo5NHJs4NnFs4tjEsYljE8cmjk0cmzg2cWzi2MSxiWMTxyaOTRybODZxbOLYxLGJYxPHJo5NHJs4NnFs4tjEsYljE8cmjk0cmzg2cWzi2MSxiWMTxyaOTRybODZxbKKO5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epY7udY8v0nbxOr3sV/E9R9F/9N0L930S7GxX8T9Pej1x9w/NjlY28Tv4+9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",
    "file_map": {
        "5": {
            "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n}\n",
            "path": "std/cmp.nr"
        },
        "6": {
            "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n",
            "path": "std/collections/bounded_vec.nr"
        },
        "17": {
            "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
            "path": "std/field/bn254.nr"
        },
        "18": {
            "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
            "path": "std/field/mod.nr"
        },
        "22": {
            "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\n/// Asserts the validity of the provided proof and public inputs against the provided verification key and hash.\n///\n/// The ACVM cannot determine whether the provided proof is valid during execution as this requires knowledge of\n/// the backend against which the program is being proven. However if an invalid proof if submitted, the program may\n/// fail to prove or the backend may generate a proof which will subsequently fail to verify.\n///\n/// # Important Note\n///\n/// If you are not developing your own backend such as [Barretenberg](https://github.com/AztecProtocol/barretenberg)\n/// you probably shouldn't need to interact with this function directly. It's easier and safer to use a verification\n/// library which is published by the developers of the backend which will document or enforce any safety requirements.\n///\n/// If you use this directly, you're liable to introduce underconstrainedness bugs and *your circuit will be insecure*.\n///\n/// # Arguments\n/// - verification_key: The verification key of the circuit to be verified.\n/// - proof: The proof to be verified.\n/// - public_inputs: The public inputs associated with `proof`\n/// - key_hash: The hash of `verification_key` of the form expected by the backend.\n/// - proof_type: An identifier for the proving scheme used to generate the proof to be verified. This allows\n///               for a single backend to support verifying multiple proving schemes.\n///\n/// # Constraining `key_hash`\n///\n/// The Noir compiler does not by itself constrain that `key_hash` is a valid hash of `verification_key`.\n/// This is because different backends may differ in how they hash their verification keys.\n/// It is then the responsibility of either the noir developer (by explicitly hashing the verification key\n/// in the correct manner) or by the proving system itself internally asserting the correctness of `key_hash`.\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n",
            "path": "std/lib.nr"
        },
        "50": {
            "source": "mod zk_jwt;\nmod tests;\n\nuse zk_jwt::{\n    extra_zeros_removal::{remove_extra_zeros_from_partial_data},\n    utils::{decimal_string_to_field, get_domain_start_index_in_email},\n    nullifier_generator::{\n        generate_nullifier_with_poseidon2,\n        generate_nullifier_with_pedersen,\n    },\n};\n\nuse jwt::JWT;\n\nuse poseidon::poseidon2;                 // @dev - For v1.0.0-beta.11 of Noir/Nargo, we need to use this module for Poseidon hash\n//use std::hash::poseidon2::Poseidon2;   // @dev - For v1.0.0-beta.6 of Noir/Nargo, we are still able to use this module for Poseidon hash\n\nglobal MAX_PARTIAL_DATA_LENGTH: u32 = 640; // signed data length after partial SHA\nglobal MAX_DOMAIN_LENGTH: u32 = 64;\nglobal MAX_EMAIL_LENGTH: u32 = 128;\nglobal NONCE_LENGTH: u32 = 77;\n\n/**\n * @brief Verify JWT signature (RSA/SHA256 only) and validate hd and nonce fields\n *\n * @param partial_data: OIDC JWT (id_token) base64 data (`$header.$payload`) as byte array of ascii characters\n *                      We do partial SHA on the data up to hd field outside of the circuit, to reduce constraints\n *                      This field only contains the bytes after partial SHA; padded to MAX_PARTIAL_DATA_LENGTH\n * @param partial_hash: The 256-bit partial hash of the `data`\n * @param full_data_length: The full length of the `data` (before partial SHA)\n * @param b64_offset: Offset needed in `partial_data` to make the payloadB64 a multiple of 4\n *                    Signed data is $header.$payload. $payload might not be a multiple of 4 in `partial_data`, so we need to offset\n *                    Not attack-able by giving an incorrect offset, as string match of hd and nonce will fail\n * @param jwt_pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n * @param jwt_pubkey_redc_params_limbs: RSA reduction parameters limbs\n * @param jwt_signature_limbs: RSA signature limbs\n * @param domain: Domain name (`hd` key) as a byte array of ascii characters padded to MAX_DOMAIN_LENGTH\n * @param ephemeral_pubkey: Public key of the ephemeral keypair that is used to sign messages\n * @param ephemeral_pubkey_salt: Salt of the ephemeral keypair that is used to sign messages\n * @param ephemeral_pubkey_expiry: Expiry of the ephemeral keypair that is used to sign messages\n * @param nonce: JWT `nonce` as a byte array of ascii characters - 32 bytes\n **/\nfn main(\n    partial_data: BoundedVec<u8, MAX_PARTIAL_DATA_LENGTH>,\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    jwt_pubkey_modulus_limbs: [u128; 18],\n    jwt_pubkey_redc_params_limbs: [u128; 18],\n    jwt_signature_limbs: [u128; 18],\n    domain: pub BoundedVec<u8, MAX_DOMAIN_LENGTH>\n    //ephemeral_pubkey: pub Field,\n    //ephemeral_pubkey_salt: Field,\n    //ephemeral_pubkey_expiry: pub u32,\n) -> pub Field {\n    // @dev - Remove extra zeros, which are added to an original \"partial_data\" when it is inputted from the frontend, from an original \"partial_data\"\n    let _partial_data: BoundedVec<u8, MAX_PARTIAL_DATA_LENGTH> = unsafe { remove_extra_zeros_from_partial_data(partial_data) };\n    println(f\"_partial_data: {_partial_data}\\n\");\n\n    // Init JWT struct and verify signature\n    let jwt = JWT::init_with_partial_hash(\n        //partial_data,\n        _partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        jwt_pubkey_modulus_limbs,\n        jwt_pubkey_redc_params_limbs,\n        jwt_signature_limbs,\n    );\n    jwt.verify();\n\n    // // Get nonce claim\n    // let nonce: BoundedVec<u8, NONCE_LENGTH> = jwt.get_claim_string(\"nonce\".as_bytes());\n    // let nonce_field: Field = decimal_string_to_field(nonce.storage());\n\n    // // Verify nonce is the hash(ephemeral_pubkey, ephemeral_pubkey_salt, ephemeral_pubkey_expiry)\n    // let ephemeral_pubkey_hash = Poseidon2::hash(\n    //     [ephemeral_pubkey, ephemeral_pubkey_salt, ephemeral_pubkey_expiry as Field],\n    //     3,\n    // );\n\n    // assert(nonce_field == ephemeral_pubkey_hash, \"invalid nonce\");\n\n    // Assert email_verified claim\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n\n    // Get email claim\n    let email: BoundedVec<u8, MAX_EMAIL_LENGTH> = jwt.get_claim_string(\"email\".as_bytes());\n\n    // Get domain start_index from email claim - unconstrained, but we verify the domain bytes below\n    let domain_start_index = unsafe { get_domain_start_index_in_email(email) };\n\n    // Verify domain passed is present in the email claim after the @\n    assert(email.storage()[domain_start_index - 1] == 64, \"char before domain is not '@'\");\n    for i in 0..MAX_DOMAIN_LENGTH {\n        assert(email.storage()[domain_start_index + i] == domain.storage()[i], \"invalid domain\");\n    }\n\n    // @dev - Calculate a nullifier\n    let nullifier = generate_nullifier_with_poseidon2([full_data_length as Field, base64_decode_offset as Field]);\n    //let nullifier = generate_nullifier_with_pedersen([full_data_length as Field, base64_decode_offset as Field]);\n    //let nullifier = generate_nullifier([ephemeral_pubkey_hash, full_data_length as Field, base64_decode_offset as Field]);\n    //let nullifier: Field = 1; // [NOTE]: This is a test value\n\n    // @dev - Return the nullifier\n    nullifier\n}\n",
            "path": "/Users/unomasanori/Projects/actual-projects/OpenBands/Openbands-Miniapp/Openbands-Miniapp_ZK-circuit_and_contracts/circuits/src/main.nr"
        },
        "54": {
            "source": "use crate::{ MAX_PARTIAL_DATA_LENGTH };\n\n/**\n * @dev - Remove extra zeros, which are added to an original \"partial_data\" when it is inputted from the frontend, from an original \"partial_data\"\n */\nunconstrained pub fn remove_extra_zeros_from_partial_data(partial_data: BoundedVec<u8, MAX_PARTIAL_DATA_LENGTH>) -> BoundedVec<u8, MAX_PARTIAL_DATA_LENGTH> {\n    let mut start_index = 0;\n    let mut zero_start_index = 0;\n    let len = partial_data.len();\n    for i in 0..len {\n        if partial_data.storage()[i] == 0 {\n            zero_start_index = i;\n            start_index = i + 1;\n            break;\n        }\n    }\n\n    let mut new_vector: BoundedVec<u8, MAX_PARTIAL_DATA_LENGTH> = BoundedVec::new();\n    for c in 0..len {\n        if partial_data.storage()[c] > 0 {\n            new_vector.push(partial_data.storage()[c]);\n        } else if partial_data.storage()[c] == 0 {\n            break;\n        }\n    }\n    println(f\"new_vector (which is a recreated partial_data from an original partial_data): {new_vector}\\n\");\n\n    new_vector\n}\n\n\n\n// pub fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\n// where\n//     T: Empty + Eq,\n// {\n//     let mut len = 0;\n//     for elem in array {\n//         if !is_empty(elem) {\n//             len += 1;\n//         }\n//     }\n//     BoundedVec::from_parts_unchecked(array, len)\n// }\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty + Eq,\n// {\n//     item.eq(T::empty())\n// }\n\n// trait Empty {\n//     fn empty() -> Self;\n// }\n\n// impl Empty for u8 {\n//     fn empty() -> Self {\n//         0\n//     }\n// }",
            "path": "/Users/unomasanori/Projects/actual-projects/OpenBands/Openbands-Miniapp/Openbands-Miniapp_ZK-circuit_and_contracts/circuits/src/zk_jwt/extra_zeros_removal.nr"
        },
        "56": {
            "source": "use poseidon::poseidon2;                 // @dev - For the Noir/Nargo v1.0.0-beta.11, we need to use this module for Poseidon hash\n//use std::hash::poseidon2::Poseidon2;   // @dev - For the Noir/Nargo v1.0.0-beta.6, we are still able to use this module for Poseidon hash\nuse std::hash::pedersen_hash;\n\n/** \n * @notice - Calculate a nullifier using Poseidon2 hash\n */\npub fn generate_nullifier_with_poseidon2(inputs: [Field; 2]) -> Field {   // @dev - For the Noir/Nargo v1.0.0-beta.11\n//pub fn generate_nullifier_with_poseidon2(inputs: [Field; _]) -> Field { // @dev - For the Noir/Nargo v1.0.0-beta.6\n    // @dev - For the Noir/Nargo v1.0.0-beta.11\n    let nullifier_hash = poseidon2::Poseidon2::hash(\n        inputs,\n        inputs.len() as u32\n    );\n\n    // @dev - For the Noir/Nargo v1.0.0-beta.6\n    // let nullifier_hash = Poseidon2::hash(\n    //     inputs,\n    //     inputs.len() as u32\n    // );\n\n    nullifier_hash\n}\n\n/** \n * @notice - Calculate a nullifier using Pedersen hash\n */\npub fn generate_nullifier_with_pedersen(inputs: [Field; 2]) -> Field {   // @dev - For the Noir/Nargo v1.0.0-beta.11\n//pub fn generate_nullifier_with_pedersen(inputs: [Field; _]) -> Field { // @dev - For the Noir/Nargo v1.0.0-beta.6\n    let nullifier_hash = pedersen_hash(\n        inputs\n    );\n    nullifier_hash\n}",
            "path": "/Users/unomasanori/Projects/actual-projects/OpenBands/Openbands-Miniapp/Openbands-Miniapp_ZK-circuit_and_contracts/circuits/src/zk_jwt/nullifier_generator.nr"
        },
        "57": {
            "source": "use crate::{MAX_EMAIL_LENGTH};\n\npub fn decimal_string_to_field<let LEN: u32>(decimal_bytes: [u8; LEN]) -> Field {\n    assert(LEN <= 77);\n\n    let mut field: Field = 0;\n    let mut multiplier: Field = 1;\n\n    for i in 0..LEN {\n        let ascii_char = decimal_bytes[LEN - i - 1];\n        if ascii_char >= 48 & ascii_char <= 57 {\n            let digit = ascii_char as Field - 48;\n            field += digit * multiplier;\n            multiplier *= 10;\n        }\n    }\n\n    field\n}\n\nunconstrained pub fn get_domain_start_index_in_email(email: BoundedVec<u8, MAX_EMAIL_LENGTH>) -> u32 {\n    let mut domain_start_index = 0;\n    for i in 0..MAX_EMAIL_LENGTH {\n        if email.storage()[i] == (\"@\".as_bytes())[0] {\n            domain_start_index = i + 1;\n            break;\n        }\n    }\n\n    domain_start_index\n}",
            "path": "/Users/unomasanori/Projects/actual-projects/OpenBands/Openbands-Miniapp/Openbands-Miniapp_ZK-circuit_and_contracts/circuits/src/zk_jwt/utils.nr"
        },
        "58": {
            "source": "mod partial_hash;\n\nuse base64::BASE64_URL_DECODER;\nuse bignum::{params::BigNumParams, RuntimeBigNum};\nuse nodash::str_to_u64;\nuse partial_hash::partial_sha256_var_end;\nuse rsa::rsa::verify_sha256_pkcs1v15;\nuse sha256::sha256_var;\nuse string_search::{StringBody, SubString};\n\n/**\n * @brief Struct representing a JWT. Use the init functions to create an instance\n *        Currently only supports RSA 2048/SHA256 signatures\n **/\npub struct JWT<let MAX_DATA_LENGTH: u32> {\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    pubkey_modulus_limbs: [u128; 18],\n    redc_params_limbs: [u128; 18],\n    signature_limbs: [u128; 18],\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    is_partial_hash: bool, // compile time variable used internally\n}\n\nimpl<let MAX_DATA_LENGTH: u32> JWT<MAX_DATA_LENGTH> {\n    /**\n    * @brief Initialize JWT struct\n    *\n    * @param data: Signed JWT data (base64 encoded `$header.$payload`) as byte array of ascii characters\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Any 4x multiple from the payload start index.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs (2048-bit split into 18 limbs)\n    * @param signature_limbs: RSA signature limbs (2048-bit split into 18 limbs)\n    **/\n    pub fn init(\n        data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(data.len() <= MAX_DATA_LENGTH, \"data length is too long\");\n\n        JWT {\n            data,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            // below fields are not relevant unless for partial hash\n            full_data_length: MAX_DATA_LENGTH,\n            partial_hash: [0; 8],\n            is_partial_hash: false,\n        }\n    }\n\n    /**\n    * @brief Initialize JWT with partial SHA256 hash'ed input\n    *        Since SHA hash is expensive to compute in circuit, we can optimize by pre-hashing up to a certain block outside the circuit,\n    *        and verify for correctness in the circuit. This is possible since SHA works in incremental blocks.\n    *        You can pre-hash up to the SHA-256 block from where you want to extract a claim.\n    *\n    * @param partial_data: Signed JWT data (base64 encoded `$header.$payload`) after partial hashed block\n    * @param partial_hash: The 256-bit partial hash of the `partial_data` up to a certain block\n    * @param full_data_length: The full length of the `data` (before partial SHA)\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Trimming `offset` nubmer of bytes from the data should it base64 decode-able.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs\n    * @param signature_limbs: RSA signature limbs\n    **/\n    pub fn init_with_partial_hash(\n        partial_data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        partial_hash: [u32; 8],\n        full_data_length: u32,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(partial_data.len() <= MAX_DATA_LENGTH, \"partial_data length is too long\");\n\n        JWT {\n            data: partial_data,\n            full_data_length,\n            partial_hash,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            is_partial_hash: true,\n        }\n    }\n\n    /**\n    * @brief Verify JWT signature with RSA 2048/SHA256\n    **/\n    pub fn verify(mut self) {\n        let mut data_hash: [u8; 32] = [0; 32];\n\n        if (!self.is_partial_hash) {\n            // this is a compile time conditional\n            // Hash the data using SHA256\n            data_hash = sha256_var(self.data.storage(), self.data.len() as u64);\n        } else {\n            // Compute the full SHA256 hash with the given partial hash\n            data_hash = partial_sha256_var_end(\n                self.partial_hash,\n                self.data.storage(),\n                self.data.len() as u64,\n                self.full_data_length as u64,\n            );\n        }\n\n        // Verify RSA signature\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(false, self.pubkey_modulus_limbs, self.redc_params_limbs);\n\n        let signature = RuntimeBigNum { params, limbs: self.signature_limbs };\n\n        assert(verify_sha256_pkcs1v15(data_hash, signature, 65537));\n    }\n\n    /**\n    * @brief Get a string claim from the JWT payload\n    *\n    * @param KEY_LENGTH: The length of the claim key\n    * @param MAX_VALUE_LENGTH: The maximum length of the claim value\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        self.get_claim::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key, true)\n    }\n\n    /**\n    * @brief Assert a string claim in the JWT payload.\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: BoundedVec<u8, MAX_VALUE_LENGTH>,\n    ) {\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> =\n            self.get_claim_string::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a number (u64) claim from the JWT payload\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_number<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> u64 {\n        let claim = self.get_claim::<KEY_LENGTH, 20>(claim_key, false);\n        str_to_u64(claim.storage())\n    }\n\n    /**\n    * @brief Assert a number (u64) claim in the JWT payload.\n    *        Refer to `get_claim_number` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_number<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: u64,\n    ) {\n        let value = self.get_claim_number::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a boolean claim from the JWT payload\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_bool<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> bool {\n        let value = self.get_claim::<KEY_LENGTH, 5>(claim_key, false);\n        let mut is_true = true;\n        for i in 0..4 {\n            is_true = is_true & (value.storage()[i] == \"true\".as_bytes()[i]);\n        }\n        let is_false = value.storage() == \"false\".as_bytes();\n\n        assert(is_true | is_false, \"incorrect value for claim\");\n        is_true\n    }\n\n    /**\n    * @brief Assert a boolean claim in the JWT payload.\n    *        Refer to `get_claim_bool` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_bool<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: bool,\n    ) {\n        let value = self.get_claim_bool::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Internal function to get claim bytes from the JWT payload\n    **/\n    fn get_claim<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        //Safety: extract the value in unconstrained mode, and verify later\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> = unsafe {\n            self.extract_claim_unconstrained::<KEY_LENGTH, MAX_VALUE_LENGTH>(\n                claim_key,\n                is_value_quoted,\n            )\n        };\n\n        // constrain the extracted value is present in the payload using string_search lib\n        // haystack is the base64 decoded payload;\n        let haystack = self.prepare_haystack();\n\n        // needle is the key with quotes around it - searching for just the key string might return false positives from elsewhere\n        // Note: key length is known at compile time as this lib doesn't support runtime keys\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = claim_key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle\n            : SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // assert value after quoted key is a colon\n        let colon_index = position + KEY_LENGTH + 2; // +2 for the quotes around the key\n        assert(haystack.body[colon_index] == 58); // :\n\n        // assert the value is correct - string have quotes around them, numbers and booleans don't\n        let mut value_start_index = colon_index + 1; // Value starts after the colon\n        let mut index_after_value = value_start_index + value.len(); // Index after the value, quoted or otherwise\n\n        if (is_value_quoted) {\n            // adjust start index for the quotes around the value\n            value_start_index = value_start_index + 1; // Adjust for the quote before the value\n            index_after_value = index_after_value + 2; // Adjust for the quotes around the value\n\n            // assert the char before and after the value is a quote\n            assert(haystack.body[value_start_index - 1] == 34); // \"\n            assert(haystack.body[index_after_value - 1] == 34); // \"\n        }\n\n        // assert the value is correct\n        for i in 0..MAX_VALUE_LENGTH {\n            if (i < value.len()) {\n                assert(haystack.body[value_start_index + i] == value.storage()[i]);\n            }\n        }\n\n        // assert the char after the value is a comma or a closing brace (last claim in the payload)\n        let char_after_value = haystack.body[index_after_value];\n        assert((char_after_value == 44) | (char_after_value == 125)); // , or }\n\n        value\n    }\n\n    /**\n    * @brief Internal function to prepare the haystack for string search (base64 decoded payload with offset applied)\n    **/\n    fn prepare_haystack(\n        self,\n    ) -> StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> {\n        // We need to decode the payload from the payload_b64_offset; i.e. data.slice(0, base64_decode_offset)\n        let mut data_to_b64_decode: [u8; MAX_DATA_LENGTH] = [0; MAX_DATA_LENGTH];\n\n        // Conditional inside the for loop blows up the constraint size\n        // So we fill the full MAX_DATA_LENGTH (rotate on overflow) and prepare a BoundedVec with the correct length later\n        for i in 0..MAX_DATA_LENGTH {\n            data_to_b64_decode[i] =\n                self.data.storage()[(i + self.base64_decode_offset) % self.data.len()];\n        }\n\n        let data_to_decode_bv: BoundedVec<u8, MAX_DATA_LENGTH> = BoundedVec::from_parts(\n            data_to_b64_decode,\n            self.data.len() - self.base64_decode_offset,\n        );\n\n        // Decode the payload\n        let payload: BoundedVec<u8, ((MAX_DATA_LENGTH / 4) * 3)> =\n            BASE64_URL_DECODER::decode_var(data_to_decode_bv); // b64 decoded length is ceil(MAX_DATA_LENGTH / 3) * 4\n\n        // Create the haystack\n        let haystack: StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> =\n            StringBody::new(payload.storage(), payload.len());\n\n        haystack\n    }\n\n    /**\n    * @brief Unconstrained function to extract claim bytes from the JWT payload\n    **/\n    pub unconstrained fn extract_claim_unconstrained<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        let haystack = self.prepare_haystack();\n\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle\n            : SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // Get the value after the key\n        let mut value_start_idx = position + key.len() + 3; // +3 for the quote around the key and the colon\n        if (is_value_quoted) {\n            value_start_idx += 1; // +1 for the quote before the value\n        }\n\n        let mut value: BoundedVec<u8, MAX_VALUE_LENGTH> = BoundedVec::new();\n\n        for i in 0..MAX_VALUE_LENGTH {\n            let val = haystack.body[value_start_idx + i];\n            if ((val == 34) | (val == 44) | (val == 125)) {\n                break;\n            }\n            value.push(haystack.body[value_start_idx + i]);\n        }\n\n        value\n    }\n}\n\n#[test]\nfn test_verify() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_verify_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_get_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_get_claim_string_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_assert_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let value: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    jwt.assert_claim_string(\"email\".as_bytes(), value);\n}\n\n#[test]\nfn test_get_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let iat: u64 = jwt.get_claim_number(\"iat\".as_bytes());\n    let expected_iat: u64 = 1737642217;\n    assert(iat == expected_iat);\n}\n\n#[test]\nfn test_assert_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let expected_iat: u64 = 1737642217;\n    jwt.assert_claim_number(\"iat\".as_bytes(), expected_iat);\n}\n\n#[test]\nfn test_get_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email_verified: bool = jwt.get_claim_bool(\"email_verified\".as_bytes());\n    assert(email_verified);\n}\n\n#[test]\nfn test_assert_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n}\n\n#[test]\nfn test_get_last_claim() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let exp: u64 = jwt.get_claim_number(\"exp\".as_bytes()); // exp is the last claim in the test payload\n    let expected_exp: u64 = 1799999999;\n    assert(exp == expected_exp);\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/zkemail/noir-jwt/saleel/deps-update-beta11/src/lib.nr"
        },
        "59": {
            "source": "// Copied form https://raw.githubusercontent.com/zkemail/zkemail.nr/refs/heads/main/lib/src/partial_hash.nr\n// Use dependency one zkemail.nr is updated to bignum 0.6.0\n\nuse std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L23\n// Convert 64-byte array to array of 16 u32s\npub fn msg_u8_to_u32(msg: [u8; BLOCK_SIZE]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4 * (i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L38\nunconstrained fn build_msg_block_iter<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> ([u8; BLOCK_SIZE], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L59\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32,\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE: u32 = 64;\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L86-L116\n/**\n * Partially computes a SHA256 hash of a message but does not finalize\n * @notice can be used for post-partial hashing where client proves part of hash and relies on server to finish\n * \n *\n * @param N: the length of the message to hash.\n *  --- WARNING: N must be divisible by BLOCK_SIZE such that N % BLOCK_SIZE == 0 \n *      otherwise the remaining bytes will not be inputted when computing the initial hash\n * @param msg: the preimage to begin hashing\n * @return the intermediate hash state\n */\npub fn partial_sha256_var_start<let N: u32>(msg: [u8; N]) -> [u32; 8] {\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block_iter(msg, N, msg_start) };\n        if msg_start < N {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, N, msg_block, msg_start);\n            if msg_start < N {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < N {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < N) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    h\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block_iter(msg, N, msg_start) };\n        if msg_start < N {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, N, msg_block, msg_start);\n            if msg_start < N {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < N {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < N) & (msg_byte_ptr == BLOCK_SIZE) & (msg_start < message_size) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    h\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L85\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the remaining preimage\n * @param real_message_size -= the total size of the preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u64,\n    real_message_size: u64,\n) -> [u8; 32] {\n    let message_size = message_size as u32; // noir stdlib uses u64\n    let real_message_size = real_message_size as u32; // noir stdlib uses u64\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block_iter(msg, message_size, msg_start) };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block_iter(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !is_unconstrained() {\n        for i in 0..64 {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..64 {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, real_message_size) };\n\n    if !is_unconstrained() {\n        for i in 0..56 {\n            if i < msg_byte_ptr {\n                assert_eq(msg_block[i], last_block[i]);\n            } else {\n                assert_eq(msg_block[i], zero);\n            }\n        }\n\n        let len = 8 * real_message_size;\n        let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n        for i in 56..64 {\n            assert_eq(msg_block[i], len_bytes[i - 56]);\n        }\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; BLOCK_SIZE],\n    mut msg_byte_ptr: u32,\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: [u8; BLOCK_SIZE],\n    mut msg_byte_ptr: u32,\n    message_size: u32,\n) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4 * j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/zkemail/noir-jwt/saleel/deps-update-beta11/src/partial_hash.nr"
        },
        "61": {
            "source": "unconstrained fn __boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let mut r: [Field; Range] = [0; Range];\n    for i in limit..Range {\n        r[i] = 1;\n    }\n    r\n}\n\n/**\n * @brief Return a size-Range array of values that describe whether an index `i` is in the range `0<=i<limit`\n * @details When evaluating variable-length loops of size `limit`, it is neccessary to iterate over a maximum bound defined at compile-time\n *          Any constraints or evaluations that occur where `i >= limit` must be discarded.\n *          This is most efficiently performed by using predicate `Field` values, where `predicate[i] = 0` if `i < limit`, otherwise `predicate[i] = 1`.\n *          This method efficiently generates such predicate values more efficiently than querying whether `i <= limit` at every iteration.\n *          Gate cost is 3 * Range\n **/\npub fn boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    // Safety: r contains claims about whether `r[i] >= limit`. the rest of this function checks this claim is correct\n    let r = unsafe { __boundary_check(limit) };\n\n    let mut transition_index = 0;\n    // **\n    // We have an array of Field elements `r` such that:\n    // if i < limit, `r = 0`\n    // if i >= limit, `r = 1`\n    // We validate the predicate list `r` is correct by checking:\n    // 1. every r[i] element is 0 or 1\n    // 2. if r[i] = 1, r[i+1] must also be 1\n    // 3. if r[i] = 0 and r[i+1] = 1, then i == limit\n    // we check point 3 by tracking a `transition_index` variable, where\n    // transition_index += (1 - r[i]) * (r[i+1]) * i\n    // i.e. if r[i] == 0 and r[i+1] == 1, transition_index += i\n    //      else transition_index += 0\n    // NOTE: total constraint cost is 3 gates per iteration\n    // **\n    if Range > 0 {\n        for i in 0..Range - 1 {\n            assert_eq(r[i] * r[i], r[i]);\n            assert_eq(r[i] * r[i + 1], r[i]);\n            let idx = (r[i + 1] * (1 - r[i])) * (i as Field + 1);\n            transition_index = transition_index + idx;\n            std::as_witness(transition_index);\n        }\n        assert_eq(r[Range - 1] * r[Range - 1], r[Range - 1]);\n        transition_index = transition_index + (1 - r[Range - 1]) * limit as Field;\n        assert(transition_index == limit as Field);\n        r\n    } else {\n        [0; Range]\n    }\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/noir_base64/v0.4.2/src/boundary_check.nr"
        },
        "62": {
            "source": "use super::defaults::{\n    BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK, INVALID_DECODE_VALUE,\n};\n\npub use crate::boundary_check::boundary_check;\nuse crate::tables::{\n    BASE64_DECODE_BE_TABLE, BASE64_DECODE_BE_URL_TABLE, BASE64_DECODE_BE_URL_VAR_TABLE,\n    BASE64_DECODE_BE_VAR_TABLE,\n};\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\npub mod Base64DecodeBE {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 0>(input)\n    }\n}\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4), but WITHOUT padding\npub mod Base64DecodeBENoPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 0>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5\npub mod Base64DecodeBEUrlSafe {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 1>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5, but WITH padding added\npub mod Base64DecodeBEUrlSafeWithPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 1>(input)\n    }\n}\n\n/**\n * @brief Return a human-readable error if the input is invalid Base64\n * @details We constrain the decoding to be correct by using a lookup table to decode Base64.\n *          Validation is performed by batch-checking that no lookups returned an error state.\n *          This produces unhelpful error messages so we put this sanitised check in an unconstrained fn\n **/\nunconstrained fn __validate_decoded(decoded: Field, input_byte: u8, offset: u32) {\n    assert(\n        decoded != INVALID_DECODE_VALUE,\n        f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n    );\n}\n\n/**\n * @brief Given a variable-sized number of Base64 encoded characters, return a *claim* about how many are padding chars\n * @note The returned value is only a claim and must be validated\n **/\nunconstrained fn __get_num_padding_chars_var<let InputElements: u32>(\n    input: BoundedVec<u8, InputElements>,\n) -> (bool, bool) {\n    let len = input.len();\n    let r1 = if len > 1 {\n        input.get(len - 2) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    let r2 = if len > 0 {\n        input.get(len - 1) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    (r1, r2)\n}\n\n/**\n * @brief Take an array of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\nfn decode<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; OutputBytes] {\n    let rem = OutputBytes % 3;\n    // Calculate the number of padding characters and the length of the input without padding\n    let num_padding_chars = if rem == 1 {\n        2\n    } else if rem == 2 {\n        1\n    } else {\n        0\n    };\n\n    // Assert that the output length & input length are correct\n    // Every 3 output chars will be encoded as 4 base64 input chars\n    let encoded_length = (OutputBytes + 2) / 3 * 4; // ceil(input * 4 / 3)\n    if Pad != 0 {\n        assert(\n            encoded_length == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {encoded_length} input elements, but got {InputElements}.\",\n        );\n        // enforce Base64 padding is valid\n        if num_padding_chars == 2 {\n            let offset = InputElements - 1;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n            let offset = InputElements - 2;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        } else if num_padding_chars == 1 {\n            let offset = InputElements - 1;\n            assert(\n                input[InputElements - 1] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        }\n    } else {\n        let expected = encoded_length - num_padding_chars;\n        assert(\n            encoded_length - num_padding_chars == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {expected} input elements, but got {InputElements}.\",\n        );\n    }\n\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n    let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    // validity_check = accumulator value that we add every output from BASE64_DECODE_BE_TABLE into.\n    // Invalid error states will return a lookup value of -2^32 , which will cause `validity_check` to fail a 32-bit range check.\n    // This batch-validation technique is more efficient than asserting every returned token is valid.\n    let mut validity_check: Field = 0;\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte: u8 = input[offset];\n                let index = input_byte as u32;\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_TABLE[index]\n                } else {\n                    BASE64_DECODE_BE_TABLE[index]\n                };\n                validity_check += decoded;\n                slice += decoded as Field;\n                // Safety: get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                unsafe {\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        // process the final chunk, which may contain padding\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_elements_in_final_chunk = if Pad != 0 {\n            InputElements - base64_offset - num_padding_chars\n        } else {\n            InputElements - base64_offset\n        };\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte: u8 = input[offset];\n            let index = input_byte as u32;\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_TABLE[index]\n            } else {\n                BASE64_DECODE_BE_TABLE[index]\n            };\n            validity_check += decoded;\n            slice += decoded as Field;\n            // Safety: get a sensible error message out if the decoding is invalid.\n            // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n            // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n            // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n            // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n            unsafe {\n                __validate_decoded(decoded, input_byte, offset);\n            }\n        }\n\n        // If any lookups returned an error state, this 32-bit range check will fail.\n        validity_check.assert_max_bit_size::<32>();\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Take a variable-length vector of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\npub fn decode_var<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: BoundedVec<u8, InputElements>,\n) -> BoundedVec<u8, OutputBytes> {\n    // We don't know how many padding bytes the input string contains - we use an unconstrained fn to return a *claim* that we will later validate\n    let (has_first_padding_byte_claim, has_second_padding_byte_claim) = if (Pad == 1) {\n        // Safety: get claims about whether the bytes input[input.len() - 2] and input[input.len() - 1] are padding chars\n        // we validate this later on by requiring these characters equal BASE64_PADDING_CHAR by looking up BASE64_DECODE_BE_VAR_TABLE\n        unsafe {\n            crate::decoder::__get_num_padding_chars_var::<InputElements>(input)\n        }\n    } else {\n        (false, false)\n    };\n\n    // num_padding_chars is a claim that depends on has_first_padding_byte_claim and has_second_padding_byte_claim being correct\n    let num_padding_chars: u32 = if Pad == 1 {\n        has_first_padding_byte_claim as u32 + has_second_padding_byte_claim as u32\n    } else {\n        0\n    };\n\n    let input_length = input.len();\n    let input = input.storage();\n\n    // boundary_flags = array of Field elements.\n    // if `i < input_length, boundary_flags[i] = 0`\n    // if `i >= input_length, boundary_flags[i+1] = 1`\n    // used as cheap(ish) predicates when iterating over bounded vector elements\n    let boundary_flags: [Field; InputElements] = boundary_check(input_length);\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n\n    let max_num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    let mut validity_check: Field = 0;\n    // if statement should be known at compile time\n    if max_num_chunks > 0 {\n        let final_chunk: u32 = max_num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n\n                let mut decode_index: Field = 0;\n                if Pad == 1 {\n                    let mut might_be_second_padding_char = 0;\n                    let mut might_be_first_padding_char = 0;\n                    // These if statements should not cost extra gates as the condition is known at compile time\n                    if (offset + 2 < InputElements) {\n                        might_be_first_padding_char = (1 - boundary_flags[offset])\n                            * (1 - boundary_flags[offset + 1])\n                            * boundary_flags[offset + 2];\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else if (offset + 1 < InputElements) {\n                        // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                        might_be_first_padding_char =\n                            (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else // last character\n                    {\n                        might_be_first_padding_char = 0;\n                        might_be_second_padding_char = (1 - boundary_flags[offset]);\n                    }\n\n                    // Cases where we need to require a padding character is present:\n                    // Case 1: we are at byte position `input.len() - 2` and `has_first_padding_byte_claim = true`\n                    // Case 2: we are at byte position `input.len() - 1` and `has_second_padding_byte_claim = true`\n                    let require_padding = might_be_first_padding_char\n                        * has_first_padding_byte_claim as Field\n                        + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n\n                    // The `decode_index` is used to map the input Base64 character into an output decoded character.\n                    // We know `input_byte` is in the range 0-255 , so we use a size 768 lookup to handle the following 3 cases:\n                    // Case 1 (index range 0-255): No special cases. We decode the Base64 ASCII char into an ASCII char\n                    // Case 2 (index range 256-511): We have exceeded the length of the input. The only valid input is 0, which decodes to 0 (all other byte values return an error state)\n                    // Case 3 (index range 512-767): A claim has been made that a padding byte is present, and we are at the appropriate byte location to check this.\n                    //                               The only valid input is BASE64_PADDING_CHAR, which decodes to 0. All other inputs return an error state\n                    decode_index =\n                        input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n                } else {\n                    decode_index = input_byte as Field + boundary_flags[offset] * 256;\n                }\n                decode_index.assert_max_bit_size::<32>();\n                let decode_index = decode_index as u32;\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n                } else {\n                    BASE64_DECODE_BE_VAR_TABLE[decode_index]\n                };\n\n                validity_check += decoded;\n                slice += decoded;\n                // Safety: get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                unsafe {\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            // convert the decoded slice into bytes and populate result array\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n        // process the final chunk\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        // might include padding characters\n        let base64_elements_in_final_chunk = InputElements - base64_offset;\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n\n            let mut decode_index: Field = 0;\n            if Pad == 1 {\n                let mut might_be_second_padding_char = 0;\n                let mut might_be_first_padding_char = 0;\n                // These if statements should not cost extra gates as the condition is known at compile time\n                if (offset + 2 < InputElements) {\n                    might_be_first_padding_char = (1 - boundary_flags[offset])\n                        * (1 - boundary_flags[offset + 1])\n                        * boundary_flags[offset + 2];\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else if (offset + 1 < InputElements) {\n                    // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                    might_be_first_padding_char =\n                        (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else // last character\n                {\n                    might_be_first_padding_char = 0;\n                    might_be_second_padding_char = (1 - boundary_flags[offset]);\n                }\n\n                let require_padding = might_be_first_padding_char\n                    * has_first_padding_byte_claim as Field\n                    + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n                decode_index =\n                    input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n            } else {\n                decode_index = input_byte as Field + boundary_flags[offset] * 256;\n            }\n            decode_index.assert_max_bit_size::<32>();\n            let decode_index = decode_index as u32;\n\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n            } else {\n                BASE64_DECODE_BE_VAR_TABLE[decode_index]\n            };\n            // Safety: get a sensible error message out if the decoding is invalid.\n            // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n            // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n            // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n            // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n            unsafe {\n                __validate_decoded(decoded, input_byte, offset);\n            }\n            validity_check += decoded;\n            slice += decoded as Field;\n        }\n\n        validity_check.assert_max_bit_size::<32>();\n\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    if Pad == 1 {\n        assert(input_length % 4 == 0, \"base64 encoded strings must be a multiple of 4 bytes\");\n    }\n\n    if has_first_padding_byte_claim {\n        assert(has_second_padding_byte_claim, \"if first byte contains padding so must the second\");\n    }\n    let output_length = ((input_length * 3) / 4) - num_padding_chars;\n    BoundedVec::from_parts_unchecked(result, output_length)\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = Base64DecodeBE::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard_no_pad() {\n    // f\n    let input: [u8; 2] = [90, 103];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 3] = [90, 109, 56];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [95, 119]; // \"_w\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 2] = [255, 255];\n    let _: [u8; 1] = Base64DecodeBENoPad::decode(input);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_standard_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 95, offset 0\")]\nfn test_decode_underscore_with_standard() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let _: [u8; 2] = Base64DecodeBE::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe_with_pad() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafeWithPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 47, offset 0\")]\nfn test_decode_slash_with_url_safe() {\n    // test decoding / and +\n    let input: [u8; 3] = [47, 43, 65];\n    let _: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe() {\n    // test decoding _ and -\n    let input: [u8; 3] = [95, 45, 65];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_url_safe_no_pad_fail_with_padding() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // all configurations should decode the same way\n    let result: [u8; 12] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n\n    // all configurations should decode the same way\n    let result: [u8; 27] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let input: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result: [u8; 44] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61,\n    ];\n\n    let result: [u8; 32] = Base64DecodeBE::decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_empty() {\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBE::decode_var(input);\n    println(f\"result {result}\");\n    println(f\"expected {expected}\");\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 8> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 6> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    // fo\n    println(f\"result {result}, expected {expected}\");\n\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n\n    assert(result == expected);\n\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 61, offset 3\")]\nfn test_decode_var_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([47, 43, 65, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([255, 224]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var() {\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let input: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let input_no_pad: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n    // \"Hello, World!\"\n    let expected: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n\n    // all configurations should decode the same way\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    println(f\"result {result}, expected {expected}\");\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_multi_chunks() {\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/noir_base64/v0.4.2/src/decoder.nr"
        },
        "101": {
            "source": "use crate::constants::TWO_POW_120;\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\nuse std::cmp::Ordering;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n * gt \n * check_gt_with_flags\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> Field {\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0] as Field\n    } else if N == 2 {\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n        (limbs[0] + limbs[1] * TWO_POW_120) as Field\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        (\n            limbs[0] as Field\n                + limbs[1] as Field * TWO_POW_120 as Field\n                + limbs[2] as Field * TWO_POW_120 as Field * TWO_POW_120 as Field\n        )\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    field: Field,\n) -> [u128; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result: [u128; N] = unsafe { __from_field::<N>(field) };\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n        let mut grumpkin_modulus = [0; N];\n        if N > 2 {\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n        }\n        if MOD_BITS > 253 {\n            // this means that the field modulus is larger than grumpkin modulus so we have to check if the element fields in the field size are less than the grumpkin modulus.\n            // also for correct params N is always larger than 3 here\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n        } else if MOD_BITS < 253 {\n            // this means that the field modulus is smaller than grumpkin modulus so we have to check if the element fields in the field size\n            validate_in_field(_params, result);\n        } else {\n            // this is the tricky part, when MOD_BITS = 253, so we have to compare the limbs of the modulus to the grumpkin modulus limbs\n            // any bignum with 253 bits will have 3 limbs\n\n            // if modulus is larger than grumpkin modulus, this will be true\n            let mut gt_grumpkin = false;\n            for i in 0..3 {\n                if !gt_grumpkin {\n                    if _params.modulus[2 - i] < grumpkin_modulus[2 - i] {\n                        gt_grumpkin = true;\n                    }\n                }\n            }\n            let result_2 = if gt_grumpkin {\n                _params.modulus\n            } else {\n                grumpkin_modulus\n            };\n            validate_gt::<N, MOD_BITS>(result_2, result);\n        }\n\n        // validate the limbs sum up to the field value\n        let TWO_POW_120_FIELD = TWO_POW_120 as Field;\n        let field_val = if N < 2 {\n            result[0] as Field\n        } else if N == 2 {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field + result[1] as Field * TWO_POW_120_FIELD\n        } else {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field\n                + result[1] as Field * TWO_POW_120_FIELD\n                + result[2] as Field * TWO_POW_120_FIELD * TWO_POW_120_FIELD\n        };\n        assert_eq(field_val, field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        poseidon::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[u128; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [u128; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        if num_bytes >= num_filled_bytes {\n            let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n            let mut num_remaining_limbs =\n                (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n            let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n            let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n                + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n            for j in 0..num_limbs_in_bigfield {\n                let mut limb: u128 = 0;\n                for _ in 0..15 {\n                    let need_more_bytes = (byte_ptr < num_bytes);\n                    let mut byte = hash_buffer[byte_ptr];\n                    limb *= (256 * need_more_bytes as u128 + (1 - need_more_bytes as u128));\n                    limb += byte as u128 * need_more_bytes as u128;\n                    byte_ptr += need_more_bytes as u32;\n                }\n                bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n            }\n            bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n        }\n    }\n\n    let mut bigfield_rhs_limbs: [u128; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, _, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [u128; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120 as Field;\n        r *= TWO_POW_120 as Field;\n        modulus_mod_n *= TWO_POW_120 as Field;\n        l += lhs[N - i - 1] as Field;\n        r += rhs[N - i - 1] as Field;\n        modulus_mod_n += params.modulus[N - i - 1] as Field;\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [u128; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [u128; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = (modulus[i] as Field - val[i] as Field);\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += (borrow_flags[0] as Field * TWO_POW_120 as Field);\n    for i in 1..N - 1 {\n        p_minus_self[i] +=\n            (borrow_flags[i] as Field * TWO_POW_120 as Field - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= (borrow_flags[N - 2] as Field);\n    validate_in_range::<_, _, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<T, let N: u32, let MOD_BITS: u32>(limbs: [T; N])\nwhere\n    T: Into<Field>,\n{\n    for i in 0..(N - 1) {\n        limbs[i].into().assert_max_bit_size::<120>();\n    }\n\n    limbs[N - 1].into().assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [u128; N]) {\n    for i in 0..(N) {\n        (limbs[i] as Field).assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    (limbs[N - 1] as Field).assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, _, MOD_BITS>(result);\n    assert(!underflow, \"BigNum::validate_gt check fails\");\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params.modulus, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params.modulus, val) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb = modulus[0] + (borrow_flags[0] as u128 * TWO_POW_120) - val[0] - result[0];\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] + (borrow_flags[i] as u128 * TWO_POW_120)\n                - val[i]\n                - result[i]\n                - borrow_flags[i - 1] as u128;\n            assert(result_limb == 0);\n        }\n        let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as u128;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            // __add_u128(params, lhs, rhs)\n            __add(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params.modulus, lhs, rhs) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [u128; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] as Field + rhs[0] as Field\n            - subtrahend[0] as Field\n            - result[0] as Field\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] as Field + rhs[i] as Field\n                - subtrahend[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120 as Field;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = lhs[N - 1] as Field + rhs[N - 1] as Field\n            - subtrahend[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params.modulus, lhs, rhs) };\n\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [u128; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n            + addend[0] as Field\n            + lhs[0] as Field\n            - rhs[0] as Field\n            - result[0] as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n                + addend[i] as Field\n                + lhs[i] as Field\n                - rhs[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = addend[N - 1] as Field + lhs[N - 1] as Field\n            - rhs[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n\n// a comparison function. returns true if lhs > rhs and false otherwise\npub(crate) fn cmp<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) -> Ordering {\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    // if underflow is true, swap lhs and rhs\n    let (lhs, rhs) = if underflow { (rhs, lhs) } else { (lhs, rhs) };\n\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n    if lhs == rhs {\n        Ordering::equal()\n    } else if underflow {\n        Ordering::less()\n    } else {\n        Ordering::greater()\n    }\n}\n\n// the constraining function for the results returned by __validate_gt_remainder. this is used in both comparisons and validate gt\npub(crate) fn check_gt_with_flags<let N: u32, let MOD_BITS: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    result: [u128; N],\n    borrow_flags: [bool; N],\n    carry_flags: [bool; N],\n) {\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] as Field - rhs[0] as Field + addend[0] - result[0] as Field\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120 as Field;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] as Field - rhs[i] as Field + addend[i] as Field\n            - result[i] as Field\n            - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] as Field - rhs[N - 1] as Field + addend[N - 1] as Field\n        - result[N - 1] as Field\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/constrained_ops.nr"
        },
        "102": {
            "source": "use crate::utils::split_bits;\n\nuse crate::constants::{TWO_POW_120, TWO_POW_126, TWO_POW_246};\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\n\nunconstrained fn compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N], [Field; 2 * N - 2]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n    assert(remainder == [0; N]);\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] as Field * params.modulus[j] as Field;\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N - 2] = [0; 2 * N - 2];\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{246 - 120} = 2^{126}\n    let downshift: Field = 1 / (TWO_POW_120 as Field);\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits =\n        (mulout_p[0] - mulout_n[0] + (borrow_flags[0] as Field * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n    flags: [bool; M],\n) -> ([u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [u128; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [u128; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + (modulus2[j] as Field - x[i][j] as Field) as u128;\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [u128; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] as Field * rhs[k][j] as Field);\n            }\n        }\n        mulout[i] += add[i] as Field;\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout: [Field; (N * 2)] = compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, k, params.modulus);\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([u128; N], [u128; N], [Field; 2 * N - 2]) = unsafe {\n        compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [u128; N] = params.double_modulus;\n\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i] as Field;\n                    t0[k][i] += double_modulus[i] as Field;\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i] as Field;\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i] as Field;\n                    t1[k][i] += double_modulus[i] as Field;\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i] as Field;\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i] as Field;\n                t4[i] += double_modulus[i] as Field;\n            } else {\n                t4[i] += linear_terms[j][i] as Field;\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term =\n                        t0[k][i] * t1[k][j] - quotient[i] as Field * params.modulus[j] as Field;\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j] as Field;\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] as Field * params.modulus[j] as Field;\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] as Field * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/expressions.nr"
        },
        "104": {
            "source": "use crate::utils::map::invert_array;\n/// conversions between big endian and little endian byte arrays and BigNum instances\n/// the byte serialization should have `(MOD_BITS + 7) / 8` bytes.\n/// each 120-bit limb is represented by 15 bytes, and there are fewer bytes for covering the most significant limb\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    let num_bits = (MOD_BITS + 7) / 8 * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result: [u128; N] = [0; N];\n\n    let excess_bytes = N * 15 - (MOD_BITS + 7) / 8;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    limb.assert_max_bit_size::<128>();\n    result[N - 1] = limb as u128;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        limb.assert_max_bit_size::<128>();\n        result[N - i - 1] = limb as u128;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - ((MOD_BITS + 7) / 8 * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_be_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let mut result: [u8; (MOD_BITS + 7) / 8] = [0; (MOD_BITS + 7) / 8];\n    // the last limb will not have all the 15 bytes so we deal with the full limbs first\n    for i in 0..N - 1 {\n        let index = N - i - 2;\n        let limb_bytes: [u8; 15] = (val[index] as Field).to_be_bytes();\n        for j in 0..15 {\n            // we leave the space for the first byte empty, which would take (MOD_BITS+7)/8 - MOD_BITS/8 bytes\n            result[i * 15 + j + (MOD_BITS + 7) / 8 - (N - 1) * 15] = limb_bytes[j];\n        }\n    }\n    // now we deal with the last limb\n    let last_limb_bytes: [u8; ((MOD_BITS + 7) / 8 - (N - 1) * 15)] =\n        (val[N - 1] as Field).to_be_bytes();\n\n    for i in 0..((MOD_BITS + 7) / 8 - (N - 1) * 15) {\n        result[i] = last_limb_bytes[i];\n    }\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let result_be: [u8; (MOD_BITS + 7) / 8] = to_be_bytes(val);\n    let result = invert_array(result_be);\n    result\n}\n\npub(crate) fn from_le_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    // make the bytes big endian\n    let be_x = invert_array(x);\n    from_be_bytes(be_x)\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/serialization.nr"
        },
        "105": {
            "source": "use crate::constants::{TWO_POW_119, TWO_POW_120};\nuse crate::fns::unconstrained_ops::{__add, __gte, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\nuse crate::utils::msb::get_msb;\nuse crate::utils::split_bits::__normalize_limbs;\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [u128; N] {\n    let mut x = field;\n    let x_first_u128 = (x as u128);\n    let first: u128 = x_first_u128 % TWO_POW_120;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_120 as Field);\n    let x_second_u128 = (x as u128);\n    let second = x_second_u128 % TWO_POW_120;\n    x = (x - (second as Field)) / (TWO_POW_120 as Field);\n    let x_third_u128 = (x as u128);\n    let third = x_third_u128 % TWO_POW_120;\n    let mut result: [u128; N] = [0; N];\n    if N > 2 {\n        result[0] = first;\n        result[1] = second;\n        result[2] = third;\n    }\n    if N == 2 {\n        result[0] = first;\n        result[1] = second;\n    }\n    if N == 1 {\n        result[0] = first;\n    }\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [u128; N] = params.modulus;\n    flags[0] = modulus[0] < val[0];\n    for i in 1..N - 1 {\n        flags[i] = modulus[i] < val[i] + flags[i - 1] as u128;\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> (bool, [u128; N], [bool; N], [bool; N]) {\n    let mut a = lhs;\n    let mut b = rhs;\n    let underflow = !__gte(lhs, rhs);\n\n    let mut result: [u128; N] = [0; N];\n    // swap a and b if there's an underflow\n    let (a, b) = if underflow { (b, a) } else { (a, b) };\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = a[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = b[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = (borrow * TWO_POW_120 + add_term - sub_term);\n\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (underflow, result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32>(\n    modulus: [u128; N],\n    val: [u128; N],\n) -> ([u128; N], [bool; N - 1]) {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow_in: u128 = 0;\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    for i in 0..N {\n        let sub_term = val[i] + borrow_in;\n        let borrow = (sub_term > modulus[i]) as u128;\n        result[i] = borrow * TWO_POW_120 + modulus[i] - sub_term;\n\n        borrow_in = borrow;\n        if (i < N - 1) {\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let add_res = __helper_add(lhs, rhs);\n    let overflow = __gte(add_res, modulus);\n\n    let mut subtrahend: [u128; N] = [0; N];\n    let mut result: [u128; N] = [0; N];\n\n    if overflow {\n        subtrahend = modulus;\n    }\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term = lhs[i] + rhs[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry as u128;\n\n        let sub_term = subtrahend[i] + borrow_in;\n\n        let mut borrow: u128 = (sub_term > add_term) as u128;\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow as u128;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let underflow = !__gte(lhs, rhs);\n    let addend: [u128; N] = if underflow { modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + addend[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = rhs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = borrow as u128 * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [u128; 2 * N],\n    redc_param: [u128; N],\n    k: u32,\n    modulus: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mulout_field: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout_field[i + j] += x[i] as Field * redc_param[j] as Field;\n        }\n    }\n\n    let mulout: [u128; 3 * N] = __normalize_limbs(mulout_field, 3 * N);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient = __shr(mulout, (k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n    // the quotient has bunch of zero limbs now, so we can just take the first N limbs as a result\n    let mut smaller_quotient = [0; N];\n    for i in 0..N {\n        smaller_quotient[i] = quotient[i] as u128;\n    }\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = __into_field_array(quotient);\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] +=\n                partial_quotient_full[i] * modulus[j] as Field;\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    let long_quotient_mul_modulus_normalized: [u128; 2 * N] =\n        __normalize_limbs(quotient_mul_modulus_normalized, 2 * N);\n    let mut quotient_mul_modulus_normalized: [u128; N] = [0; N];\n    for i in 0..N {\n        quotient_mul_modulus_normalized[i] = long_quotient_mul_modulus_normalized[i];\n    }\n\n    let mut long_remainder = __helper_sub(x, long_quotient_mul_modulus_normalized);\n    // ugly but have to remove a bunch of zeros from this\n    let mut remainder = [0; N];\n    for i in 0..N {\n        remainder[i] = long_remainder[i];\n    }\n    // barrett reduction is quirky so might need to remove a few modulus from the remainder\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n\n    (smaller_quotient, remainder)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let mut target = __helper_sub(params.modulus, one);\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target = __shr1(target);\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [u128; N],\n    p_minus_one_over_two: [u128; N],\n) -> (bool, [u128; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [u128; N] = __one();\n    let neg_one = __neg(params.modulus, one);\n    let found = exped == neg_one;\n    let mut result: (bool, [u128; N]) = (found, target);\n    if (!found) {\n        let _target: [u128; N] = __add(params.modulus, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [u128; N] {\n    let mut target: [u128; N] = __one();\n    let p_minus_one_over_two = __shr1(__helper_sub(params.modulus, __one()));\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [u128; N],\n    i: u32,\n) -> u32 {\n    let one: [u128; N] = __one();\n    let is_one = t2m == one;\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n\npub(crate) unconstrained fn __increment<let N: u32>(val: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 1;\n    for i in 0..N {\n        let mut add_term = (val[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u128;\n    let remainder_shift = (120 - limb_shift);\n    let mask: u128 = (((1 as u128) << limb_shift) - 1) << remainder_shift;\n    result[0] = (input[0 + num_shifted_limbs] >> (limb_shift));\n    for i in 1..(N - num_shifted_limbs) {\n        let value = input[i + num_shifted_limbs];\n        result[i] = value >> limb_shift;\n        let remainder: u128 = (value << remainder_shift) & mask;\n        result[i - 1] = result[i - 1] + remainder;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shl<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u128;\n    let remainder_shift = 120 - limb_shift;\n\n    // 83\n    // limb shift = 1\n    // inside shift = 19 bits to the left\n    // meaning we have 19 carry bits and 41 remainder bits\n    let mask: u128 = (1 as u128 << 120) - 1;\n    //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n    let value = input[0];\n\n    let mut remainder = (value >> remainder_shift);\n    result[num_shifted_limbs] = (value << limb_shift) & mask;\n\n    // shift 84. num shifted = 1\n    for i in 1..((N) - num_shifted_limbs) {\n        let value = input[i];\n        let upshift = ((value << limb_shift) + remainder) & mask;\n        result[i + num_shifted_limbs] = upshift;\n        remainder = (value >> remainder_shift);\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_sub<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    for i in 0..N {\n        borrow = ((rhs[i] + borrow_in) > lhs[i]) as u128;\n        let sub = (borrow << 120) + lhs[i] as u128 - rhs[i] as u128 - borrow_in;\n        result[i] = sub;\n        borrow_in = borrow;\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_add<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr1<let N: u32>(mut input: [u128; N]) -> [u128; N] {\n    let value = input[N - 1];\n    input[N - 1] = value >> 1;\n\n    let mut remainder = (value & 1) << 119;\n\n    for i in 1..N {\n        let value = input[N - 1 - i];\n        input[N - 1 - i] = (value >> 1) + remainder;\n        remainder = (value << 119) & TWO_POW_119;\n    }\n    input\n}\n\npub(crate) unconstrained fn __get_msb<let N: u32>(val: [u128; N]) -> u32 {\n    let mut count = 0;\n    for i in 0..N {\n        let v = val[(N - 1 - i)];\n        if (v > 0) {\n            count = 120 * (N - 1 - i) + get_msb(v);\n            break;\n        }\n    }\n    count\n}\n\npub(crate) fn __get_bit<let N: u32>(input: [u128; N], bit: u32) -> bool {\n    let segment_index: u32 = bit / 120;\n    let uint_index = (bit % 120) as u128;\n    let limb: u128 = input[segment_index];\n    let value = (limb >> uint_index) & 1;\n    value == 1\n}\n\npub(crate) fn __into_field_array<let N: u32>(input: [u128; N]) -> [Field; N] {\n    let mut result: [Field; N] = [0; N];\n    for i in 0..N {\n        result[i] = input[i] as Field;\n    }\n    result\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/unconstrained_helpers.nr"
        },
        "106": {
            "source": "use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __get_bit, __get_msb, __helper_add, __helper_sub, __increment,\n    __multiplicative_generator, __primitive_root_log_size, __shl, __shr,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse super::unconstrained_helpers::__shr1;\n\npub(crate) unconstrained fn __one<let N: u32>() -> [u128; N] {\n    let mut limbs: [u128; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [u128; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32>(modulus: [u128; N], limbs: [u128; N]) -> [u128; N] {\n    __helper_sub(modulus, limbs)\n}\n\npub(crate) unconstrained fn __add<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    // check if the result is greater than the modulus\n    if __gte(result, modulus) {\n        __helper_sub(result, modulus)\n    } else {\n        result\n    }\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __add(modulus, lhs, __neg(modulus, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += (lhs[i] as Field * rhs[j] as Field);\n        }\n    }\n    let to_reduce: [u128; (N * 2)] = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(to_reduce, params.redc_param, MOD_BITS, params.modulus);\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    let inv_divisor: [u128; N] = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut quotient: [u128; N] = [0; N];\n    let mut remainder: [u128; N] = numerator;\n\n    let b = divisor;\n    let numerator_msb = __get_msb(numerator);\n    let divisor_msb = __get_msb(divisor);\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = __get_msb(remainder) - __get_msb(divisor);\n        let mut accumulator: [u128; N] = __one();\n        let mut divisor = __shl(divisor, bit_difference);\n        accumulator = __shl(accumulator, bit_difference);\n\n        if (__gte(divisor, __increment(remainder))) {\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        for _ in 0..(N * 120) {\n            if (__gte(remainder, b) == false) {\n                break;\n            }\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (__gte(remainder, divisor)) {\n                remainder = __helper_sub(remainder, divisor);\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient = __helper_add(quotient, accumulator);\n            }\n            divisor = __shr1(divisor); // >>= 1;\n            accumulator = __shr1(accumulator); //  >>= 1;\n        }\n\n        (quotient, remainder)\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    let one = __one();\n    let exp = __helper_sub(params.modulus, __helper_add(one, one));\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n    exponent: [u128; N],\n) -> [u128; N] {\n    let x = exponent;\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [u128; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if __get_bit(x, num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n) -> [[u128; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]; M] = std::mem::zeroed();\n\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]],\n) -> [[u128; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one = __one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let Q = __shr(\n        __helper_sub(params.modulus, one),\n        primitive_root_log_size - 1,\n    );\n    let two = __helper_add(one, one);\n    let Q_minus_one_over_two = __shr(__helper_sub(Q, two), 2);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [u128; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __gte<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    let mut result = false;\n    let mut early_exit = false;\n    for i in 0..(N) {\n        let idx = (N) - 1 - i;\n        if (rhs[idx] == lhs[idx]) {\n            continue;\n        }\n\n        result = rhs[idx] < lhs[idx];\n        early_exit = true;\n        break;\n    }\n    if early_exit {\n        result\n    } else {\n        lhs[0] == rhs[0]\n    }\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/unconstrained_ops.nr"
        },
        "108": {
            "source": "pub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [u128; N],\n\n    // @brief double_modulus: used when performing negations and subtractions\n    // @note we borrow 1 from the last limb. This is for easing up the operations that might underflow\n    pub double_modulus: [u128; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [u128; N],\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [u128; N],\n        redc_param: [u128; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [u128; N]) -> [u128; N] {\n    let TWO_POW_120: u128 = 0x1000000000000000000000000000000;\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (modulus[i] + modulus[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/params.nr"
        },
        "109": {
            "source": "use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, cmp, derive_from_seed, div, eq, is_zero, mul, neg, sub, udiv,\n        udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    serialization::{from_be_bytes, from_le_bytes, to_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __derive_from_seed, __div, __eq, __invmod, __is_zero, __mul, __neg, __pow, __sub,\n        __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::{cmp::Ordering, ops::Neg};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [u128; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {\n\n    pub fn zero(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [u128; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    pub fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::zero(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    pub fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [u128]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    pub fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [u128; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    pub fn from_be_bytes(params: BigNumParams<N, MOD_BITS>, x: [u8; (MOD_BITS + 7) / 8]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS>(x), params }\n    }\n\n    pub fn from_le_bytes(params: BigNumParams<N, MOD_BITS>, x: [u8; (MOD_BITS + 7) / 8]) -> Self {\n        Self { limbs: from_le_bytes::<_, MOD_BITS>(x), params }\n    }\n\n    pub fn to_be_bytes(self) -> [u8; (MOD_BITS + 7) / 8] {\n        to_be_bytes::<_, MOD_BITS>(self.limbs)\n    }\n\n    pub fn to_le_bytes(self) -> [u8; (MOD_BITS + 7) / 8] {\n        to_le_bytes::<_, MOD_BITS>(self.limbs)\n    }\n\n    pub fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    pub fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    pub fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    pub fn get_limbs(self) -> [u128; N] {\n        self.limbs\n    }\n\n    pub fn get_limb(self, idx: u32) -> u128 {\n        self.limbs[idx]\n    }\n\n    pub fn set_limb(&mut self, idx: u32, value: u128) {\n        self.limbs[idx] = value;\n    }\n\n    pub unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    pub unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params.modulus, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params.modulus, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params.modulus, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    pub fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    pub fn validate_in_range(self) {\n        validate_in_range::<_, _, MOD_BITS>(self.limbs);\n    }\n\n    pub fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    pub fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    pub fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Ord for RuntimeBigNum<N, MOD_BITS> {\n    fn cmp(self, other: Self) -> Ordering {\n        assert(self.params == other.params);\n        cmp::<_, MOD_BITS>(self.limbs, other.limbs)\n    }\n}\n\n// UNCONSTRAINED! (Hence `__` prefix).\npub fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[RuntimeBigNum<N, MOD_BITS>; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[RuntimeBigNum<N, MOD_BITS>; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [RuntimeBigNum<N, MOD_BITS>; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> (RuntimeBigNum<N, MOD_BITS>, RuntimeBigNum<N, MOD_BITS>) {\n    let (q_limbs, r_limbs) = unsafe {\n        crate::fns::expressions::compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| RuntimeBigNum::get_limbs(bn)),\n            linear_flags,\n        )\n    };\n    (RuntimeBigNum { limbs: q_limbs, params }, RuntimeBigNum { limbs: r_limbs, params })\n}\n\npub fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[RuntimeBigNum<N, MOD_BITS>; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[RuntimeBigNum<N, MOD_BITS>; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [RuntimeBigNum<N, MOD_BITS>; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    crate::fns::expressions::evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n        params,\n        map(lhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n        lhs_flags,\n        map(rhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n        rhs_flags,\n        map(linear_terms, |bn| RuntimeBigNum::get_limbs(bn)),\n        linear_flags,\n    )\n}\n\n// UNCONSTRAINED! (Hence `__` prefix).\npub fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    x: [RuntimeBigNum<N, MOD_BITS>; M],\n) -> [RuntimeBigNum<N, MOD_BITS>; M] {\n    let params = x[0].params;\n    assert(params.has_multiplicative_inverse);\n    let all_limbs = unsafe {\n        crate::fns::unconstrained_ops::batch_invert::<_, MOD_BITS, _>(\n            params,\n            x.map(|bn| RuntimeBigNum::get_limbs(bn)),\n        )\n    };\n    all_limbs.map(|limbs| RuntimeBigNum { limbs, params })\n}\n\npub unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32, let M: u32>(\n    x: [RuntimeBigNum<N, MOD_BITS>],\n) -> [RuntimeBigNum<N, MOD_BITS>] {\n    let params = x[0].params;\n    assert(params.has_multiplicative_inverse);\n    let all_limbs = crate::fns::unconstrained_ops::batch_invert_slice::<_, MOD_BITS>(\n        params,\n        x.map(|bn| RuntimeBigNum::get_limbs(bn)),\n    );\n\n    all_limbs.map(|limbs| RuntimeBigNum { limbs, params })\n}\n\npub fn conditional_select<let N: u32, let MOD_BITS: u32>(\n    lhs: RuntimeBigNum<N, MOD_BITS>,\n    rhs: RuntimeBigNum<N, MOD_BITS>,\n    predicate: bool,\n) -> RuntimeBigNum<N, MOD_BITS> {\n    let params = lhs.params;\n    assert(params == rhs.params);\n    let limbs = if predicate { lhs.limbs } else { rhs.limbs };\n    RuntimeBigNum { limbs: limbs, params }\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/runtime_bignum.nr"
        },
        "116": {
            "source": "use crate::constants::TWO_POW_120;\n\nunconstrained fn split_120_bits(mut x: Field) -> (u128, u128) {\n    // Here we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low = (x as u128) % TWO_POW_120;\n    let high = ((x - low as Field) / TWO_POW_120 as Field) as u128;\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [u128; N] {\n    let mut normalized: [u128; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n        normalized[i] = lo as u128;\n        next = input[i + 1] + hi as Field;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[range - 1] = lo as u128;\n        assert(hi == 0);\n    }\n    normalized\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/utils/split_bits.nr"
        },
        "123": {
            "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"
        },
        "148": {
            "source": "use dep::bignum::RuntimeBigNum;\nuse sha1::sha1;\nuse sha256;\nuse sha512::{sha384, sha512};\n\nglobal SHA1_HASH_LEN: u32 = 20;\nglobal SHA256_HASH_LEN: u32 = 32;\nglobal SHA384_HASH_LEN: u32 = 48;\nglobal SHA512_HASH_LEN: u32 = 64;\n\nfn reverse_array<let N: u32>(array: [u8; N]) -> [u8; N] {\n    let mut reversed = [0 as u8; N];\n    for i in 0..N {\n        reversed[i] = array[N - i - 1];\n    }\n    reversed\n}\n\nfn get_array_slice<let N: u32, let M: u32>(array: [u8; N], start: u32, end: u32) -> [u8; M] {\n    assert(end - start <= M);\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        if i < end - start {\n            slice[i] = array[start + i];\n        }\n    }\n    slice\n}\n\nfn pow(base: u32, exp: u32) -> u32 {\n    let mut result = 1;\n    for _ in 0..exp {\n        result *= base;\n    }\n    result\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA1 as the hash function\n **/\nfn mgf1_sha1<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA1_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA1_HASH_LEN as Field + 1);\n\n    // SHA1_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA1_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA1_HASH_LEN] = [0; SHA1_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block using SHA-1\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha1::sha1_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA1_HASH_LEN {\n            if i * SHA1_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA1_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA256 as the hash function\n **/\nfn mgf1_sha256<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA256_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA256_HASH_LEN as Field + 1);\n\n    // SHA256_HASH_LEN bytes are added at each iteration and there is at least 1 iteration\n    // so if SHA256_HASH_LEN is not enough to fill MASK_LEN bytes in one iteration,\n    // another one is required and so on.\n    let iterations = (MASK_LEN / SHA256_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA256_HASH_LEN] = [0; SHA256_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block\n        // First SEED_LEN bytes are the seed, next 4 bytes are the counter\n        hashed = sha256::sha256_var(block, SEED_LEN as u64 + 4);\n\n        // Copy hashed output to mask\n        for j in 0..SHA256_HASH_LEN {\n            if i * SHA256_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA256_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA384 as the hash function\n **/\nfn mgf1_sha384<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA384_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA384_HASH_LEN as Field + 1);\n\n    // SHA384_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA384_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA384_HASH_LEN] = [0; SHA384_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha384::sha384_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA384_HASH_LEN {\n            if i * SHA384_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA384_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA512 as the hash function\n **/\nfn mgf1_sha512<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA512_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA512_HASH_LEN as Field + 1);\n\n    // SHA512_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA512_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA512_HASH_LEN] = [0; SHA512_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha512::sha512_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA512_HASH_LEN {\n            if i * SHA512_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA512_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-1 to the original message hash\n **/\nfn compare_signature_sha1<let N: u32>(padded_sha1_hash: [u8; N], msg_hash: [u8; 20]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..20 {\n        // Padded hash is reversed\n        assert(padded_sha1_hash[19 - i] == msg_hash[i]);\n    }\n\n    // SHA-1 ASN.1 DER identifier\n    let hash_prefix: [u8; 15] = [20, 4, 0, 5, 26, 2, 3, 14, 43, 5, 6, 9, 48, 33, 48];\n\n    for i in 20..35 {\n        assert(hash_prefix[i - 20] == padded_sha1_hash[i]);\n    }\n\n    assert(padded_sha1_hash[35] == 0);\n\n    // Sub 20 bytes for hash, 15 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 38;\n    for i in 36..N {\n        if i < 36 + ps_len {\n            // PS padding\n            assert(padded_sha1_hash[i] == 255);\n        } else if i == 36 + ps_len {\n            // Pad 0x01\n            assert(padded_sha1_hash[i] == 1);\n        } else if i == 37 + ps_len {\n            // 0x00\n            assert(padded_sha1_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha1_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-384 to the original message hash\n **/\nfn compare_signature_sha384<let N: u32>(padded_sha384_hash: [u8; N], msg_hash: [u8; 48]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..48 {\n        // Padded hash is reversed\n        assert(padded_sha384_hash[47 - i] == msg_hash[i]);\n    }\n\n    // SHA-384 ASN.1 DER identifier\n    let hash_prefix: [u8; 19] =\n        [48, 4, 0, 5, 2, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 65, 48];\n\n    for i in 48..67 {\n        assert(hash_prefix[i - 48] == padded_sha384_hash[i]);\n    }\n\n    assert(padded_sha384_hash[67] == 0);\n\n    // Sub 48 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 70;\n    for i in 68..N {\n        if i as u32 < 68 + ps_len as u32 {\n            // PS padding\n            assert(padded_sha384_hash[i] == 255);\n        } else if i as u32 == 68 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha384_hash[i] == 1);\n        } else if i as u32 == 69 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha384_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha384_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-512 to the original message hash\n **/\nfn compare_signature_sha512<let N: u32>(padded_sha512_hash: [u8; N], msg_hash: [u8; 64]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..64 {\n        // Padded hash is reversed\n        assert(padded_sha512_hash[63 - i] == msg_hash[i]);\n    }\n\n    // SHA-512 ASN.1 DER identifier\n    let hash_prefix: [u8; 19] =\n        [64, 4, 0, 5, 3, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 81, 48];\n\n    for i in 64..83 {\n        assert(hash_prefix[i - 64] == padded_sha512_hash[i]);\n    }\n\n    assert(padded_sha512_hash[83] == 0);\n\n    // Sub 64 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 86;\n    for i in 84..N {\n        if i as u32 < 84 + ps_len as u32 {\n            // PS padding\n            assert(padded_sha512_hash[i] == 255);\n        } else if i as u32 == 84 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha512_hash[i] == 1);\n        } else if i as u32 == 85 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha512_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha512_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Exponentiate a signature by a given exponent using binary exponentiation\n * @details This function handles the exponentiation of a signature by any given exponent.\n * Uses the square-and-multiply algorithm for efficient modular exponentiation.\n * @param sig The signature to exponentiate\n * @param exponent The exponent to use (any positive integer)\n * @return The exponentiated signature\n */\nfn exponentiate_signature<let NumLimbs: u32, let ModBits: u32>(\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> RuntimeBigNum<NumLimbs, ModBits> {\n    assert((exponent > 0) & (exponent < 131072), \"Exponent must be positive and less than 2^17\");\n\n    // Binary exponentiation (square-and-multiply algorithm)\n    let mut result = RuntimeBigNum::one(sig.params);\n    let mut base = sig;\n    let mut exp = exponent;\n\n    // We assume the exponent won't be more than to 2^17 so we can\n    // have less iterations\n    for _ in 0..17 {\n        if exp > 0 {\n            // If the exponent is odd, multiply result by current base\n            if exp % 2 == 1 {\n                result = result * base;\n            }\n\n            // Square the base for the next bit\n            base = base * base;\n\n            // Divide exponent by 2 (move to the next bit)\n            exp = exp / 2;\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-1\n *\n * @param msg_hash The SHA-1 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha1_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 20],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha1_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha1(padded_sha1_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme with SHA-256\n * @note The `exponent` can be any positive integer (commonly 3 or 65537 are used for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-384\n *\n * @param msg_hash The SHA-384 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha384_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 48],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha384_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha384(padded_sha384_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-512\n *\n * @param msg_hash The SHA-512 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha512_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 64],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha512_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha512(padded_sha512_hash_bytes, msg_hash)\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-1.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha1_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 20],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 20; // SHA-1 produces 20-byte hashes\n    let s_len = 20; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 20 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 21 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 21 = 235 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 21 = 107 bytes left for DB\n    let masked_db: [u8; (ModBits + 7) / 8 - 21] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-1\n    let db_mask: [u8; (ModBits + 7) / 8 - 21] = mgf1_sha1(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 21];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 20] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 48]; // 8 + h_len + s_len = 8 + 20 + 20 = 48\n    for i in 8..28 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 28..48 {\n        m_prime[i] = salt[i - 28];\n    }\n\n    // Compute H' using SHA-1\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 48);\n    let h_prime = sha1::sha1_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha256_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 32;\n    let s_len = 32;\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 32 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 33 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 33 = 223 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 33 = 95 bytes left for DB\n    let masked_db: [u8; (ModBits + 7) / 8 - 33] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1\n    let db_mask: [u8; (ModBits + 7) / 8 - 33] = mgf1_sha256(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 33];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 32] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 72]; // 8 + h_len + s_len\n    for i in 8..40 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 40..72 {\n        m_prime[i] = salt[i - 40];\n    }\n\n    // Compute H'\n    let h_prime = sha256::sha256_var(m_prime, 72);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-384.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha384_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 48],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 48; // SHA-384 produces 48-byte hashes\n    let s_len = 48; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    let offset = key_len - em_len;\n\n    // The array slice sizes will be different for SHA-384 compared to SHA-256\n    let masked_db: [u8; (ModBits + 7) / 8 - 49] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-384\n    let db_mask: [u8; (ModBits + 7) / 8 - 49] = mgf1_sha384(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 49];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 48] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 104]; // 8 + h_len + s_len = 8 + 48 + 48 = 104\n    for i in 8..56 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 56..104 {\n        m_prime[i] = salt[i - 56];\n    }\n\n    // Compute H' using SHA-384\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 104);\n    let h_prime = sha384::sha384_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-512.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha512_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 64],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 64; // SHA-512 produces 64-byte hashes\n    let s_len = 64; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    let offset = key_len - em_len;\n\n    // The array slice sizes will be different for SHA-512 compared to SHA-256\n    let masked_db: [u8; (ModBits + 7) / 8 - 65] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-512\n    let db_mask: [u8; (ModBits + 7) / 8 - 65] = mgf1_sha512(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 65];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 64] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 136]; // 8 + h_len + s_len = 8 + 64 + 64 = 136\n    for i in 8..72 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 72..136 {\n        m_prime[i] = salt[i - 72];\n    }\n\n    // Compute H' using SHA-512\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 136);\n    let h_prime = sha512::sha512_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\nmod tests {\n\n    use crate::types::{\n        Params1024, Params1025, Params2048, Params4096, RBN1024, RBN1025, RBN2048, RBN4096,\n    };\n    use super::{\n        mgf1_sha1, mgf1_sha256, mgf1_sha384, mgf1_sha512, verify_sha1_pkcs1v15, verify_sha1_pss,\n        verify_sha256_pkcs1v15, verify_sha256_pss, verify_sha384_pkcs1v15, verify_sha384_pss,\n        verify_sha512_pkcs1v15, verify_sha512_pss,\n    };\n    use bignum::params::BigNumParams;\n    use bignum::RuntimeBigNum;\n    use sha1::sha1;\n    use sha512::{sha384, sha512};\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_1024() {\n        // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170, 193,\n            96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n        ];\n\n        let params: BigNumParams<9, 1024> = BigNumParams::new(\n            false,\n            [\n                0xab238ad9cb37979a43aefbf10be8fb,\n                0x31347febe45fe8c2dac1dd30900704,\n                0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n                0x5eac6390f7873fe97ff9bb14a173ea,\n                0xbc41f700c91fd733a2c63177bbdbd4,\n                0x41442bd58769a3595b659a2ec9c6be,\n                0x4ddc91395f330382aa2e2d3fbe147,\n                0x3d008ff255a0bc71c7887f5728ba1,\n                0xb640c3a8f511c64e,\n            ],\n            [\n                0x5d53d2634c6a0918266043968ce263,\n                0x5dd4be3dce0323a492ee9340aec4db,\n                0xf82d0e2e5c8319f01a460c72c01854,\n                0x236e6fc6e62e8a1d522acda5fb3892,\n                0xdaf755619d66e580901aa224d03174,\n                0x8366291616480e7e1f202dbcedda87,\n                0x40ba1202537d1e94561ccc05265586,\n                0x69b993d857ba89ea5de9822aeb4b93,\n                0x167968c0000761a273,\n            ],\n        );\n\n        let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xc3850e84ea02da3f028ff422f4d6a9,\n                0x9761f0bd9021f76d45c60df0670a19,\n                0xc1ede421a43607ab623ed4d5a17fc8,\n                0x86197b4315206f4d53200b42555831,\n                0xe95783b69db28c26a83706f39d04cd,\n                0x18b178dc1a9ec76fb22b57e4dfa703,\n                0xdd0e19cd5a09ab48e7af4d0e3470e3,\n                0x10004dfab1cf91304e80e6baa4dfc7,\n                0x241c3fd77b90adef,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048() {\n        // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131, 166,\n            79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n                0xbfb937fc4d3cf02cc0af780f3cab44,\n                0xd20637ef7adcf5d238ee87bccc9bca,\n                0xb9db4f2663108e2f8b673f7612ae8b,\n                0x85f894ef669b36bfd3d86b0a28873,\n                0xdcc70e1884e38b8229cce3b884121d,\n                0x35488d1138e0b03e1676f7f5d8a5b3,\n                0xe1a97820e7dcbb4eab35c9b71bb273,\n                0x97d19eb3c63249ddbfcff915863f54,\n                0x3a78c7af6da0f6af0d67b1ca4b6065,\n                0xd7a3c433c020f624821e5e678c7d69,\n                0x52d5b53240feae82ffea3d2a3d9b09,\n                0xb8aad5e19e2163f68997c6fdd71906,\n                0x5db432d06e8b0bf59511100c7894e2,\n                0xadc0bbc4c54da10d1cc88438ea3127,\n                0xece1cf6a1501109cd2734d5893c8d9,\n                0x7196b90acdf06c31b1288064fd0c27,\n                0xc8,\n            ],\n            [\n                0x1b1deccf4dbde852c34a5d6908a0f,\n                0xbc9e5bdab22f023fbcca58692bccf5,\n                0x1f65439685623e45396ff55751c3bf,\n                0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n                0x5ca2e8e3048243c16c708a8030ab0d,\n                0x30079bfeb1fa51e5501581173ca19c,\n                0xff8d5f6bea485fdcc2716327f69ab4,\n                0x36b599d81589416b5b5f037986b999,\n                0x75612e34a4ff29f0a19a7823512f58,\n                0x288b6897929b54c3b26a5faa07c00f,\n                0x4b5675fa13ab7444f1f047d3eb1bbe,\n                0x6ba0ac610ef9f267ab30fe25bb1c84,\n                0xa386b48ee03168d5cea3ecb9dc901f,\n                0xacf1a01f7dba44e050c976142fb1f6,\n                0x97a63b5cb7efc60d3502946aec63cf,\n                0x12cc1d5cab10a1e9e2398d29b9e3ef,\n                0x4635cf25c66e76bba8034df46204fb,\n                0x146f,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xad29e07d16a278de49a371b9760a27,\n                0x86311920cc0e17a3c20cdff4c56dbb,\n                0x863556c6c5247dd83668dd825716ae,\n                0xc247c960945f4485b46c33b87425ca,\n                0x7326463c5c4cd5b08e21b938d9ed9a,\n                0x4f89fe0c82da08a0259eddb34d0da1,\n                0x43a74e76d4e1bd2666f1591889af0d,\n                0x240f7b80f0ff29f4253ee3019f832d,\n                0xc6edd131fbaaf725fd423dac52b362,\n                0x85f9732679242163e8afff44f6104d,\n                0xd3c3bbcb1757013fd6fb80f31dd9a6,\n                0x9008633f15df440e6df6d21ee585a2,\n                0x324df3425ed256e283be5b6b761741,\n                0xc60c1302929bd0e07caa4aeff4e8fd,\n                0x600d804ff13ba8d0e1bc9508714212,\n                0x50f7e75e5751d7edd61167027926be,\n                0x0db41d39442023e1420a8a84fe81d9,\n                0xab,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n        // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132, 239,\n            227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0xe40ee47801326543c8e84b85d567c1,\n                0x5b54ea87f0ce29de1995697b0696fd,\n                0x457078f8fdce68b437cac0970b2452,\n                0x473ec776fee3731b6ab06e35875ddc,\n                0x62dedd594e5f12c80c3ccb5791a6cd,\n                0xecb934b9d8272c5e3a418145345499,\n                0xd1af643b3d785470ed0c6cd633f706,\n                0xb58a57b9e96eccbdfc7c17f0333d4,\n                0x2ebd34b5039fc596504927c282c60d,\n                0x3a44928a74f25fc1043bb37ce4dfa8,\n                0x91448459f9617fac33a2816162ac9e,\n                0x70cb910d9f3e1a78864640ec6c8240,\n                0x9aed33f6b31f1c9de67248a98c180,\n                0x7f1416e032c79488c94b311e87bd9c,\n                0x7191b4ebb1b3fffa949fa48ed01e5,\n                0x350a75cbaeca6bfdd71ca83cdbcae9,\n                0xfb1d274fa207457c6814d42c09f9cf,\n                0xd4,\n            ],\n            [\n                0x803bf4d38110a7d37fdd05f590dee9,\n                0xa68d317c933f37cab5ab4e7c00a3b9,\n                0x476a05a536bf5f2aa1b8850146cba7,\n                0xca297ea8b5528d91d4836ff27c30ab,\n                0x75cf2eaab76eefa12bbd570f1aea9f,\n                0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n                0xd497db1f6ebe83decacaa647fabea6,\n                0x686b27ca330e25e7a7cf197f6433ef,\n                0xfde04d2225c8308b07580af0058a0f,\n                0xa29fb69777c0e916976243b2b09855,\n                0xf983592285852e7e1c2cb3ae968323,\n                0x673608017f9f5acf67a01b73728d70,\n                0xeeff82521c0bc432a05f4b7444fac0,\n                0x85a89c4d229f60aaa3aa7ac7dac1e2,\n                0xcfecff93bc9fbfe0d6dff6091f2db8,\n                0xf20f047dcb224b4447bd098c07f8c2,\n                0x554bb53cadeb3eaab911a189f90227,\n                0x133b,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa250eff812c63eaaeaa3f04641c05f,\n                0xecc09613cb8b289c1f37c8f92e6a05,\n                0x2c0a0510058360c07af65d46f594fd,\n                0x943d67513363d3de430c94a1dafe7c,\n                0x511ec8e9b10bc6c6ff0d6c232ccf92,\n                0x50ffd07b3c093b3f5fc027de847731,\n                0xc268e1489449943fdafdf89ff168c3,\n                0x0b8b7f9f49b492f78fda58d252f23a,\n                0x491c6c4ef836a6a8730b7bf81e865e,\n                0x8746c75fb079d014e419543f56d7f0,\n                0x65804c417d6168a8bc0025d255cebf,\n                0xf695e91b77890b8e3fd775fa56e627,\n                0x5e90001c0218550f4083ae28025a2f,\n                0x526bd4eff34f25f62a698f0470e0a6,\n                0x7f224306a7d9daf536b1559434c6c6,\n                0x88809f16fe1fcea3c87511d9319735,\n                0x7694685fee0bfab4a9196b92ec6f2e,\n                0xa7,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_38129() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x4f79aee9e865ee89b9695c2ac44903,\n                0xe33ac311e740f4dfc39492d38186d4,\n                0xf513677b71c4cdf88b9011d109402d,\n                0x940eba50ebc0a50b539268b2c9edee,\n                0x6d7b7dc633b0ba7deb34669da59af9,\n                0x69f0b92bd973d83643b54c86302bc8,\n                0xbee39cd038bb54491cab410bc1382d,\n                0xe59688c01aa8491c6522aa467fbdba,\n                0x8731b6ff98f9e1f792d4a4dff8c81d,\n                0x9d1773f064f1ce81301053e3abcc43,\n                0xe80e6137f3ccf06ca669e0d0f14c30,\n                0xefbf9d55ae96471f9fef8d5ac29c46,\n                0x284807c893f7e7af1a39d9c599ba76,\n                0x17491bdeafd3a2c796dd50f2444997,\n                0x21742c4e2dc66d064e36abb50f9c67,\n                0x58f1503ad765979883692dcff55252,\n                0xf613ad8641b9195cb742ac5d3ff778,\n                0xad,\n            ],\n            [\n                0xbd864af583a9911c93c5b92ab68568,\n                0x10d63ed8c0c83e91e945683061045b,\n                0xf38982278a43cfae6438348ae94c9b,\n                0x75133ea58bac5abff54a6e7a165283,\n                0xd3449474e97738f4c6a2d843722783,\n                0x9e3b3c08f360d9f967416af9becf84,\n                0xcd40081688aedd976009f34a964356,\n                0xa27adea282e0227e69ff47203440cb,\n                0x99f812956fd9377b0bed8deb543ede,\n                0x5f655415ed123df19398d5d479401d,\n                0x587d5cae3d0a5b34e3f8b2ca43ade1,\n                0xa4fde6c7f37ea8267d2183519ceb1,\n                0x1ba5bec0bb36c67251aa7678f7c169,\n                0x2e1ddae393d6a4f1a320b15b23b974,\n                0xfc61518efd066b5912b60cfd1d7474,\n                0xf854c457bf3908af1e4934d7c72d1f,\n                0xa44257cffc0c579bf0addd3c75d4df,\n                0x178b,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x98156ae7cbad0e0fbaa9b254c445cf,\n                0x6f3ea82d1faf48ecb60f3f7481f020,\n                0xea0f2df747bbe8a8629c9dc6246da7,\n                0xb635b9de66aa7e600e924c0932b43b,\n                0xa010df8938db4c035c8473f0fd167d,\n                0xe37d1709aae17c76199c99efa5e5a7,\n                0xf8336b32c807dfb62d149fb8353f4e,\n                0xf852a4cc6a84981cd8a0d9eef5510f,\n                0x10c5cae74e75c83e3835906e5eea2a,\n                0xd83e21dc7e49277c86d81144837750,\n                0x72e367e8e2db3320145626438e6e93,\n                0x2129c9c0c2ce89e77661a15c8c7647,\n                0xe9c0b584a2ed003dbe4cadd2cfd87f,\n                0x6e5bd7521c235ab9e18356d089863a,\n                0x28e861ed03b6acc39fa7af5c068fa7,\n                0x4d1a681de2ce54f0d19eb736723af8,\n                0x2042cf79eb42702aab8526c68a64fd,\n                0x90,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 38129));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_107903() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xf2bc2f4fd3637bb9ccc7e163324dbf,\n                0x88ac5e7a9abee89a393533168e8743,\n                0xa9d1ef7f5677329e23336052001928,\n                0x2fa85860b512fed4ecc0c94388e4dc,\n                0x61b27bbdb48fd8dcf155a1d3242029,\n                0x8119d20bb357bee95c9e6038448ea2,\n                0x4e8759208ccbfc555d32e3fa487af4,\n                0x7608d025ac5a266c1e795b7dc0840b,\n                0xd9df24711a6d2fed0d9248057cf278,\n                0xfbcd7907dc0dacc66a855324c5ae85,\n                0xcf3eca7c8405dfaf7ce39c1b1e526d,\n                0xf2c0a24eb8fd5b2b49eb261b01e5cb,\n                0xb7be784d951012ec79c8df7bb35e10,\n                0x2f7a97fe187189f04fead5f1b00850,\n                0x8246d382cd0821b066e801665eb949,\n                0xbca14eae9a7d4b426639eb99d15c3e,\n                0xfd0f6549b224f1be363e496501a0d8,\n                0xd0,\n            ],\n            [\n                0x66eb2aa6aa1141cacc9004c4aaafcb,\n                0x3983dda53fcc7548cac5070988d128,\n                0xa94b8ccd7bc37c9c6c074ec9dc418e,\n                0x57d6ec9504d4f025839a764cc80cd6,\n                0x5a99da586dd573c790ad0b0cf4048f,\n                0x4c7432020677232539d08b80c4d3,\n                0x338f75091af189cb1d224bd37c6249,\n                0xee6a89be24e36b5f7f1e7c38fae7ba,\n                0x1464843dcb6adf79a5775db61a461c,\n                0x6040e8536fcfa579e6058fe8fe2faf,\n                0x493b2bb04dd77744a5adc46d90652c,\n                0xef49699688680f2bed603abb89bf31,\n                0x5d86fdb1035de7023db8815fea79ef,\n                0x36e4b0aca5531d5c0da94709ba17a4,\n                0xa4327a03320a6982a60603abc981cb,\n                0x5d54032f69977241b356abc4590887,\n                0x62bf97079a59e9ce6320da47988e99,\n                0x1399,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x4b2f40b350af5cf9b4cd5e4a48484b,\n                0x2d45da942f02e9c1ca4d0b5c8891eb,\n                0x95e181ee7a25546bb5f06881ed06ab,\n                0x96daf6f89a37583781ac3cadc3b474,\n                0xca3d251f57ab831e38da4a72febd6b,\n                0xd331a8762354c7a21a205bd00a56e4,\n                0x30e1612ca0c22b20df7e3b13ce20ab,\n                0x0e44e8752d7f365a5be65666a695c7,\n                0x2f9371a16fac95bdbe2bdd29fe3660,\n                0xb5aa14bd29c9cead7fe248cc8d8fef,\n                0x5152b5458eac4871b2dad8ae6f82a9,\n                0xb440d47429dfc47c83afa416a4f6e2,\n                0x6c71eb1897abe36235364ea0257868,\n                0xd2d51b57e037b494d663d8238f7ee5,\n                0xcc7fdf728797297df1292e63fd6e3c,\n                0x4eaf8992cf23b65390e2dfa7b012d7,\n                0xe84bdde98147a17f3a9297786a9b84,\n                0xaa,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 107903));\n    }\n\n    #[test]\n    fn smoke_test() {\n        // Output of `cargo run -- --msg \"hello world\"` in the `signature_gen` directory\n        // Create runtime params:\n        let modulus_limbs = [\n            0x65af46d235241cf0e8fbe8cff4abb7,\n            0xeead39ba3f377ddd5ccb2ef2085190,\n            0xe483f94c0a98e8b618d92fb926f596,\n            0x1fa8c1b2c62cca6db090cd74a29db2,\n            0xc38e22042fcb74585a7e535301f50f,\n            0xcbc4378e5212752743ae78a75a44a9,\n            0xf5acc41788d9a346a0f75630a8b2b6,\n            0xf7a741bb3ecf1aadd5a327f362abd8,\n            0x4d5f24e815db43a1b2cc2ba40f8715,\n            0xe501f1a01305cb198475a4bff0da2e,\n            0xd541b78cfbc2b314083c340840c82c,\n            0xa0ab069c26b2a0458f4c642bf72526,\n            0x2ccb676d8f22517116fee0d2340533,\n            0x7cf2a7cf772025c0a83747bbc18228,\n            0xf9475f17988a56f17b3bdf88dc72dc,\n            0x4ff228bee24415fae7a7c05771e830,\n            0x55acd96b485515c38906106cf0d189,\n            0xb9,\n        ];\n        let redc_limbs = [\n            0x172c8f156f020ad88d30fa3ba47f03,\n            0x1740a43a67cb9a7be1ac1422d77246,\n            0x2d967be1edf369834317e04856e591,\n            0x65d9fa0de5fdab598c04d9a515156a,\n            0xc6791a661ea7621db7e6c4ec48f466,\n            0xa4a1a7c06d3e8a0bcbc540c6af6788,\n            0xdcaffeb149f5bf646caa00d7355715,\n            0xb75471630a9d0fefb5cb61e66991a1,\n            0x97c041a0fc30fdff3d5ed16997da02,\n            0xbfbe7d217694b269e1ed37819c2f17,\n            0x1b44ffc3180531e2ab8bdf7848a3a9,\n            0x9f004af11132cb68bb55998ed7616a,\n            0x1b15dbbb96ce80f479724bbd768a0c,\n            0x59ba1419093ae6ed2592ffb3065867,\n            0xa35b69affa3bb3f4713f315e50b584,\n            0xa873210f83a6de0d8cbb816af3e37,\n            0xbe4fe7cf98da87ec87638030797e92,\n            0x1619,\n        ];\n\n        let signature_limbs = [\n            0x2f397c4611d4a4271453e1e50e1578,\n            0xe506a7f47c721a4943783e8ad459e6,\n            0x6cc4ae1d91cb381cba9673470999fb,\n            0x1e127364d07f94e58227f50fbf5687,\n            0xf64a2579c7189f882d68832d16faa4,\n            0x3b014b74c6c6f76f2f8af170fa0fe4,\n            0x7df41e68c86815a6fdc33968c66b67,\n            0x6a57ac06282527242fddb6ed08dbdc,\n            0xac40d37b819c4b6193f90a634e4fc7,\n            0x96606ed166a7f032d858cd40ac73a5,\n            0x8eb7d4351159a46733f92610d5c597,\n            0xc8e8e9faa9738e82dbe774a3f5cf07,\n            0x89ca84fd54ee3d5cca87c9f178375e,\n            0xdb7a1465fc76507ea498a351af70dd,\n            0x6ac6fe14f51c711f983125c776f712,\n            0x3254c17fef51bf4194a8a1674634e3,\n            0xee38c83c77c6e1ff7b70a5d9d1dd0f,\n            0x26,\n        ];\n\n        let hash: [u8; 32] = [\n            0xb9, 0x4d, 0x27, 0xb9, 0x93, 0x4d, 0x3e, 0x08, 0xa5, 0x2e, 0x52, 0xd7, 0xda, 0x7d,\n            0xab, 0xfa, 0xc4, 0x84, 0xef, 0xe3, 0x7a, 0x53, 0x80, 0xee, 0x90, 0x88, 0xf7, 0xac,\n            0xe2, 0xef, 0xcd, 0xe9,\n        ];\n\n        let has_multiplicative_inverse = false;\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(has_multiplicative_inverse, modulus_limbs, redc_limbs);\n\n        let signature: RBN2048 = RBN2048::from_array(params, signature_limbs);\n\n        assert(verify_sha256_pkcs1v15(hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha384_pkcs1v15_2048() {\n        let sha384_hash: [u8; 48] = sha384::sha384_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x1dccbc1b553aef560cd665aa2ca411,\n                0xdf1b70d8f0ff39013065a5a886490f,\n                0xc3952220c2f6ba45b86fd1842f6db5,\n                0x13403323f2e86127e7d30ca5c3741f,\n                0xdd9593e1b80868ee660cff6aed224d,\n                0xa768ff67951f621cf220c3f11fb7d0,\n                0x827a30c8fc6da6d9e0002ccbab7354,\n                0xd4f4b3326c1822490ba84bf7d8f2ff,\n                0xbc1aed9983525cf9795c5ee886efbe,\n                0x95eca388e0ef68d9e1b51bfdb3f38b,\n                0x5f250161202b7d91724180734cd057,\n                0x5f6a6e4b2adf9db128af321e90bc61,\n                0x2b395ebbeaaf0c6c40a8e7ab2f041b,\n                0x8fea1754c39077bbc232d8380c4eac,\n                0xa113212c3d6ba516cdf08b1c0c0cae,\n                0x9ba6c1d51332cd846f88cfe28dabb,\n                0x57a8d8bfcb8839f3ef85c7ee2dc2e0,\n                0xb4,\n            ],\n            [\n                0xeb993de4326322c7d2e7979b705653,\n                0x1d611f18aa83085ef385333ec454c3,\n                0xb7a3bee73153dae2577781e9a435b0,\n                0xee599bc9d964a749c73673b0559c2c,\n                0x35c1adbbcbfe860f721aa7a0fc3f13,\n                0xa8c28cff73d6ab769ff07f77246062,\n                0xa6263efec60ed7d395f486a0a96b2d,\n                0xa6da86e3c3abd7bec42b6fab8927bf,\n                0xc5a27d894e67e310bc4490762e53dd,\n                0xea29c3c6430885ae7b68d1399dd42e,\n                0xb5a82288241107dcc02e4d04cc0fd,\n                0xf9dbe42935c2111913f05933346bb8,\n                0xc82f5eca04e0b6ab27cdbc55ed1cf6,\n                0xbc6d3e01593e9d1c9399245a306ccd,\n                0xf5da9e23e54b7ace54fc14e9b8fe89,\n                0xc087aabdf746e1a12a8792cf7ac5d1,\n                0x5c825b2c8353558dd371d57b1d31af,\n                0x16b6,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x0d643395f61610f78e0965ff28b34a,\n                0x991a18b16cd776f8ba0dc7d3a2c0ac,\n                0x59ad92fdc6573338573a5ec3a8ac1f,\n                0x39fa3c545c220904560f89449e0cb6,\n                0x77c0492bb5f8faeab6484258164fef,\n                0x32f66a824fc81c4bc3a10228c9d875,\n                0xaf5a933d03c5c769af3e1c43112418,\n                0xe4b3c71e29d230dbcd784dfd344cc6,\n                0x08f5fd6f3b0782eaae154fe56fbe0f,\n                0x9b785970ee35b2cd656cd9f098565c,\n                0xc6c649021334fff3d4ba072255eb0e,\n                0x1fb7d5c84e2fc4e975ea5793a92fc9,\n                0xcbb718f2f6c780b4f6e3a17575b89f,\n                0x04f7eb7174814ff492727916397bb8,\n                0x77790f451d53ce4d4229791f142d38,\n                0xd9ab6403501d48c29b3abbad760d43,\n                0x20d90ee7975dcbd1761fa7f6487391,\n                0x17,\n            ],\n        };\n        assert(verify_sha384_pkcs1v15(sha384_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha512_pkcs1v15_2048() {\n        let sha512_hash: [u8; 64] = sha512::sha512_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x56acc9475dd0568166f6d519d2b123,\n                0x4388e4291f2a16d58441e4c966d869,\n                0x3b6cbbf6524f2e12e274d96a598cf3,\n                0xcb7b28845e13e53fc8827fadcbf5c2,\n                0xc2f20ecad4360634ca81a3f2700df9,\n                0x71b5ed85f3cc58e9820fa9cdabf2b4,\n                0x8e15d0237c7dbee5369ccbf8f6e25e,\n                0x280d4771bcddaebaa691b4870d4a92,\n                0x3f8ab4c278a35f45149814c95c1c6a,\n                0x4b88bb3a4f16adaa8a9ffa781086ad,\n                0xb4e8dad6bc3fd7d666683e872832e1,\n                0x3135b2958becadcb9e25ec25e55b23,\n                0x405ef523d210399f9def6302a36221,\n                0xb9aaf3a3c5b2e3f4f86393bde7b852,\n                0x5f66a3d278b5759b92269481eb94ca,\n                0xb0ae491acfb3d0a8a46a92b7adffb7,\n                0xa61f0e1720a3cc4594121de7aedf34,\n                0xc0,\n            ],\n            [\n                0xa1818833c46a2c4799148d9f1264d9,\n                0x91008bc32d17f31c4f28b53cf3b9a,\n                0xbf512971ab01254af711f37837279b,\n                0x4f98e0725dbc7d52fba2f5d5482d5,\n                0xc06343b59716c402d33ae0d15ce9b,\n                0x96e236079ec038a21029aba4ff7ffb,\n                0x76e91c4ee8870b1d1c06b73a00f0f9,\n                0xc5018d4394283930ab64cc401b3809,\n                0xc8b4f3f863b01b0fe223822f163552,\n                0x6a94ec6a63708552ac0ab6a824f380,\n                0xc3cf47d1d72b08284f9c04e265a5bc,\n                0xa9d863c6820f2ec1cd35de9327b153,\n                0x85983ec02cffd866801e790bbfa7d2,\n                0x5ee89f7c98ece0aaf4150b6c5b6abe,\n                0x7255ef31994f3cb4b731d0bbf76c57,\n                0x3aba2e537e9003f447c62153c3dcd7,\n                0xf005726db837e60cff0feaac8d326d,\n                0x1542,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x8c1ac22b4f25479bd4d63adc5647a5,\n                0xc226d235d17e3ce2d6303804edd317,\n                0x75992147cd0883367aac32c28927e2,\n                0x7f131d0a5dc76ac9a3982bc3430a66,\n                0x1e5c5471a794bede59e42c5125df77,\n                0x7d4d8bffa69b08eb5a9338c96eb042,\n                0x44bc5745bdb2ed1944e61939c9b325,\n                0xa9c536593f93201b1493257bfceedb,\n                0x9f00b9f27e424f9724c1486fb54314,\n                0xeae7e1250521e254ee2d31f94002f9,\n                0x9ee4db7dbe46139670393a1250fa79,\n                0x014039fcd5bcfa3db273bf7188b3ce,\n                0x4967a88c2ddaf359c3c813cfa3ccc6,\n                0x9c3f74383a8c3326b47401d5815c45,\n                0x2f666d5fbe8464dcfaf569bffa0248,\n                0xfeccacb7e9e0e44320651e58344e8e,\n                0x8942c708df7e40a175d44fee7cf5ec,\n                0x4c,\n            ],\n        };\n        assert(verify_sha512_pkcs1v15(sha512_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_mgf1_sha256() {\n        let seed: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let expected_mask: [u8; 32] = [\n            106, 93, 232, 46, 236, 203, 51, 228, 103, 104, 145, 29, 197, 74, 26, 194, 135, 200, 40,\n            232, 179, 172, 220, 135, 51, 185, 209, 35, 194, 131, 176, 190,\n        ];\n        let mask: [u8; 32] = mgf1_sha256(seed);\n        assert(mask == expected_mask);\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_2048() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xb2cae9b4d726643aef459696fb80d7,\n                0x46585d789783e6f0ea6a4a17001b8e,\n                0xfdf7476659c117564ca991f3d635f4,\n                0x9bb5835a63f78d2ff06927d5f5a64d,\n                0x18ce92c21c9a7dad5ed41c66790811,\n                0x38003b2699273864cc87b363714855,\n                0x7c19d41f8dbe41e03505fe1e061a5a,\n                0xd63a7a6d91625495e46db9161b0d7c,\n                0x3dffb1f7121946f6e04dc642a85da9,\n                0x389eabe29dbf38c1be95c9b9c0c029,\n                0x77a14dc6452603a154cc463e4c2a3a,\n                0x68eaeef1963fa3866c934d1225ac67,\n                0x3a66b9b64048ed95cec6bbe4235189,\n                0x113fd1c23822a8dd63e7d97b034eeb,\n                0x28b7376afc6109602ed94eb40284f6,\n                0x4d331f4da82c798979e7d9d2c5f7bf,\n                0x716d8b401bea115cf1265f976aaccf,\n                0xaf,\n            ],\n            [\n                0x399ea4dac74d4757a7a2956b5b0493,\n                0x954c409a53ce8d70f35be10b94d284,\n                0xee4d330032d52a65e66f54f9e091f4,\n                0x7522b6ca940bfc5133b8fd77ca4bc8,\n                0x43485c2c6ac94d8041c5a056da794b,\n                0xa464924f3a28ab23c5ffa0493dddee,\n                0x8fe3f1bc6a09e1103acbb53acbf6f1,\n                0x5e47597909e86c168b5748cc089ce1,\n                0xc86b6b4de2aa786e144d0ef5556c30,\n                0xf45a9d9d93fbe0cd5f2ddca2316648,\n                0x5edab2328b0b639407f9c773a06c5c,\n                0xb61d4e287c0c6a969f5decfd036ea5,\n                0xd47864f47e49cd0e0ec34f120ba0a4,\n                0x3eaa94f799b276ef6a790eb61722d4,\n                0x5c18da1341811cee5de6f76ed1a186,\n                0x5ef0641da7cac0c45ba74d4355befa,\n                0xbb04586630e92ea5ece8e5db45caea,\n                0x1758,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x6d3125fde00a57fb5971460c38a826,\n                0xba2092dd58c4de8ffff2bf13f5ef57,\n                0xf0ad4ed46727881e7e7f6a103d7713,\n                0x7e8b2203a7a6e3a3a30219d6edf8a2,\n                0x9b0b861dd1cb2751f30d54d07ad167,\n                0x4373e863b15edba97439182a6a9043,\n                0x61621211db5f34a0786d5ef38cd90c,\n                0x63001609f7dffdc70761c67617b580,\n                0x8b2b817a0508e4be6f2c50df23962d,\n                0x6d6f9396978782a90fe06ca78c4f88,\n                0xc567a9fe5f7175225384d7c1e4c991,\n                0x38926dfee8636b9e36728c1cf51198,\n                0x0eb84e90f89a0bd21536a537618b92,\n                0x23dbdcda1fee2b57c8dc2e605777b7,\n                0x6acac69b2fc1c12c204e790034a01e,\n                0xee44b77264385863ccef2e133241cd,\n                0xe9c67049c219997cc8c43b0b1f420b,\n                0x78,\n            ],\n        };\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha384_pss_2048() {\n        let sha384_hash: [u8; 48] = sha384::sha384_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xc3034c17b5578d9c029b22158a8e45,\n                0xa84c80b43a68c9eb7cde67f1f60e07,\n                0xa8d82a4aef2cd733a9fdf43439ffbb,\n                0xa1b9aae31832c2815b81f0db70962e,\n                0xcfcbc51338d691443e702bd18354a7,\n                0xaa2c5f465a247efc9d97fb052579b8,\n                0x571f3c233fa322a933a4cfc0c4b213,\n                0x3280f1f7238a3416c5e1140077537a,\n                0x8685f03e3076c1bb62550cb363ae08,\n                0x55ebdcb84073ad2dfd3553c5e2d21a,\n                0x1e5a0a662b44f5250377abcd1069e6,\n                0x178357493184215e38603004f6c9f3,\n                0x75cb8889b33c6b78bab0a378453376,\n                0x4f5f7baa56492d5ac52c1bf7b998b,\n                0x16cf48a7c416bbf67657a263376e22,\n                0x1d8ab41c7021ebcb15da705dab5343,\n                0xc5e43d48377059df0aa5d7e5441586,\n                0xc7,\n            ],\n            [\n                0x721a52a87ca82263e96fd6d2bf3417,\n                0x74bfd742af70020df01f6cae960793,\n                0x1091edcad411cdbfc254bbb2ab2906,\n                0x9d1a2951a8e50de9c90b803c3d4931,\n                0x506ad1760d06b52708ccc0ed9fe629,\n                0x11b96266505a62523f9cfa1101a9c8,\n                0xbe5243b0f30ee090c4181e19f45f1a,\n                0xa2a56edaec8f9fe12d4d07d725931e,\n                0x50723b780f7ef18393031ced4f1489,\n                0x1ef7d8dc5b567db0b1a65b745625f2,\n                0xf9f37b5efea9a93029d7d5dda26bc2,\n                0x759247cff5570cb9075ae0e8b5cfee,\n                0xfb2e6c00b4ce0feedc40f3633d354e,\n                0xc9051ad4f912e7a5753e614d892320,\n                0x3cf78d852f5f76bc267b0ebcf13c39,\n                0x7b3cb2df2619a3020f2080dd555657,\n                0xd649e6032585f42250ac6c95111c09,\n                0x1480,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x06d24f9dbd859780c7684e7733ebb1,\n                0x3acb7e4bd7c9f42a5f9649e1fef5c4,\n                0x67878f2493de5cb48ae107df08dbf1,\n                0xf268bc940d64e42b8719216fef188e,\n                0x2c4701120db41532e6d195ba1f8faa,\n                0x03d3b537eefd6f0c99fbb7c1f359d9,\n                0x35b732ca45b03bb17b1f3564f18464,\n                0x468584d7dac0a4ba51032e2a5f95e2,\n                0xe10042eb30d1662517aed3b89e1154,\n                0x0e5743acb366c6251627e64f751256,\n                0xb06e6af3e06ed5c656e66aa0295f63,\n                0x67378aabfe17e33e305825eb4f6c5a,\n                0x8cd4c7aa81b660325dba4b0d899a9c,\n                0x40c83a9c74f99c026aa845fa222b69,\n                0xd52f8e19032a33a1d9a01063fff8f9,\n                0x7dc36972054edf46bbfe918711e693,\n                0xb035fca3baf4329ff5d588baf7b034,\n                0x1c,\n            ],\n        };\n\n        assert(verify_sha384_pss(sha384_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha512_pss_2048() {\n        let sha512_hash: [u8; 64] = sha512::sha512_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x928a173c3947c058b084e258b8a4c1,\n                0x5f1179c22cfacb440464695cfa393e,\n                0xc409e532b3077ce4d90e66e913f125,\n                0x29e8696374f86380ff45d0f29a98d5,\n                0xf931d155d89d3753ee931433a8e2fd,\n                0xfc3d1c2a999f0112f5c5416c2e0428,\n                0x4d21692b210bec2ab8e1b52fe78e66,\n                0x9df364fad350d314b146e84f114203,\n                0x8511a74031596831dda8ac9d18dcf7,\n                0xab5f9ad71b33284aae738988284229,\n                0x3332aa31681f69a5f470caadad7469,\n                0xf1fcad281e0fea144e1f4208d38e38,\n                0xe83d3b0afb20bc39814ea22df000ef,\n                0x3d9244664808f54fc4f0702adc9399,\n                0xc087b5dc693953e6371b9c7c175a21,\n                0xd5910d0d4232e8f92148482a72baec,\n                0x44e57b58ec4e75250116ce2f1abf3b,\n                0xd2,\n            ],\n            [\n                0x74b3f4c907125a6150549b8b5a387e,\n                0x9c2ecc9981d5fc27f5a6a7b4f23756,\n                0x57ee194ec44b4a44df198809f8d673,\n                0x7ffa9a1ec7d9a9b915e1abc75c493f,\n                0xde339596c27c993135a7ee132cf774,\n                0xfdb788951d3777aeea6afee171b569,\n                0x8dda93126970270ed42ae605e9824f,\n                0x3fa6e07b4429f0ee8370c988553ee3,\n                0x26d95e43ed1e1960a316eebf6b3b0b,\n                0xfd155b9025d16ecdbdac73725d9a89,\n                0x2f5a47107ec03b05f5a10fba4fa1df,\n                0x61a45285c5dc3355741713d6d71a24,\n                0x8644f1f46cecd803e531110da3bd5f,\n                0xaf989d56c5412bee6598af25829723,\n                0x52f7827f7aee453f9c3eb9753fbe4b,\n                0x9f38d6f5f1a3ff0d40c601d799dbb0,\n                0xd401bd1620fdd206413a8977de6375,\n                0x137a,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x2058f7115f339e55a93f8dcefe81b9,\n                0x38a20cdbfc439a1fea423c119f2879,\n                0x7ac4e03a5fa662754e6e21a78984d4,\n                0x69d714829d29b235d588476152b5af,\n                0xce3db2102990c27bb66bc32da8dec4,\n                0xb4914f6f0e73718b5f1e422fac6ddf,\n                0x7d812b554c81ccb7932d1e78c6e002,\n                0x438fe60d9e0912328374513ab91b69,\n                0x56abaf2b8d9a6dcb9201586d2f0d0a,\n                0x4151c524481066bd81b4cd17829481,\n                0x7c63b445e245d09ca91057032ad22b,\n                0x9f242d5a655035a028a68d337ae40d,\n                0xb5f91b99b495862044bc7122913806,\n                0xc123aa56dff5b23d7d8ad097748efb,\n                0x6892e3a32a7b6963d97b3bdd81b91d,\n                0xcd7aa9e3e77f68f0ed195bff92a162,\n                0x583a32fd5a399f3acd867dd7d6a1b6,\n                0x7f,\n            ],\n        };\n\n        assert(verify_sha512_pss(sha512_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_4096() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params4096 = BigNumParams::new(\n            false,\n            [\n                0xd78653b3d43a72784415fc0537129b,\n                0xc725d4fb19419a03b58e0fb5ea4ad2,\n                0x1d866cfc050224a0eb317e835ee283,\n                0xd298018e86d3225a264a449c63d69d,\n                0x824db5365a077bf704acd2446baa7f,\n                0x5c419e562b5b5ccb0dcb151a3f48c9,\n                0x198a6627edcbc2afce1893217c2e25,\n                0x29a693a0bb3f6f02d80e660f681d6d,\n                0x5656562a9622f87bfb969db2542f63,\n                0xb9408b08a3ee3b25b6dc6ae12899ef,\n                0x4ce9b767219e1e0593782ce46a041f,\n                0xc5a4f318b34ff79121677f283ceea1,\n                0xbd5e62c599453a94e0bf5f48c6b58a,\n                0x6ce23c4978ae07af4c46ea9b9964ad,\n                0x68d4db6209ac89538e6d986cb77459,\n                0xf2ada72cff01696e2efdf123ab60f3,\n                0xf951c3c1965c355f460fa815587ed2,\n                0x6063ac0275e6592b878d5a66e68501,\n                0x594eb3db288ad091bc1db2b2a90101,\n                0xb72899c91edcdf890053f87d5b1dab,\n                0xdfd45eab0c435e275202bff1e22f5d,\n                0x3da05e1d0d3cd0012e6c40e1878ab7,\n                0x4fe053feaf486a27dd119cbee9ce1e,\n                0xa3781b036bd3a3411c2af8377ad0d9,\n                0xdf4410ba8397cbe580fc5eca7d230d,\n                0xdc34151036d459fc3c21d8ba0702fc,\n                0x4ea71eb1b0b1a2f36741b61e8765d8,\n                0x22cb66b4eb0b34b34320402ef652dd,\n                0xd19167b88620fc6b60709fd39cd48b,\n                0x524e4fbe4d75e4817de075ac70c72f,\n                0xd0de26679602cd331c3e5534ce668a,\n                0xf5aa120ff51d4bd3d57c1d68359f95,\n                0xaa06f0791b623cddd53d787035bd66,\n                0x122e014d565fa26417a5ed0f786fbb,\n                0xb95e,\n            ],\n            [\n                0xc4c3bf6cc9335c4bb7199f9eb47a5d,\n                0x7bcbe7b5b3cfb697c6b77fe1aa066f,\n                0x3e936bb516c60dec6e7bde90a54056,\n                0x78a92edbea967a370dc928b2f4cb53,\n                0x99df0977952d4278e6b4c792b31c39,\n                0x7d894ebed8702b158c7a51dff502b8,\n                0x6da93f37eabadd8e55d4f450bf48a6,\n                0xfb59acbad033856be388bf59b73c4a,\n                0x8644dd32dc773e5e12e03380dbff01,\n                0xdff59e8aefb7acc81bde30f7b22890,\n                0xa646c3f6a98819547eae677e99679,\n                0xc777d7da058b7a0d88b7ec84400a6,\n                0xc6ba50b7cc4d0aebf8a25d1eaca0ec,\n                0x6f2cc8babdde75a318872b952885fa,\n                0x6fc91aadc8ce227e9039c8f3148d9c,\n                0x67773f804221d4f58ca3bd11952bc7,\n                0xcf5a20affc5a099ad25abb5b9cc622,\n                0xf60a9108eb36c8068e93e524c23512,\n                0x8b67af87617dcd94e38a62a7297673,\n                0x656343f8e1802e8c043b2621f5b08d,\n                0xd82c8e1a8d3e458e7979a77cd76424,\n                0xd2bf783c787be340bd66fb8a07d1d7,\n                0xc94d16e2ea48369f57abca5909b81c,\n                0x2ff442542b4e904ad3ca20d06ee11f,\n                0xa1fa20565627dd7eb96b4027b6714f,\n                0xd3a82d484df4983db5fadd7b93048a,\n                0x5f4e993b09d0ab81b8312bc09f069,\n                0xcd135a6daa623b906fb62c6e28e9e1,\n                0x1a5abe5655f62a0a0d0d9479ae7675,\n                0xcfa89adba08b924725c940a56ad9e,\n                0x6023b1d30936eb9ee54bf789026e22,\n                0x9e91f11aa269f381122653c704cd5,\n                0x2116e976d592737e0c57dc12269efc,\n                0xe88a3202a09bdeaa3db69af98a651,\n                0x1618be,\n            ],\n        );\n        let signature: RBN4096 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x5d9212d0c25acc14b61c6ce61a844e,\n                0x9d369ae765eb0545f83f552b8d7bb6,\n                0x5f0f5d383bd70d7726a851c422fe29,\n                0xcff5886575636efcde5d9843e59a10,\n                0x5820fa1e3158154641adb2c28a8954,\n                0x03ce0301512be13c0317fb679e6348,\n                0x13ec0af966303ca69b6f7fece6c2f4,\n                0x58dcc592b80e4756a8d01224e6174f,\n                0x73610ba199750de1e35cd658cbae92,\n                0xeb1d49f1ecc3bf332b4048d978a46a,\n                0x8c9ad13691accdce88ce1e6fda0bf5,\n                0x425e80441351444e751cd86b97b464,\n                0xd25a9581921c44fba102ed92a75658,\n                0x698c73a7fc85fee22b1c7f04fb4600,\n                0x70267fc50db236dfcf1e9405e25856,\n                0x1a35b94cf56f801be96defed712afe,\n                0xa3ecae6965b3bdee416f8d506f64fd,\n                0xc875faf0fb4e4fa47ff65aba633529,\n                0x3ca01bcaf3c4a5eee7fa8fdf0e98,\n                0xa666b5d8c9f3217c412610ae91c862,\n                0x517ccc77102fa7799e521ef0e6d4e7,\n                0x7a50f7e553db75f0e0bd18d43bd622,\n                0x98e8da14444b6cf3d2b91d84da3506,\n                0xd1f5e4f7a725babc988cc7822c3d0a,\n                0x09ee2caa2e6f8b02db37ebe2352624,\n                0xd500b790312328a681b89b5de51b4f,\n                0x5ce0ebb445d4c82c3ecf21134c00bf,\n                0x83b6fafae79bc59f07e9b6802ef018,\n                0x8efd78556c637f8af6299ace0cd790,\n                0x5e99cf54d0f7e491cd72bcf20701fe,\n                0x19f15da137fe1bbe44c5531300829a,\n                0x0aae159f54317b49ec6b083292f57e,\n                0x37c2bba2237a59a35556f2d351c728,\n                0x7ec51821f03bde0c862e19e6ebe62c,\n                0x2081,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_2048_exponent_3() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x1c961b234309c24fdab3f3e8a09da1,\n                0xf4aa851a30a198c359f3779b6bf4e0,\n                0x844034a1488c79edf31b1711a5e547,\n                0xc83ad2f9b30cfcb6d5f7c152a78e62,\n                0x16e97e0f8d8bad08da76d859c575c6,\n                0x6a85158069b211820a596359d0dc47,\n                0x1b834ed69818f1aa7d9944dee07b20,\n                0x4d7148da361f1881cd4fd396ef46d2,\n                0xc4cf36bbfa2781703699abf19a1e6d,\n                0xca4bd632c8eb2c8051915c3530aef9,\n                0x9cbfd5681aa95ade8eb256925d60ea,\n                0x3b8153585ff5f1d7b1ed37ac709dc6,\n                0x7d741c118fd653af3c21848f789ed8,\n                0x7aefa65093c124e46405849ca82ad1,\n                0xf9dbb9414e8eb849e2532d3f55d0b9,\n                0x35aeee862ac76c20be58527220f6a,\n                0xa3b6f81f07963c34ff0168634f8a99,\n                0xc4,\n            ],\n            [\n                0xaf8e2d749a5966b98ffa10ea071d41,\n                0x83704b0ef8ae71e3f1a7d24d871556,\n                0x82903be42859c5bd5cbb935d1097fb,\n                0x5bdc4e1e26670ed73580e2c8c144c1,\n                0xce5178ff7019c4a6c0a2743ab2fae1,\n                0xfd9ba73654ecf2020bdfa6ed9dc777,\n                0x9ba95e3e7551ee261a4f10eca35f05,\n                0x9e09b71274e5df10e06a6ce6319c3f,\n                0xb14781efad91be0888f5150771eea5,\n                0x15d2f490d6ba3cf25ad91e5e2539b0,\n                0x7887aca3df2194cdbed904e6d42977,\n                0xb797f21802a052c11e5c205bcb7d21,\n                0x94d15b35eaf46e2fe69f2b60c02922,\n                0x73814f1d160107a3ff1081b0cd1fea,\n                0xaa4c31b61839c41980a8bb9c922a0c,\n                0x123cc9f0ad08747529171a2e286eb6,\n                0x7a8b658fe4e9b448debf21d8ea0cc0,\n                0x14d4,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x091a8c417287e046ec96c62b5ac66f,\n                0xbe71db0fe3122ea5624e8e7a0a72dc,\n                0xf35e5f3537c0ad0e938fdedd454de9,\n                0xd53c652cc3aac5d11fe6f5bc7ec536,\n                0x5d6869f0dd8b00697743f956b9b112,\n                0x5d46286274a1128a8fe0d96e859837,\n                0x951ee9dcb59dacebba972e9b9d7cfd,\n                0xd22245a462bff840a882f6869689a5,\n                0xcf7605b64a20dc2c3e6d5ceb88a03a,\n                0x7831aa25052c11411c3e5bdbe7dc10,\n                0x8e3bce799814987c984a2cc0e5d283,\n                0x7fdb0ce6e413e0f32742f4652f14a2,\n                0xa896a360bd70243209390e00761c57,\n                0x0d326051ac677371678f92bd182f13,\n                0xfcc593faaa9f45448ab756d70def,\n                0x2fd6d46ec8d25a6648dadf8246daf0,\n                0xe4aea2700222e610c1d94d82dd0f52,\n                0x9b,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 3));\n    }\n\n    // Test an unusual key length that is not a multiple of 8\n    /*#[test]\nfn test_verify_sha256_pss_1964() {\n    let sha256_hash: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n    let params: Params1964 = BigNumParams::new(\n        false,\n        [\n            0x75ac0d9987aebebd25983ab5a48fdf,\n            0xae0a5ffc69f51e789ea8f90a72745b,\n            0x9b8c92fb6ea3ca021a894ae52025f1,\n            0x50de84cce0d856376083aa1785fd38,\n            0xa912e3aabd4191e143128ce89e2086,\n            0xcf361d0e7f4fb458b950ca7f58414e,\n            0xe27bbefff3820e512b05a07d2d7e1c,\n            0x7a2fd42d837098a67f056f1b15ed33,\n            0x4ebeddd5d6fde42dc68ba5bb2a3732,\n            0x2d1cbcf87c37b430c33b04aa35ce2b,\n            0x9e9cd702ef1e7191c78e712ac6e151,\n            0x9aef318e4318c313c0cf0c71ba378b,\n            0xc1cd2e631f327acf58dca9f4e63bfd,\n            0xc828e43ce8acda48fa1fff12de4df4,\n            0x2d91364c2a898031a0ea615c82fe50,\n            0x3fed935e1e73af131b48aafef030d7,\n            0xc278be706ab,\n        ],\n        [\n            0xd4343ba7542877db4a663c12d159c,\n            0xb7f3ebb5e9a7e46abb5fa5ebebf068,\n            0x6f2ab6c72bbdcd87bf3cd5343f7059,\n            0xa437eae960f2ac5714f7a35b803598,\n            0xae01beec10904488485933615d62b6,\n            0xf9509a6004d765dfa27536888f2757,\n            0x57dbdd558fa8831a632849dbaecdfa,\n            0xe7c4027a23af2ef309461db1f95629,\n            0x388a2b780c78da825692f1cec5055e,\n            0xd064ac53ec3c505b8e8e25b9350ce7,\n            0x529b1374876a3bbf8e83e5d239cd69,\n            0x7206c8bf4a0d11655219207de991b4,\n            0x5fe1135077b5b760d31bdbfcb4f698,\n            0xdb00d1d10cdb6c91c0f93f4b1a18c8,\n            0x8329224ca1e3c5ef415cb1629f82d8,\n            0xecca0fb0c3e52adfd165bbf85b34eb,\n            0x150fec084e187,\n        ],\n    );\n    let signature: RBN1964 = RuntimeBigNum {\n        params,\n        limbs: [\n            0xbd4bab3d5a9af46cac40fc2f6c9547,\n            0xd3e04f0b8e833f1e80a4022684694f,\n            0xbb4267e4fc29ec83dc8398dc547fca,\n            0xba625b4fdf379883f6ccabede3574a,\n            0xc9736193ab3cc0d1ef8ea63fdba46f,\n            0x72dc058e8abcbe15ed09e97c1bb58a,\n            0x98d8c915cb9447bcce3bbfc0f92032,\n            0x9a0778461e9dec09e41c0ea354a41f,\n            0xe4a6b80a5f62abf93268cde64b5e9c,\n            0xd36dc0ccfdc6d9d8e8a939a3e762d0,\n            0x1b2593bff17ff433ee20f1a60c6861,\n            0x78115ebfd2484df0b59abfa3222e79,\n            0x7693ac9aa8acfb4b5379c0adbcb7d1,\n            0xd76979aa97b41f1f58c65ad896f1cf,\n            0xe1f7c4fa2dc6cbe0162be9adb01c14,\n            0x5f5a8f5b9ca6fe12c4fe3c00795f10,\n            0x8b4a98cedd,\n        ],\n    };\n\n    assert(verify_sha256_pss(sha256_hash, signature, 65537));\n}*/\n\n    // Test an edge case where the key length in bytes is greater than the encoded message length\n    #[test]\n    fn test_verify_sha256_pss_1025() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params1025 = BigNumParams::new(\n            false,\n            [\n                0xf278b138628000b2652c779e852235,\n                0x6d0676977e76ef0429002673ce9be2,\n                0x6cfc0db4d97f20ad2a1ad48cd899a0,\n                0x64024c19a1b1540e23ba4531e677f2,\n                0x3696125dd256ffed9567fccff06be6,\n                0x2dc09476b0c7629eed3c7c2cb591e3,\n                0x2e007f2f978504c5cfea0ec51ba0e9,\n                0x84ec9458cc6d0e95e06a7f404f26b4,\n                0x174fd186dca48668a,\n            ],\n            [\n                0x7ab08c63fb6eeee6204bd814d3134a,\n                0x20d51c551c06e8ae471cc43e84d131,\n                0x5eac3eae8238c6c2c37c1ce5bec407,\n                0xcff61632bd2ea6bc1dc8da002aa0c5,\n                0x801c1e85137856c4a6dc8c25078a59,\n                0x5ce8ee248cac12cbc3faa426acd58b,\n                0xe72384bb8302bbb78a3766fc61c5f0,\n                0x6ea716c0a657933b91b2d488b29cec,\n                0x2bed1ff958b58c194c,\n            ],\n        );\n\n        let signature: RBN1025 = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa90e06eff7cbd20dd9c1241fe89290,\n                0x9ff719ce8f34229cd248e1f0ef4246,\n                0xd1d032dbf236cd711aa4fb49f0c71f,\n                0x454abf136ae14c7617df3b4d505e08,\n                0x45f30ac2c023205d35803f114f8ee3,\n                0xc8b1265c786d6da808ab31d35795a1,\n                0x1f75005a85f3636b099c58edd9fb8e,\n                0xac251bf9bb342b551c0f5c80449a3f,\n                0x03e2bc114292962b,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha1_pkcs1v15_2048() {\n        let sha1_hash: [u8; 20] = sha1::sha1_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x156ceaf444d8819f2aedf0ba175481,\n                0xd3bf95380882ed1e760191e383dc84,\n                0x8585e65def5c89b3b3aeab9ceb6c80,\n                0xf215a93f61d5165db91d88a871368c,\n                0x5274e088a95fb4053f26fcc5619e6d,\n                0xf4494a491b66f30025ee633bed7a72,\n                0x801bdf85598a082dbac2b26a4fbff9,\n                0x9cd2905057dcca8c319d294785aa89,\n                0xb155d5581ec0bfd4096e6878b3bc25,\n                0xa0cfdf3decd16f8dde113e85a38c7b,\n                0x9452a725f9f2f3e82ebef589345c23,\n                0x1984df6bd68eaf0cc88b42b166ab6c,\n                0xff925851486b26af0a896eae9c7fe9,\n                0xe6fd92b72a2381389820a8ab283ff3,\n                0xbd5a35556d716ba8685d106a944555,\n                0xd9102f1ca16442372df5234fc4c23,\n                0xae1aa56a4a4e1b155af1ac4fbef88a,\n                0xdc,\n            ],\n            [\n                0x8ad3c9e65e7035db6d57a4182a4fb2,\n                0x9df5db4eabb63cb8306ba17ab7d99,\n                0x4177c0f5014aa2717306987d9ff827,\n                0xb35faed8cc169c33eecfac2341d47d,\n                0xff5faf8dbca65f1431a5d94d3a6d60,\n                0xbd49ab8984a0739a666a81bcf41f4,\n                0xb97ef986aa48a3f9c5160b1a9165c5,\n                0x3b34d06a7867dc8c0e9411bb389f30,\n                0x66ccff351294c073811e0e018e0917,\n                0x4bb0ee68c1f5ddebb71a9dd3a6df38,\n                0x29d2d550ec2d549320fec501d71108,\n                0x6609e5236bb550a30e29378259ed01,\n                0x4c33e3f52407cc796ba41acfaa3007,\n                0x6e6ec514bb4f26c0ac197aa2f995f2,\n                0x47967368b344f7c4fe0e84bdddc040,\n                0x1dc9219753dbeb4aa003c81b210e0e,\n                0x90dbe39955df1d4aa7c6efce2a8b3d,\n                0x128f,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x1999f7717a7fd287d0b3e2d66a3437,\n                0xc8fb6805554123679c362e6f002aae,\n                0x3facdc5f1def4f49606b908e2a2538,\n                0xc05aa4965a11190493a6f4e7fd5984,\n                0x1672f3416fb95821efcb5375f1779e,\n                0x2f81eb13f1894268f4acb1b0ae7513,\n                0x15d997bac63df6624c2603e93cb0fa,\n                0x536c959eea6cb9fc3980b86d9877b7,\n                0x4296d1c42936c208b6ae13cd06d60b,\n                0x39144ec79fc42ccc160b14c8b793e4,\n                0xc40a783835d9df4c5f69ba68faaa,\n                0xde2af88216d83b8136f094d8945b95,\n                0x4ecac07a39171bd9a01383a4919924,\n                0x737d8ffc839f4a503c431c507ba5f3,\n                0x844f4957cf4b01c277f67a7591b7f5,\n                0x0291a8afc7cda7e4c6e73e011c181f,\n                0x7afcd49577ffbc75fbe9a2e2959b82,\n                0x83,\n            ],\n        };\n\n        assert(verify_sha1_pkcs1v15(sha1_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha1_pss_2048() {\n        let sha1_hash: [u8; 20] = sha1::sha1_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x8076ee27cf6ed266e737de20b03e47,\n                0xbd07415cda0752a917b4f40d19c992,\n                0xd473ccfa4dc8a5690c17eceab674d4,\n                0xdf2645d4e31531b5e68d7b30152182,\n                0xe4e6d87d9b3222f56ddc48b46dc544,\n                0x587c5d66e6970f42fe18afa99b5e5b,\n                0x30261d8162c75fe7ba96ab0c2a6dd3,\n                0xdc69073390846c7fb3c98c9c316d60,\n                0x4b6a2bc2c1e5131129539c38b0ac3b,\n                0xf05187e8d7cf34d2c1685409173080,\n                0x2d26be5b0d792a3d92b7d4062b3d44,\n                0x4eb7f21f6c4e3df8d2829f6b3e6eaa,\n                0x9f1cd4d18bd53d4bbcf804651435f3,\n                0x3d266b2f1223e08dd2159d58cb48d4,\n                0x873625d48c8244c51924bfdee0c6ac,\n                0xfcbf5c61a9d3cf2d0e13686af8d0de,\n                0xb4345e8b5be7510698390901722861,\n                0xba,\n            ],\n            [\n                0x51b40d9d6a288a5396a16f9fc85f2a,\n                0xbc36a9bf43ffceed626f118da3b290,\n                0xdcff05073f93178b589ab93edcfa9d,\n                0x42fe8b2c11fb9eb89432cd017ecae3,\n                0x7c74c2b03dc0a6ef97319821e6adaa,\n                0xf35c6951909aa944366d8e5f8f435f,\n                0x211b51cea0e9e9db01a1803ff9d995,\n                0xe9632ae2bbff5ecfb13344716976aa,\n                0x5ac98d1f7f9796c5f4360a6c53c0ac,\n                0x21cad5d27ccd949ab83384e613df0f,\n                0x7305d4a53c3121804a7e563663ac19,\n                0x42f7f8514dc823f5cec8029950f51d,\n                0x88af0d59283ad9e8ceadd7275f9665,\n                0xe377f531eb845e3ae55cb1f4f00845,\n                0x863da2aa3bd54edc8b6da777626340,\n                0xe92dc9d46715752498a8eda776a039,\n                0x401e4c6793f0bc7f5da805da5cd5bb,\n                0x15f0,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x835c0b9302499888acedea4013ec92,\n                0xe1f4b56b2ca0ad8c1ee3b8a9a85d93,\n                0x5d4fecc54034eb1091ca9fc28e3ff1,\n                0xab316868780469b1621c789b8d8b75,\n                0x13205cae60d93b387ef282c901bb,\n                0x776e846d321b59b584c6de6ae6da18,\n                0x6170c33330baeaee6a3de84e32f031,\n                0x3862d9f28a50c32f0f09a6e5e60560,\n                0x83e54c8d5a9522e5addc4cb35078b1,\n                0xf4cd91425b0b042fb1cbb81d0ce6d6,\n                0x33c49780bb4c00637bfd9f5de1d1cc,\n                0xcbd14e26c78a769ff0e47854ff9d72,\n                0x459db8d780c5287c894d8d419ec583,\n                0x19909716db20e09223fbc169d58ed4,\n                0x62efd0331023145d761b8568fc93c9,\n                0xcac052c722d08645d4ad31464f665a,\n                0x33c6a0e25cd27dbfd1d15fc2197aa5,\n                0x89,\n            ],\n        };\n\n        assert(verify_sha1_pss(sha1_hash, signature, 65537));\n    }\n\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/zkpassport/noir_rsa/saleel/sha-version/src/rsa.nr"
        },
        "164": {
            "source": "mod utils;\n\npub use utils::{conditional_select, DebugRandomEngine};\nuse std::collections::bounded_vec::BoundedVec;\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"haystack\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @details the \"body\" parameter contains some input bytes, zero-padded to the nearest multiple of 31\n *          We pack \"bytes\" into 31-byte \"chunks\", as this is the maximum number of bytes we can fit\n *          into a field element without overflowing.\n *          TODO: once we can derive generics via arithmetic on other generics, we want this \"31\" parameter\n *          to be defined by the backend being used instead of being hardcoded to 31\n *\n * @note We perform this 31-byte packing because it dramatically reduces the number of constraints required for substring matching. See (chicken)\n *\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunks: the number of 31-byte chunks needed to represent MaxPaddedBytes\n **/\npub struct StringBody<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    chunks: [Field; PaddedChunks],\n    pub byte_length: u32,\n}\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"needle\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunksMinusOne: the number of 31-byte chunks needed to represent MaxPaddedBytes minus one!\n *\n * @note PaddedChunksMinusOne is because we are going to do the following:\n *                            1. align the SubString bytes according to the StringBody bytes being matched against\n *                            2. split the aligned bytes into 31-byte chunks. The 1st and last chunks might contain\n *                               fewer than 31 bytes due to the above alignment\n *                            3. validate the aligned-byte-chunks match the StringBody byte chunks\n *       To account for the fact that the 1st and last chunks might have fewer bytes we treat those separately\n *       The param PaddedChunksMinusOne is the number of 31-byte chunks required to represent SubString *EXCLUDING* the initial and final chunks\n */\npub struct SubString<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    pub byte_length: u32,\n}\n\npub type StringBody32 = StringBody<62, 2, 32>;\npub type StringBody64 = StringBody<93, 3, 64>;\npub type StringBody128 = StringBody<155, 5, 128>;\npub type StringBody256 = StringBody<279, 9, 256>;\npub type StringBody512 = StringBody<527, 17, 512>;\npub type StringBody1024 = StringBody<1054, 34, 1024>;\npub type StringBody2048 = StringBody<2077, 67, 2048>;\npub type StringBody4096 = StringBody<4123, 133, 4096>;\npub type StringBody8192 = StringBody<8215, 265, 8192>;\npub type StringBody16384 = StringBody<16399, 529, 16384>;\n\npub type SubString32 = SubString<62, 1, 32>;\npub type SubString64 = SubString<93, 2, 64>;\npub type SubString128 = SubString<155, 4, 128>;\npub type SubString256 = SubString<279, 8, 256>;\npub type SubString512 = SubString<527, 16, 512>;\npub type SubString1024 = SubString<1054, 33, 1024>;\n\npub trait SubStringTrait {\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        num_bytes_in_first_chunk: u32,\n        body_chunk_offset: u32,\n        num_full_chunks: u32,\n    );\n\n    fn len(self) -> u32;\n    fn get(self, idx: u32) -> u8;\n    fn get_body(self) -> [u8];\n}\n\n// ######################################################\n// S U B S T R I N G\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    /**\n     * @brief construct a SubString object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(input: [u8; InputBytes], input_length: u32) -> Self {\n        assert(MaxBytes <= MaxPaddedBytes);\n        assert(input_length <= MaxBytes);\n        assert(InputBytes <= MaxBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together\n     * @details each SubString can have different MaxBytes sizes, however we need OtherBytes <= MaxBytes\n     *          (use concat_into for cases where this is not the case)\n     **/\n    pub fn concat<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> Self {\n        assert(\n            OtherPaddedBytes <= MaxPaddedBytes,\n            \"SubString::concat. SubString being concatted has larger max length. Try calling concat_into\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxPaddedBytes,\n            \"SubString::concat, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body = self.body;\n        let offset: u32 = self.byte_length;\n        for i in 0..MaxPaddedBytes {\n            if (i + offset < MaxPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together. Return type has OtherPaddedBytes max bytes\n     * @details each SubString can have different MaxBytes sizes, however we need MaxBytes <= OtherBytes\n     *          (use concat for cases where this is not the case)\n     **/\n    pub fn concat_into<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes> {\n        assert(\n            MaxPaddedBytes <= OtherPaddedBytes,\n            \"SubString::concat_into. SubString being concat has larger max length. Try calling concat\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= OtherPaddedBytes,\n            \"SubString::concat_into, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body: [u8; OtherPaddedBytes] = [0; OtherPaddedBytes];\n        for i in 0..MaxBytes {\n            body[i] = self.body[i];\n        }\n\n        let offset: u32 = self.byte_length;\n        for i in 0..OtherPaddedBytes {\n            if (i + offset < OtherPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubStringTrait for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    fn len(self) -> u32 {\n        self.byte_length\n    }\n    fn get(self, idx: u32) -> u8 {\n        self.body[idx]\n    }\n    fn get_body(self) -> [u8] {\n        let x = self.body.as_slice();\n        x\n    }\n\n    /**\n     * @brief given some `haystack` 31-byte chunks, validate that there exist `num_full_chunks`\n     *        in the SubString, starting at byte position `starting_needle_byte`.\n     *        The selected chunks must be equal to the haystack chunks starting at `starting_haystack_chunk`\n     **/\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        starting_needle_byte: u32,\n        starting_haystack_chunk: u32,\n        num_full_chunks: u32,\n    ) {\n        let mut substring_chunks: [Field; PaddedChunksMinusOne] = [0; PaddedChunksMinusOne];\n        // pack the substring into 31 byte chunks.\n        // This is fairly expensive as we need a ROM table to access the SubString.body\n        // which is 2 gates per byte\n        for i in 0..PaddedChunksMinusOne {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let substring_idx = starting_needle_byte + (i * 31) + j;\n                let mut byte = self.body[substring_idx];\n                slice += byte as Field;\n            }\n            std::as_witness(slice);\n            substring_chunks[i] = slice;\n        }\n        // iterate over the needle chunks and validate they match the haystack chunks\n        for i in 0..PaddedChunksMinusOne {\n            let predicate = i < num_full_chunks;\n            let lhs = substring_chunks[i];\n            let rhs = haystack[predicate as u32 * (i + starting_haystack_chunk)];\n            assert(predicate as Field * (lhs - rhs) == 0);\n        }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n// ######################################################\n// S T R I N G   B O D Y\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> StringBody<MaxPaddedBytes, PaddedChunks, MaxBytes> {\n\n    /**\n     * @brief construct a StringBody object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(data: [u8; InputBytes], length: u32) -> Self {\n        assert(length <= MaxBytes);\n        assert(length <= InputBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = data[i];\n        }\n        StringBody { body, chunks: compute_chunks(body), byte_length: length }\n    }\n\n    /**\n     * @brief Validate a substring exists in the StringBody. Returns a success flag and the position within the StringBody that the match was found\n     **/\n    pub fn substring_match<NeedleSubString>(self, substring: NeedleSubString) -> (bool, u32)\n    where\n        NeedleSubString: SubStringTrait,\n    {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text\n        let position: u32 = unsafe {\n            // Safety: The rest of this function checks this.\n            utils::search(\n                self.body,\n                substring.get_body(),\n                self.byte_length,\n                substring.len(),\n            )\n        };\n\n        assert(\n            position + substring.len() <= self.byte_length,\n            \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\",\n        );\n        let substring_length = substring.len();\n\n        // chunk_index = which 31-byte haystack chunk does the needle begin in?\n        let chunk_index: u32 = position / 31;\n        // chunk_offset = how many haystack bytes are present in the 1st haystack chunk?\n        let chunk_offset: u32 = position % 31;\n        // how many needle bytes are in 1st haystack chunk?\n        let num_bytes_in_first_chunk: u32 = 31 - chunk_offset;\n        let mut starting_needle_byte_index_of_final_chunk: u32 = 0;\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes: u32 = 0;\n        let mut num_full_chunks = 0;\n\n        // is there only one haystack chunk that contains needle bytes?\n        let merge_initial_final_needle_chunks = substring_length < num_bytes_in_first_chunk;\n\n        // if the above is false...\n        if (!merge_initial_final_needle_chunks) {\n            // compute how many full 31-byte haystack chunks contain 31 needle bytes\n            num_full_chunks = (substring_length - num_bytes_in_first_chunk) / 31;\n            // for the final haystack chunk that contains needle bytes, where in the needle does this chunk begin?\n            starting_needle_byte_index_of_final_chunk =\n                num_full_chunks * 31 + num_bytes_in_first_chunk;\n\n            // what is the index of the final haystack chunk that contains needle bytes?\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes =\n                num_full_chunks + chunk_index + 1;\n        } else {\n            starting_needle_byte_index_of_final_chunk = 0;\n            // if the needle bytes does NOT span more than 1 haystack chunk,\n            // the final haystack index will be the same as the initial haystack index\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index;\n        }\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n        when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n        a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n        Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n        The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n        If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let offset_to_first_needle_byte_in_chunk: u32 = chunk_offset;\n        let initial_haystack_chunk = self.chunks[chunk_index];\n        let final_haystack_chunk =\n            self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n\n        let initial_body_bytes: [u8; 31] = initial_haystack_chunk.to_be_bytes();\n        let final_body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes();\n\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: u32 = i;\n            let predicate = i < offset_to_first_needle_byte_in_chunk;\n            let lhs: Field = initial_body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = if predicate {\n                0\n            } else {\n                idx - offset_to_first_needle_byte_in_chunk\n            };\n            let rhs: Field = substring.get(substring_idx) as Field;\n            let byte: Field = predicate as Field * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // If `merge_initial_final_needle_chunks = true`, `final_chunk` will contain the full needle data,\n        // this requires some complex logic to determine where we are sourcing the needle bytes from.\n        // Either they come from the `initial_chunk`, the haystack bytes or the substring bytes.\n        for i in 0..31 {\n            let mut lhs_index = starting_needle_byte_index_of_final_chunk + i;\n            let predicate = lhs_index < substring_length;\n            /*\n                | merge_initial_final_needle_chunks | predicate | byte_source              |\n                | false                             | false     | body_bytes[i]            |\n                | false                             | true      | substring[lhs_idx]       |\n                | true                              | false     | body_bytes[i]            |\n                | true                              | true      | initial_chunk[lhs_index] |\n            NOTE: if `merge = true` and `predicate = true`, we read from `initial_chunk` to short-circuit some extra logic.\n                      if `initial_chunk` did not exist, then we would need to validate whether `i < offset_to_first_needle_byte_in_chunk`.\n                      if true, the byte source would be body_bytes, otherwise the source would be substring bytes\n            */\n            let substring_idx = (predicate as u32) * lhs_index;\n            let byte_from_substring = substring.get(substring_idx) as Field;\n            let byte_from_initial_chunk = initial_chunk[i] as Field;\n            let byte_from_haystack = final_body_bytes[i] as Field;\n\n            // TODO: find out why this cuts 1 gate per iteration\n            std::as_witness(byte_from_initial_chunk);\n\n            let p = predicate as Field;\n            let m = merge_initial_final_needle_chunks as Field;\n            // p * (m * (a - b) + (b - c)) + c\n            let ab = byte_from_initial_chunk - byte_from_substring;\n            std::as_witness(ab);\n            let bc = byte_from_substring - byte_from_haystack;\n            let t0 = m * ab + bc;\n            let destination_byte = p * t0 + byte_from_haystack;\n\n            final_chunk[i] = destination_byte;\n        }\n\n        // TODO: moving this above the previous code block adds 31 gates. find out why? :/\n        let mut initial_needle_chunk: Field = 0;\n        let mut final_needle_chunk: Field = 0;\n\n        // Construct the initial and final needle chunks from the byte arrays we previously built.\n        // Validate they match the initial and final haystack chunks\n        for i in 0..31 {\n            initial_needle_chunk *= 256;\n            initial_needle_chunk += initial_chunk[i];\n            final_needle_chunk *= 256;\n            final_needle_chunk += final_chunk[i];\n        }\n\n        std::as_witness(initial_needle_chunk);\n        std::as_witness(final_needle_chunk);\n\n        initial_needle_chunk = merge_initial_final_needle_chunks as Field\n            * (final_needle_chunk - initial_needle_chunk)\n            + initial_needle_chunk;\n        assert(initial_needle_chunk == initial_haystack_chunk);\n        assert(final_needle_chunk == final_haystack_chunk);\n\n        // Step 3: Construct needle chunks (for all but the 1st and last chunks) and validate they match the haystack chunks.\n        //         This part is much simpler as we know that all bytes in the chunk are sourced from the needle chunk.\n        // NOTE:   If we chose to not pack bytes into 31-byte chunks, the string matching algorithm would be simpler but more expensive.\n        //         Instead of matching chunks with each other, we would match individual byte values.\n        //         i.e. the number of iterations in this loop would be 31x greater\n        //         each loop iteration would also require a predicate, to check whether the byte index was within the needle range or not\n        //         Combined these two operations would add about 10 gates per loop iteration,\n        //         combined with a 31x iteration length would make this algorithm much more costly than the chunked variant\n        let body_chunk_offset = chunk_index + 1;\n        substring.match_chunks(\n            self.chunks,\n            num_bytes_in_first_chunk,\n            body_chunk_offset,\n            num_full_chunks,\n        );\n        (true, position)\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for StringBody<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n/// Given an input byte array, convert into 31-byte chunks\n///\n/// Cost: ~0.5 gates per byte\nfn compute_chunks<let MaxPaddedBytes: u32, let PaddedChunks: u32>(\n    body: [u8; MaxPaddedBytes],\n) -> [Field; PaddedChunks] {\n    let mut chunks: [Field; PaddedChunks] = [0; PaddedChunks];\n    for i in 0..PaddedChunks {\n        let mut limb: Field = 0;\n        for j in 0..31 {\n            limb *= 256;\n            limb += body[i * 31 + j] as Field;\n        }\n        chunks[i] = limb;\n        std::as_witness(chunks[i]);\n    }\n    chunks\n}\n\n#[test]\nfn test() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \"olor\".as_bytes();\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString32 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog\".as_bytes();\n    let needle_text = \" the lazy dog\".as_bytes();\n\n    let mut haystack: StringBody256 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString256 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_haystack_equal_size() {\n    let haystack_text =\n        \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n    let needle_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n\n    let mut haystack: StringBody64 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_concat() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString128 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nfn test_concat_into() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat_into(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nunconstrained fn test_partial_match() {\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 1024] = Engine.get_random_bytes();\n    let mut bar: [u8; 128] = [0; 128];\n    for i in 0..128 {\n        bar[i] = foo[i + 123];\n    }\n    let position = utils::search(foo, bar.as_slice(), 1024, 128);\n\n    assert(position == 123);\n}\n\n#[test]\nfn test_substring_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_string_body_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn regression_20() {\n    let haystack: [u8; 128] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x92, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x6e, 0x00, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    let needle: [u8; 32] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    let needle_len: u32 = 0x20;\n    let id_haystack: StringBody128 = StringBody::new(haystack, 128);\n    let pk_needle: SubString32 = SubString::new(needle, needle_len);\n    let (result, _): (bool, u32) = id_haystack.substring_match(pk_needle);\n    assert(result);\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/lib.nr"
        },
        "165": {
            "source": "pub unconstrained fn search<let N: u32>(\n    haystack: [u8; N],\n    needle: [u8],\n    haystack_length: u32,\n    needle_length: u32,\n) -> u32 {\n    assert(needle_length > 0, \"needle length of size 0 not supported\");\n    assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n    let mut found = false;\n    let mut found_index: u32 = 0;\n    for i in 0..haystack_length - needle_length + 1 {\n        if (found == true) {\n            break;\n        }\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    assert(found == true, \"utils::search could not find needle in haystack\");\n    found_index\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    if (predicate) {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    // Safety: This is all just a very verbose `if (predicate) { lhs } else { rhs }`\n    // formulated as `rhs + (lhs - rhs) * predicate`\n    unsafe {\n        let result = __conditional_select(lhs, rhs, predicate);\n        let result_f = result as Field;\n        let lhs_f = lhs as Field;\n        let rhs_f = rhs as Field;\n\n        let diff = lhs_f - rhs_f;\n        std::as_witness(diff);\n        assert_eq((predicate as Field) * diff + rhs_f, result_f);\n        result\n    }\n}\n\npub struct DebugRandomEngine {\n    pub seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes();\n        let hash: [u8; 32] = std::hash::blake3(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    pub unconstrained fn get_random_bytes<let NBytes: u32>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u32;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n",
            "path": "/Users/unomasanori/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/utils.nr"
        }
    },
    "names": [
        "main"
    ],
    "brillig_names": [
        "remove_extra_zeros_from_partial_data",
        "print_unconstrained",
        "build_msg_block_iter",
        "pad_msg_block",
        "attach_len_to_msg_block",
        "__mul",
        "compute_quadratic_expression_with_borrow_flags",
        "extract_claim_unconstrained",
        "__boundary_check",
        "__validate_decoded",
        "search",
        "extract_claim_unconstrained",
        "get_domain_start_index_in_email",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
    ]
}